/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#include "bool2x2.h"
#include "bool2x3.h"
#include "bool2x4.h"
#include "bool3x2.h"
#include "bool3x3.h"
#include "bool3x4.h"
#include "bool4x2.h"
#include "bool4x3.h"
#include "bool4x4.h"

#include "int2x2.h"
#include "int2x3.h"
#include "int2x4.h"
#include "int3x2.h"
#include "int3x3.h"
#include "int3x4.h"
#include "int4x2.h"
#include "int4x3.h"
#include "int4x4.h"

#include "uint2x2.h"
#include "uint2x3.h"
#include "uint2x4.h"
#include "uint3x2.h"
#include "uint3x3.h"
#include "uint3x4.h"
#include "uint4x2.h"
#include "uint4x3.h"
#include "uint4x4.h"

#include "float2x2.h"
#include "float2x3.h"
#include "float2x4.h"
#include "float3x2.h"
#include "float3x3.h"
#include "float3x4.h"
#include "float4x2.h"
#include "float4x3.h"
#include "float4x4.h"

#include "double2x2.h"
#include "double2x3.h"
#include "double2x4.h"
#include "double3x2.h"
#include "double3x3.h"
#include "double3x4.h"
#include "double4x2.h"
#include "double4x3.h"
#include "double4x4.h"

#include "hlml_functions_vector.h"

// bool2x2
/// \relates bool2x2
/// \brief Returns true if the all the components of the left-hand-side bool2x2 match the other one, otherwise returns false.
inline bool bool2x2_cmpe( const bool2x2* lhs, const bool2x2* rhs );

/// \relates bool2x2
/// \brief Returns true if not all of the components of the left-hand-side bool2x2 match the other one, otherwise returns false.
inline bool bool2x2_cmpne( const bool2x2* lhs, const bool2x2* rhs );

/// \relates bool2x2
/// \brief Sets the matrix to an identity matrix.
inline void bool2x2_identity( bool2x2* mat );

/// \relates bool2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x2 bool2x2_transpose( const bool2x2* mat );


// bool2x3
/// \relates bool2x3
/// \brief Returns true if the all the components of the left-hand-side bool2x3 match the other one, otherwise returns false.
inline bool bool2x3_cmpe( const bool2x3* lhs, const bool2x3* rhs );

/// \relates bool2x3
/// \brief Returns true if not all of the components of the left-hand-side bool2x3 match the other one, otherwise returns false.
inline bool bool2x3_cmpne( const bool2x3* lhs, const bool2x3* rhs );

/// \relates bool2x3
/// \brief Sets the matrix to an identity matrix.
inline void bool2x3_identity( bool2x3* mat );

/// \relates bool2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x2 bool2x3_transpose( const bool2x3* mat );


// bool2x4
/// \relates bool2x4
/// \brief Returns true if the all the components of the left-hand-side bool2x4 match the other one, otherwise returns false.
inline bool bool2x4_cmpe( const bool2x4* lhs, const bool2x4* rhs );

/// \relates bool2x4
/// \brief Returns true if not all of the components of the left-hand-side bool2x4 match the other one, otherwise returns false.
inline bool bool2x4_cmpne( const bool2x4* lhs, const bool2x4* rhs );

/// \relates bool2x4
/// \brief Sets the matrix to an identity matrix.
inline void bool2x4_identity( bool2x4* mat );

/// \relates bool2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x2 bool2x4_transpose( const bool2x4* mat );


// bool3x2
/// \relates bool3x2
/// \brief Returns true if the all the components of the left-hand-side bool3x2 match the other one, otherwise returns false.
inline bool bool3x2_cmpe( const bool3x2* lhs, const bool3x2* rhs );

/// \relates bool3x2
/// \brief Returns true if not all of the components of the left-hand-side bool3x2 match the other one, otherwise returns false.
inline bool bool3x2_cmpne( const bool3x2* lhs, const bool3x2* rhs );

/// \relates bool3x2
/// \brief Sets the matrix to an identity matrix.
inline void bool3x2_identity( bool3x2* mat );

/// \relates bool3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x3 bool3x2_transpose( const bool3x2* mat );


// bool3x3
/// \relates bool3x3
/// \brief Returns true if the all the components of the left-hand-side bool3x3 match the other one, otherwise returns false.
inline bool bool3x3_cmpe( const bool3x3* lhs, const bool3x3* rhs );

/// \relates bool3x3
/// \brief Returns true if not all of the components of the left-hand-side bool3x3 match the other one, otherwise returns false.
inline bool bool3x3_cmpne( const bool3x3* lhs, const bool3x3* rhs );

/// \relates bool3x3
/// \brief Sets the matrix to an identity matrix.
inline void bool3x3_identity( bool3x3* mat );

/// \relates bool3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x3 bool3x3_transpose( const bool3x3* mat );


// bool3x4
/// \relates bool3x4
/// \brief Returns true if the all the components of the left-hand-side bool3x4 match the other one, otherwise returns false.
inline bool bool3x4_cmpe( const bool3x4* lhs, const bool3x4* rhs );

/// \relates bool3x4
/// \brief Returns true if not all of the components of the left-hand-side bool3x4 match the other one, otherwise returns false.
inline bool bool3x4_cmpne( const bool3x4* lhs, const bool3x4* rhs );

/// \relates bool3x4
/// \brief Sets the matrix to an identity matrix.
inline void bool3x4_identity( bool3x4* mat );

/// \relates bool3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x3 bool3x4_transpose( const bool3x4* mat );


// bool4x2
/// \relates bool4x2
/// \brief Returns true if the all the components of the left-hand-side bool4x2 match the other one, otherwise returns false.
inline bool bool4x2_cmpe( const bool4x2* lhs, const bool4x2* rhs );

/// \relates bool4x2
/// \brief Returns true if not all of the components of the left-hand-side bool4x2 match the other one, otherwise returns false.
inline bool bool4x2_cmpne( const bool4x2* lhs, const bool4x2* rhs );

/// \relates bool4x2
/// \brief Sets the matrix to an identity matrix.
inline void bool4x2_identity( bool4x2* mat );

/// \relates bool4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x4 bool4x2_transpose( const bool4x2* mat );


// bool4x3
/// \relates bool4x3
/// \brief Returns true if the all the components of the left-hand-side bool4x3 match the other one, otherwise returns false.
inline bool bool4x3_cmpe( const bool4x3* lhs, const bool4x3* rhs );

/// \relates bool4x3
/// \brief Returns true if not all of the components of the left-hand-side bool4x3 match the other one, otherwise returns false.
inline bool bool4x3_cmpne( const bool4x3* lhs, const bool4x3* rhs );

/// \relates bool4x3
/// \brief Sets the matrix to an identity matrix.
inline void bool4x3_identity( bool4x3* mat );

/// \relates bool4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x4 bool4x3_transpose( const bool4x3* mat );


// bool4x4
/// \relates bool4x4
/// \brief Returns true if the all the components of the left-hand-side bool4x4 match the other one, otherwise returns false.
inline bool bool4x4_cmpe( const bool4x4* lhs, const bool4x4* rhs );

/// \relates bool4x4
/// \brief Returns true if not all of the components of the left-hand-side bool4x4 match the other one, otherwise returns false.
inline bool bool4x4_cmpne( const bool4x4* lhs, const bool4x4* rhs );

/// \relates bool4x4
/// \brief Sets the matrix to an identity matrix.
inline void bool4x4_identity( bool4x4* mat );

/// \relates bool4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x4 bool4x4_transpose( const bool4x4* mat );


// int2x2
/// \relates int2x2
/// \brief Returns true if the all the components of the left-hand-side int2x2 match the other one, otherwise returns false.
inline bool int2x2_cmpe( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns true if not all of the components of the left-hand-side int2x2 match the other one, otherwise returns false.
inline bool int2x2_cmpne( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise added by the given scalar value.
inline int2x2 int2x2_comp_adds( const int2x2* lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise added by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_comp_addm( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise subtracted by the given scalar value.
inline int2x2 int2x2_comp_subs( const int2x2* lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise subtracted by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_comp_subm( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise multiplied by the given scalar value.
inline int2x2 int2x2_comp_muls( const int2x2* lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise multiplied by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_comp_mulm( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise divided by the given scalar value.
inline int2x2 int2x2_comp_divs( const int2x2* lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise divided by the corresponding component of the right-hand int2x2.
inline int2x2 int2x2_comp_divm( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise AND'd against the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_comp_and( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise OR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_comp_or( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise XOR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_comp_xor( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Performs a unary bitwise operation on all components of the given int2x2.
inline int2x2 int2x2_comp_unary( const int2x2* lhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise left-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_comp_shift_left( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise right-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 int2x2_comp_shift_right( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 int2x2_cmpl( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 int2x2_cmple( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 int2x2_cmpg( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 int2x2_cmpge( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Sets the matrix to an identity matrix.
inline void int2x2_identity( int2x2* mat );

/// \relates int2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x2 int2x2_transpose( const int2x2* mat );

/// \relates int2x2
/// \brief Returns the determinant of the matrix.
inline int32_t int2x2_determinant( const int2x2* mat );

/// \relates int2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 int2x2_mulm( const int2x2* lhs, const int2x2* rhs );

/// \relates int2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline int2 int2x2_mulv( const int2x2* lhs, const int2* rhs );


// int2x3
/// \relates int2x3
/// \brief Returns true if the all the components of the left-hand-side int2x3 match the other one, otherwise returns false.
inline bool int2x3_cmpe( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns true if not all of the components of the left-hand-side int2x3 match the other one, otherwise returns false.
inline bool int2x3_cmpne( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise added by the given scalar value.
inline int2x3 int2x3_comp_adds( const int2x3* lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise added by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_comp_addm( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise subtracted by the given scalar value.
inline int2x3 int2x3_comp_subs( const int2x3* lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise subtracted by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_comp_subm( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise multiplied by the given scalar value.
inline int2x3 int2x3_comp_muls( const int2x3* lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise multiplied by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_comp_mulm( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise divided by the given scalar value.
inline int2x3 int2x3_comp_divs( const int2x3* lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise divided by the corresponding component of the right-hand int2x3.
inline int2x3 int2x3_comp_divm( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise AND'd against the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_comp_and( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise OR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_comp_or( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise XOR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_comp_xor( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Performs a unary bitwise operation on all components of the given int2x3.
inline int2x3 int2x3_comp_unary( const int2x3* lhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise left-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_comp_shift_left( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise right-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 int2x3_comp_shift_right( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 int2x3_cmpl( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 int2x3_cmple( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 int2x3_cmpg( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 int2x3_cmpge( const int2x3* lhs, const int2x3* rhs );

/// \relates int2x3
/// \brief Sets the matrix to an identity matrix.
inline void int2x3_identity( int2x3* mat );

/// \relates int2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x2 int2x3_transpose( const int2x3* mat );

/// \relates int2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 int2x3_mulm( const int2x3* lhs, const int3x2* rhs );

/// \relates int2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int2x3 int2x3_scale( const int2x3* mat, const int2* vec );


// int2x4
/// \relates int2x4
/// \brief Returns true if the all the components of the left-hand-side int2x4 match the other one, otherwise returns false.
inline bool int2x4_cmpe( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns true if not all of the components of the left-hand-side int2x4 match the other one, otherwise returns false.
inline bool int2x4_cmpne( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise added by the given scalar value.
inline int2x4 int2x4_comp_adds( const int2x4* lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise added by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_comp_addm( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise subtracted by the given scalar value.
inline int2x4 int2x4_comp_subs( const int2x4* lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise subtracted by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_comp_subm( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise multiplied by the given scalar value.
inline int2x4 int2x4_comp_muls( const int2x4* lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise multiplied by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_comp_mulm( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise divided by the given scalar value.
inline int2x4 int2x4_comp_divs( const int2x4* lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise divided by the corresponding component of the right-hand int2x4.
inline int2x4 int2x4_comp_divm( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise AND'd against the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_comp_and( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise OR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_comp_or( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise XOR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_comp_xor( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Performs a unary bitwise operation on all components of the given int2x4.
inline int2x4 int2x4_comp_unary( const int2x4* lhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise left-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_comp_shift_left( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise right-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 int2x4_comp_shift_right( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 int2x4_cmpl( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 int2x4_cmple( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 int2x4_cmpg( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 int2x4_cmpge( const int2x4* lhs, const int2x4* rhs );

/// \relates int2x4
/// \brief Sets the matrix to an identity matrix.
inline void int2x4_identity( int2x4* mat );

/// \relates int2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x2 int2x4_transpose( const int2x4* mat );

/// \relates int2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 int2x4_mulm( const int2x4* lhs, const int4x2* rhs );

/// \relates int2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int2x4 int2x4_scale( const int2x4* mat, const int2* vec );


// int3x2
/// \relates int3x2
/// \brief Returns true if the all the components of the left-hand-side int3x2 match the other one, otherwise returns false.
inline bool int3x2_cmpe( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns true if not all of the components of the left-hand-side int3x2 match the other one, otherwise returns false.
inline bool int3x2_cmpne( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise added by the given scalar value.
inline int3x2 int3x2_comp_adds( const int3x2* lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise added by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_comp_addm( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise subtracted by the given scalar value.
inline int3x2 int3x2_comp_subs( const int3x2* lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise subtracted by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_comp_subm( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise multiplied by the given scalar value.
inline int3x2 int3x2_comp_muls( const int3x2* lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise multiplied by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_comp_mulm( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise divided by the given scalar value.
inline int3x2 int3x2_comp_divs( const int3x2* lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise divided by the corresponding component of the right-hand int3x2.
inline int3x2 int3x2_comp_divm( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise AND'd against the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_comp_and( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise OR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_comp_or( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise XOR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_comp_xor( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Performs a unary bitwise operation on all components of the given int3x2.
inline int3x2 int3x2_comp_unary( const int3x2* lhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise left-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_comp_shift_left( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise right-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 int3x2_comp_shift_right( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 int3x2_cmpl( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 int3x2_cmple( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 int3x2_cmpg( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 int3x2_cmpge( const int3x2* lhs, const int3x2* rhs );

/// \relates int3x2
/// \brief Sets the matrix to an identity matrix.
inline void int3x2_identity( int3x2* mat );

/// \relates int3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x3 int3x2_transpose( const int3x2* mat );

/// \relates int3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 int3x2_mulm( const int3x2* lhs, const int2x3* rhs );


// int3x3
/// \relates int3x3
/// \brief Returns true if the all the components of the left-hand-side int3x3 match the other one, otherwise returns false.
inline bool int3x3_cmpe( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns true if not all of the components of the left-hand-side int3x3 match the other one, otherwise returns false.
inline bool int3x3_cmpne( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise added by the given scalar value.
inline int3x3 int3x3_comp_adds( const int3x3* lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise added by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_comp_addm( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise subtracted by the given scalar value.
inline int3x3 int3x3_comp_subs( const int3x3* lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise subtracted by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_comp_subm( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise multiplied by the given scalar value.
inline int3x3 int3x3_comp_muls( const int3x3* lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise multiplied by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_comp_mulm( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise divided by the given scalar value.
inline int3x3 int3x3_comp_divs( const int3x3* lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise divided by the corresponding component of the right-hand int3x3.
inline int3x3 int3x3_comp_divm( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise AND'd against the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_comp_and( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise OR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_comp_or( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise XOR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_comp_xor( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Performs a unary bitwise operation on all components of the given int3x3.
inline int3x3 int3x3_comp_unary( const int3x3* lhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise left-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_comp_shift_left( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise right-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 int3x3_comp_shift_right( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 int3x3_cmpl( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 int3x3_cmple( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 int3x3_cmpg( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 int3x3_cmpge( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Sets the matrix to an identity matrix.
inline void int3x3_identity( int3x3* mat );

/// \relates int3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x3 int3x3_transpose( const int3x3* mat );

/// \relates int3x3
/// \brief Returns the determinant of the matrix.
inline int32_t int3x3_determinant( const int3x3* mat );

/// \relates int3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 int3x3_mulm( const int3x3* lhs, const int3x3* rhs );

/// \relates int3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline int3 int3x3_mulv( const int3x3* lhs, const int3* rhs );

/// \relates int3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int3x3 int3x3_translate( const int3x3* mat, const int2* vec );

/// \relates int3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int3x3 int3x3_scale( const int3x3* mat, const int2* vec );


// int3x4
/// \relates int3x4
/// \brief Returns true if the all the components of the left-hand-side int3x4 match the other one, otherwise returns false.
inline bool int3x4_cmpe( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns true if not all of the components of the left-hand-side int3x4 match the other one, otherwise returns false.
inline bool int3x4_cmpne( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise added by the given scalar value.
inline int3x4 int3x4_comp_adds( const int3x4* lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise added by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_comp_addm( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise subtracted by the given scalar value.
inline int3x4 int3x4_comp_subs( const int3x4* lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise subtracted by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_comp_subm( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise multiplied by the given scalar value.
inline int3x4 int3x4_comp_muls( const int3x4* lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise multiplied by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_comp_mulm( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise divided by the given scalar value.
inline int3x4 int3x4_comp_divs( const int3x4* lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise divided by the corresponding component of the right-hand int3x4.
inline int3x4 int3x4_comp_divm( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise AND'd against the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_comp_and( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise OR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_comp_or( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise XOR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_comp_xor( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Performs a unary bitwise operation on all components of the given int3x4.
inline int3x4 int3x4_comp_unary( const int3x4* lhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise left-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_comp_shift_left( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise right-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 int3x4_comp_shift_right( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 int3x4_cmpl( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 int3x4_cmple( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 int3x4_cmpg( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 int3x4_cmpge( const int3x4* lhs, const int3x4* rhs );

/// \relates int3x4
/// \brief Sets the matrix to an identity matrix.
inline void int3x4_identity( int3x4* mat );

/// \relates int3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x3 int3x4_transpose( const int3x4* mat );

/// \relates int3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 int3x4_mulm( const int3x4* lhs, const int4x3* rhs );

/// \relates int3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int3x4 int3x4_translate( const int3x4* mat, const int3* vec );

/// \relates int3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int3x4 int3x4_scale( const int3x4* mat, const int2* vec );


// int4x2
/// \relates int4x2
/// \brief Returns true if the all the components of the left-hand-side int4x2 match the other one, otherwise returns false.
inline bool int4x2_cmpe( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns true if not all of the components of the left-hand-side int4x2 match the other one, otherwise returns false.
inline bool int4x2_cmpne( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise added by the given scalar value.
inline int4x2 int4x2_comp_adds( const int4x2* lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise added by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_comp_addm( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise subtracted by the given scalar value.
inline int4x2 int4x2_comp_subs( const int4x2* lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise subtracted by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_comp_subm( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise multiplied by the given scalar value.
inline int4x2 int4x2_comp_muls( const int4x2* lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise multiplied by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_comp_mulm( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise divided by the given scalar value.
inline int4x2 int4x2_comp_divs( const int4x2* lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise divided by the corresponding component of the right-hand int4x2.
inline int4x2 int4x2_comp_divm( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise AND'd against the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_comp_and( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise OR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_comp_or( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise XOR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_comp_xor( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Performs a unary bitwise operation on all components of the given int4x2.
inline int4x2 int4x2_comp_unary( const int4x2* lhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise left-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_comp_shift_left( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise right-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 int4x2_comp_shift_right( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 int4x2_cmpl( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 int4x2_cmple( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 int4x2_cmpg( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 int4x2_cmpge( const int4x2* lhs, const int4x2* rhs );

/// \relates int4x2
/// \brief Sets the matrix to an identity matrix.
inline void int4x2_identity( int4x2* mat );

/// \relates int4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x4 int4x2_transpose( const int4x2* mat );

/// \relates int4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 int4x2_mulm( const int4x2* lhs, const int2x4* rhs );


// int4x3
/// \relates int4x3
/// \brief Returns true if the all the components of the left-hand-side int4x3 match the other one, otherwise returns false.
inline bool int4x3_cmpe( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns true if not all of the components of the left-hand-side int4x3 match the other one, otherwise returns false.
inline bool int4x3_cmpne( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise added by the given scalar value.
inline int4x3 int4x3_comp_adds( const int4x3* lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise added by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_comp_addm( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise subtracted by the given scalar value.
inline int4x3 int4x3_comp_subs( const int4x3* lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise subtracted by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_comp_subm( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise multiplied by the given scalar value.
inline int4x3 int4x3_comp_muls( const int4x3* lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise multiplied by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_comp_mulm( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise divided by the given scalar value.
inline int4x3 int4x3_comp_divs( const int4x3* lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise divided by the corresponding component of the right-hand int4x3.
inline int4x3 int4x3_comp_divm( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise AND'd against the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_comp_and( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise OR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_comp_or( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise XOR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_comp_xor( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Performs a unary bitwise operation on all components of the given int4x3.
inline int4x3 int4x3_comp_unary( const int4x3* lhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise left-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_comp_shift_left( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise right-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 int4x3_comp_shift_right( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 int4x3_cmpl( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 int4x3_cmple( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 int4x3_cmpg( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 int4x3_cmpge( const int4x3* lhs, const int4x3* rhs );

/// \relates int4x3
/// \brief Sets the matrix to an identity matrix.
inline void int4x3_identity( int4x3* mat );

/// \relates int4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x4 int4x3_transpose( const int4x3* mat );

/// \relates int4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 int4x3_mulm( const int4x3* lhs, const int3x4* rhs );

/// \relates int4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int4x3 int4x3_scale( const int4x3* mat, const int2* vec );


// int4x4
/// \relates int4x4
/// \brief Returns true if the all the components of the left-hand-side int4x4 match the other one, otherwise returns false.
inline bool int4x4_cmpe( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns true if not all of the components of the left-hand-side int4x4 match the other one, otherwise returns false.
inline bool int4x4_cmpne( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise added by the given scalar value.
inline int4x4 int4x4_comp_adds( const int4x4* lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise added by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_comp_addm( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise subtracted by the given scalar value.
inline int4x4 int4x4_comp_subs( const int4x4* lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise subtracted by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_comp_subm( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise multiplied by the given scalar value.
inline int4x4 int4x4_comp_muls( const int4x4* lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise multiplied by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_comp_mulm( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise divided by the given scalar value.
inline int4x4 int4x4_comp_divs( const int4x4* lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise divided by the corresponding component of the right-hand int4x4.
inline int4x4 int4x4_comp_divm( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise AND'd against the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_comp_and( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise OR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_comp_or( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise XOR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_comp_xor( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Performs a unary bitwise operation on all components of the given int4x4.
inline int4x4 int4x4_comp_unary( const int4x4* lhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise left-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_comp_shift_left( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise right-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 int4x4_comp_shift_right( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 int4x4_cmpl( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 int4x4_cmple( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 int4x4_cmpg( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 int4x4_cmpge( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Sets the matrix to an identity matrix.
inline void int4x4_identity( int4x4* mat );

/// \relates int4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x4 int4x4_transpose( const int4x4* mat );

/// \relates int4x4
/// \brief Returns the determinant of the matrix.
inline int32_t int4x4_determinant( const int4x4* mat );

/// \relates int4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 int4x4_mulm( const int4x4* lhs, const int4x4* rhs );

/// \relates int4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline int4 int4x4_mulv( const int4x4* lhs, const int4* rhs );

/// \relates int4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int4x4 int4x4_translate( const int4x4* mat, const int3* vec );

/// \relates int4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int4x4 int4x4_scale( const int4x4* mat, const int3* vec );


// uint2x2
/// \relates uint2x2
/// \brief Returns true if the all the components of the left-hand-side uint2x2 match the other one, otherwise returns false.
inline bool uint2x2_cmpe( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns true if not all of the components of the left-hand-side uint2x2 match the other one, otherwise returns false.
inline bool uint2x2_cmpne( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise added by the given scalar value.
inline uint2x2 uint2x2_comp_adds( const uint2x2* lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise added by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_comp_addm( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise subtracted by the given scalar value.
inline uint2x2 uint2x2_comp_subs( const uint2x2* lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise subtracted by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_comp_subm( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise multiplied by the given scalar value.
inline uint2x2 uint2x2_comp_muls( const uint2x2* lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise multiplied by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_comp_mulm( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise divided by the given scalar value.
inline uint2x2 uint2x2_comp_divs( const uint2x2* lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise divided by the corresponding component of the right-hand uint2x2.
inline uint2x2 uint2x2_comp_divm( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise AND'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_comp_and( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise OR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_comp_or( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_comp_xor( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Performs a unary bitwise operation on all components of the given uint2x2.
inline uint2x2 uint2x2_comp_unary( const uint2x2* lhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_comp_shift_left( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 uint2x2_comp_shift_right( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 uint2x2_cmpl( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 uint2x2_cmple( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 uint2x2_cmpg( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 uint2x2_cmpge( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Sets the matrix to an identity matrix.
inline void uint2x2_identity( uint2x2* mat );

/// \relates uint2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x2 uint2x2_transpose( const uint2x2* mat );

/// \relates uint2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 uint2x2_mulm( const uint2x2* lhs, const uint2x2* rhs );

/// \relates uint2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline uint2 uint2x2_mulv( const uint2x2* lhs, const uint2* rhs );


// uint2x3
/// \relates uint2x3
/// \brief Returns true if the all the components of the left-hand-side uint2x3 match the other one, otherwise returns false.
inline bool uint2x3_cmpe( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns true if not all of the components of the left-hand-side uint2x3 match the other one, otherwise returns false.
inline bool uint2x3_cmpne( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise added by the given scalar value.
inline uint2x3 uint2x3_comp_adds( const uint2x3* lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise added by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_comp_addm( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise subtracted by the given scalar value.
inline uint2x3 uint2x3_comp_subs( const uint2x3* lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise subtracted by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_comp_subm( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise multiplied by the given scalar value.
inline uint2x3 uint2x3_comp_muls( const uint2x3* lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise multiplied by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_comp_mulm( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise divided by the given scalar value.
inline uint2x3 uint2x3_comp_divs( const uint2x3* lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise divided by the corresponding component of the right-hand uint2x3.
inline uint2x3 uint2x3_comp_divm( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise AND'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_comp_and( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise OR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_comp_or( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_comp_xor( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Performs a unary bitwise operation on all components of the given uint2x3.
inline uint2x3 uint2x3_comp_unary( const uint2x3* lhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_comp_shift_left( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 uint2x3_comp_shift_right( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 uint2x3_cmpl( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 uint2x3_cmple( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 uint2x3_cmpg( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 uint2x3_cmpge( const uint2x3* lhs, const uint2x3* rhs );

/// \relates uint2x3
/// \brief Sets the matrix to an identity matrix.
inline void uint2x3_identity( uint2x3* mat );

/// \relates uint2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x2 uint2x3_transpose( const uint2x3* mat );

/// \relates uint2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 uint2x3_mulm( const uint2x3* lhs, const uint3x2* rhs );

/// \relates uint2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint2x3 uint2x3_scale( const uint2x3* mat, const uint2* vec );


// uint2x4
/// \relates uint2x4
/// \brief Returns true if the all the components of the left-hand-side uint2x4 match the other one, otherwise returns false.
inline bool uint2x4_cmpe( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns true if not all of the components of the left-hand-side uint2x4 match the other one, otherwise returns false.
inline bool uint2x4_cmpne( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise added by the given scalar value.
inline uint2x4 uint2x4_comp_adds( const uint2x4* lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise added by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_comp_addm( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise subtracted by the given scalar value.
inline uint2x4 uint2x4_comp_subs( const uint2x4* lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise subtracted by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_comp_subm( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise multiplied by the given scalar value.
inline uint2x4 uint2x4_comp_muls( const uint2x4* lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise multiplied by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_comp_mulm( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise divided by the given scalar value.
inline uint2x4 uint2x4_comp_divs( const uint2x4* lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise divided by the corresponding component of the right-hand uint2x4.
inline uint2x4 uint2x4_comp_divm( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise AND'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_comp_and( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise OR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_comp_or( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_comp_xor( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Performs a unary bitwise operation on all components of the given uint2x4.
inline uint2x4 uint2x4_comp_unary( const uint2x4* lhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_comp_shift_left( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 uint2x4_comp_shift_right( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 uint2x4_cmpl( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 uint2x4_cmple( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 uint2x4_cmpg( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 uint2x4_cmpge( const uint2x4* lhs, const uint2x4* rhs );

/// \relates uint2x4
/// \brief Sets the matrix to an identity matrix.
inline void uint2x4_identity( uint2x4* mat );

/// \relates uint2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x2 uint2x4_transpose( const uint2x4* mat );

/// \relates uint2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 uint2x4_mulm( const uint2x4* lhs, const uint4x2* rhs );

/// \relates uint2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint2x4 uint2x4_scale( const uint2x4* mat, const uint2* vec );


// uint3x2
/// \relates uint3x2
/// \brief Returns true if the all the components of the left-hand-side uint3x2 match the other one, otherwise returns false.
inline bool uint3x2_cmpe( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns true if not all of the components of the left-hand-side uint3x2 match the other one, otherwise returns false.
inline bool uint3x2_cmpne( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise added by the given scalar value.
inline uint3x2 uint3x2_comp_adds( const uint3x2* lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise added by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_comp_addm( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise subtracted by the given scalar value.
inline uint3x2 uint3x2_comp_subs( const uint3x2* lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise subtracted by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_comp_subm( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise multiplied by the given scalar value.
inline uint3x2 uint3x2_comp_muls( const uint3x2* lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise multiplied by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_comp_mulm( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise divided by the given scalar value.
inline uint3x2 uint3x2_comp_divs( const uint3x2* lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise divided by the corresponding component of the right-hand uint3x2.
inline uint3x2 uint3x2_comp_divm( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise AND'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_comp_and( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise OR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_comp_or( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_comp_xor( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Performs a unary bitwise operation on all components of the given uint3x2.
inline uint3x2 uint3x2_comp_unary( const uint3x2* lhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_comp_shift_left( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 uint3x2_comp_shift_right( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 uint3x2_cmpl( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 uint3x2_cmple( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 uint3x2_cmpg( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 uint3x2_cmpge( const uint3x2* lhs, const uint3x2* rhs );

/// \relates uint3x2
/// \brief Sets the matrix to an identity matrix.
inline void uint3x2_identity( uint3x2* mat );

/// \relates uint3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x3 uint3x2_transpose( const uint3x2* mat );

/// \relates uint3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 uint3x2_mulm( const uint3x2* lhs, const uint2x3* rhs );


// uint3x3
/// \relates uint3x3
/// \brief Returns true if the all the components of the left-hand-side uint3x3 match the other one, otherwise returns false.
inline bool uint3x3_cmpe( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns true if not all of the components of the left-hand-side uint3x3 match the other one, otherwise returns false.
inline bool uint3x3_cmpne( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise added by the given scalar value.
inline uint3x3 uint3x3_comp_adds( const uint3x3* lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise added by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_comp_addm( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise subtracted by the given scalar value.
inline uint3x3 uint3x3_comp_subs( const uint3x3* lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise subtracted by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_comp_subm( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise multiplied by the given scalar value.
inline uint3x3 uint3x3_comp_muls( const uint3x3* lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise multiplied by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_comp_mulm( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise divided by the given scalar value.
inline uint3x3 uint3x3_comp_divs( const uint3x3* lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise divided by the corresponding component of the right-hand uint3x3.
inline uint3x3 uint3x3_comp_divm( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise AND'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_comp_and( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise OR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_comp_or( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_comp_xor( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Performs a unary bitwise operation on all components of the given uint3x3.
inline uint3x3 uint3x3_comp_unary( const uint3x3* lhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_comp_shift_left( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 uint3x3_comp_shift_right( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 uint3x3_cmpl( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 uint3x3_cmple( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 uint3x3_cmpg( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 uint3x3_cmpge( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Sets the matrix to an identity matrix.
inline void uint3x3_identity( uint3x3* mat );

/// \relates uint3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x3 uint3x3_transpose( const uint3x3* mat );

/// \relates uint3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 uint3x3_mulm( const uint3x3* lhs, const uint3x3* rhs );

/// \relates uint3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline uint3 uint3x3_mulv( const uint3x3* lhs, const uint3* rhs );

/// \relates uint3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint3x3 uint3x3_translate( const uint3x3* mat, const uint2* vec );

/// \relates uint3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint3x3 uint3x3_scale( const uint3x3* mat, const uint2* vec );


// uint3x4
/// \relates uint3x4
/// \brief Returns true if the all the components of the left-hand-side uint3x4 match the other one, otherwise returns false.
inline bool uint3x4_cmpe( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns true if not all of the components of the left-hand-side uint3x4 match the other one, otherwise returns false.
inline bool uint3x4_cmpne( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise added by the given scalar value.
inline uint3x4 uint3x4_comp_adds( const uint3x4* lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise added by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_comp_addm( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise subtracted by the given scalar value.
inline uint3x4 uint3x4_comp_subs( const uint3x4* lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise subtracted by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_comp_subm( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise multiplied by the given scalar value.
inline uint3x4 uint3x4_comp_muls( const uint3x4* lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise multiplied by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_comp_mulm( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise divided by the given scalar value.
inline uint3x4 uint3x4_comp_divs( const uint3x4* lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise divided by the corresponding component of the right-hand uint3x4.
inline uint3x4 uint3x4_comp_divm( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise AND'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_comp_and( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise OR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_comp_or( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_comp_xor( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Performs a unary bitwise operation on all components of the given uint3x4.
inline uint3x4 uint3x4_comp_unary( const uint3x4* lhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_comp_shift_left( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 uint3x4_comp_shift_right( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 uint3x4_cmpl( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 uint3x4_cmple( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 uint3x4_cmpg( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 uint3x4_cmpge( const uint3x4* lhs, const uint3x4* rhs );

/// \relates uint3x4
/// \brief Sets the matrix to an identity matrix.
inline void uint3x4_identity( uint3x4* mat );

/// \relates uint3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x3 uint3x4_transpose( const uint3x4* mat );

/// \relates uint3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 uint3x4_mulm( const uint3x4* lhs, const uint4x3* rhs );

/// \relates uint3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint3x4 uint3x4_translate( const uint3x4* mat, const uint3* vec );

/// \relates uint3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint3x4 uint3x4_scale( const uint3x4* mat, const uint2* vec );


// uint4x2
/// \relates uint4x2
/// \brief Returns true if the all the components of the left-hand-side uint4x2 match the other one, otherwise returns false.
inline bool uint4x2_cmpe( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns true if not all of the components of the left-hand-side uint4x2 match the other one, otherwise returns false.
inline bool uint4x2_cmpne( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise added by the given scalar value.
inline uint4x2 uint4x2_comp_adds( const uint4x2* lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise added by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_comp_addm( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise subtracted by the given scalar value.
inline uint4x2 uint4x2_comp_subs( const uint4x2* lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise subtracted by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_comp_subm( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise multiplied by the given scalar value.
inline uint4x2 uint4x2_comp_muls( const uint4x2* lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise multiplied by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_comp_mulm( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise divided by the given scalar value.
inline uint4x2 uint4x2_comp_divs( const uint4x2* lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise divided by the corresponding component of the right-hand uint4x2.
inline uint4x2 uint4x2_comp_divm( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise AND'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_comp_and( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise OR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_comp_or( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_comp_xor( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Performs a unary bitwise operation on all components of the given uint4x2.
inline uint4x2 uint4x2_comp_unary( const uint4x2* lhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_comp_shift_left( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 uint4x2_comp_shift_right( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 uint4x2_cmpl( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 uint4x2_cmple( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 uint4x2_cmpg( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 uint4x2_cmpge( const uint4x2* lhs, const uint4x2* rhs );

/// \relates uint4x2
/// \brief Sets the matrix to an identity matrix.
inline void uint4x2_identity( uint4x2* mat );

/// \relates uint4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x4 uint4x2_transpose( const uint4x2* mat );

/// \relates uint4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 uint4x2_mulm( const uint4x2* lhs, const uint2x4* rhs );


// uint4x3
/// \relates uint4x3
/// \brief Returns true if the all the components of the left-hand-side uint4x3 match the other one, otherwise returns false.
inline bool uint4x3_cmpe( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns true if not all of the components of the left-hand-side uint4x3 match the other one, otherwise returns false.
inline bool uint4x3_cmpne( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise added by the given scalar value.
inline uint4x3 uint4x3_comp_adds( const uint4x3* lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise added by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_comp_addm( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise subtracted by the given scalar value.
inline uint4x3 uint4x3_comp_subs( const uint4x3* lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise subtracted by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_comp_subm( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise multiplied by the given scalar value.
inline uint4x3 uint4x3_comp_muls( const uint4x3* lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise multiplied by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_comp_mulm( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise divided by the given scalar value.
inline uint4x3 uint4x3_comp_divs( const uint4x3* lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise divided by the corresponding component of the right-hand uint4x3.
inline uint4x3 uint4x3_comp_divm( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise AND'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_comp_and( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise OR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_comp_or( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_comp_xor( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Performs a unary bitwise operation on all components of the given uint4x3.
inline uint4x3 uint4x3_comp_unary( const uint4x3* lhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_comp_shift_left( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 uint4x3_comp_shift_right( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 uint4x3_cmpl( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 uint4x3_cmple( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 uint4x3_cmpg( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 uint4x3_cmpge( const uint4x3* lhs, const uint4x3* rhs );

/// \relates uint4x3
/// \brief Sets the matrix to an identity matrix.
inline void uint4x3_identity( uint4x3* mat );

/// \relates uint4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x4 uint4x3_transpose( const uint4x3* mat );

/// \relates uint4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 uint4x3_mulm( const uint4x3* lhs, const uint3x4* rhs );

/// \relates uint4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint4x3 uint4x3_scale( const uint4x3* mat, const uint2* vec );


// uint4x4
/// \relates uint4x4
/// \brief Returns true if the all the components of the left-hand-side uint4x4 match the other one, otherwise returns false.
inline bool uint4x4_cmpe( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns true if not all of the components of the left-hand-side uint4x4 match the other one, otherwise returns false.
inline bool uint4x4_cmpne( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise added by the given scalar value.
inline uint4x4 uint4x4_comp_adds( const uint4x4* lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise added by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_comp_addm( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise subtracted by the given scalar value.
inline uint4x4 uint4x4_comp_subs( const uint4x4* lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise subtracted by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_comp_subm( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise multiplied by the given scalar value.
inline uint4x4 uint4x4_comp_muls( const uint4x4* lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise multiplied by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_comp_mulm( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise divided by the given scalar value.
inline uint4x4 uint4x4_comp_divs( const uint4x4* lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise divided by the corresponding component of the right-hand uint4x4.
inline uint4x4 uint4x4_comp_divm( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise AND'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_comp_and( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise OR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_comp_or( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_comp_xor( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Performs a unary bitwise operation on all components of the given uint4x4.
inline uint4x4 uint4x4_comp_unary( const uint4x4* lhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_comp_shift_left( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 uint4x4_comp_shift_right( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 uint4x4_cmpl( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 uint4x4_cmple( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 uint4x4_cmpg( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 uint4x4_cmpge( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Sets the matrix to an identity matrix.
inline void uint4x4_identity( uint4x4* mat );

/// \relates uint4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x4 uint4x4_transpose( const uint4x4* mat );

/// \relates uint4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 uint4x4_mulm( const uint4x4* lhs, const uint4x4* rhs );

/// \relates uint4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline uint4 uint4x4_mulv( const uint4x4* lhs, const uint4* rhs );

/// \relates uint4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint4x4 uint4x4_translate( const uint4x4* mat, const uint3* vec );

/// \relates uint4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint4x4 uint4x4_scale( const uint4x4* mat, const uint3* vec );


// float2x2
/// \relates float2x2
/// \brief Returns true if the all the components of the left-hand-side float2x2 match the other one, otherwise returns false.
inline bool float2x2_cmpe( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns true if not all of the components of the left-hand-side float2x2 match the other one, otherwise returns false.
inline bool float2x2_cmpne( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise added by the given scalar value.
inline float2x2 float2x2_comp_adds( const float2x2* lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise added by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_comp_addm( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise subtracted by the given scalar value.
inline float2x2 float2x2_comp_subs( const float2x2* lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise subtracted by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_comp_subm( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise multiplied by the given scalar value.
inline float2x2 float2x2_comp_muls( const float2x2* lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise multiplied by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_comp_mulm( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise divided by the given scalar value.
inline float2x2 float2x2_comp_divs( const float2x2* lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise divided by the corresponding component of the right-hand float2x2.
inline float2x2 float2x2_comp_divm( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 float2x2_cmpl( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 float2x2_cmple( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 float2x2_cmpg( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 float2x2_cmpge( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Sets the matrix to an identity matrix.
inline void float2x2_identity( float2x2* mat );

/// \relates float2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x2 float2x2_transpose( const float2x2* mat );

/// \relates float2x2
/// \brief Returns the determinant of the matrix.
inline float float2x2_determinant( const float2x2* mat );

/// \relates float2x2
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float2x2 float2x2_inverse( const float2x2* mat );

/// \relates float2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 float2x2_mulm( const float2x2* lhs, const float2x2* rhs );

/// \relates float2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline float2 float2x2_mulv( const float2x2* lhs, const float2* rhs );


// float2x3
/// \relates float2x3
/// \brief Returns true if the all the components of the left-hand-side float2x3 match the other one, otherwise returns false.
inline bool float2x3_cmpe( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns true if not all of the components of the left-hand-side float2x3 match the other one, otherwise returns false.
inline bool float2x3_cmpne( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise added by the given scalar value.
inline float2x3 float2x3_comp_adds( const float2x3* lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise added by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_comp_addm( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise subtracted by the given scalar value.
inline float2x3 float2x3_comp_subs( const float2x3* lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise subtracted by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_comp_subm( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise multiplied by the given scalar value.
inline float2x3 float2x3_comp_muls( const float2x3* lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise multiplied by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_comp_mulm( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise divided by the given scalar value.
inline float2x3 float2x3_comp_divs( const float2x3* lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise divided by the corresponding component of the right-hand float2x3.
inline float2x3 float2x3_comp_divm( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 float2x3_cmpl( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 float2x3_cmple( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 float2x3_cmpg( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 float2x3_cmpge( const float2x3* lhs, const float2x3* rhs );

/// \relates float2x3
/// \brief Sets the matrix to an identity matrix.
inline void float2x3_identity( float2x3* mat );

/// \relates float2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x2 float2x3_transpose( const float2x3* mat );

/// \relates float2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 float2x3_mulm( const float2x3* lhs, const float3x2* rhs );

/// \relates float2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float2x3 float2x3_scale( const float2x3* mat, const float2* vec );


// float2x4
/// \relates float2x4
/// \brief Returns true if the all the components of the left-hand-side float2x4 match the other one, otherwise returns false.
inline bool float2x4_cmpe( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns true if not all of the components of the left-hand-side float2x4 match the other one, otherwise returns false.
inline bool float2x4_cmpne( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise added by the given scalar value.
inline float2x4 float2x4_comp_adds( const float2x4* lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise added by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_comp_addm( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise subtracted by the given scalar value.
inline float2x4 float2x4_comp_subs( const float2x4* lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise subtracted by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_comp_subm( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise multiplied by the given scalar value.
inline float2x4 float2x4_comp_muls( const float2x4* lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise multiplied by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_comp_mulm( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise divided by the given scalar value.
inline float2x4 float2x4_comp_divs( const float2x4* lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise divided by the corresponding component of the right-hand float2x4.
inline float2x4 float2x4_comp_divm( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 float2x4_cmpl( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 float2x4_cmple( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 float2x4_cmpg( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 float2x4_cmpge( const float2x4* lhs, const float2x4* rhs );

/// \relates float2x4
/// \brief Sets the matrix to an identity matrix.
inline void float2x4_identity( float2x4* mat );

/// \relates float2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x2 float2x4_transpose( const float2x4* mat );

/// \relates float2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 float2x4_mulm( const float2x4* lhs, const float4x2* rhs );

/// \relates float2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float2x4 float2x4_scale( const float2x4* mat, const float2* vec );


// float3x2
/// \relates float3x2
/// \brief Returns true if the all the components of the left-hand-side float3x2 match the other one, otherwise returns false.
inline bool float3x2_cmpe( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns true if not all of the components of the left-hand-side float3x2 match the other one, otherwise returns false.
inline bool float3x2_cmpne( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise added by the given scalar value.
inline float3x2 float3x2_comp_adds( const float3x2* lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise added by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_comp_addm( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise subtracted by the given scalar value.
inline float3x2 float3x2_comp_subs( const float3x2* lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise subtracted by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_comp_subm( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise multiplied by the given scalar value.
inline float3x2 float3x2_comp_muls( const float3x2* lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise multiplied by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_comp_mulm( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise divided by the given scalar value.
inline float3x2 float3x2_comp_divs( const float3x2* lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise divided by the corresponding component of the right-hand float3x2.
inline float3x2 float3x2_comp_divm( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 float3x2_cmpl( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 float3x2_cmple( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 float3x2_cmpg( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 float3x2_cmpge( const float3x2* lhs, const float3x2* rhs );

/// \relates float3x2
/// \brief Sets the matrix to an identity matrix.
inline void float3x2_identity( float3x2* mat );

/// \relates float3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x3 float3x2_transpose( const float3x2* mat );

/// \relates float3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 float3x2_mulm( const float3x2* lhs, const float2x3* rhs );


// float3x3
/// \relates float3x3
/// \brief Returns true if the all the components of the left-hand-side float3x3 match the other one, otherwise returns false.
inline bool float3x3_cmpe( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns true if not all of the components of the left-hand-side float3x3 match the other one, otherwise returns false.
inline bool float3x3_cmpne( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise added by the given scalar value.
inline float3x3 float3x3_comp_adds( const float3x3* lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise added by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_comp_addm( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise subtracted by the given scalar value.
inline float3x3 float3x3_comp_subs( const float3x3* lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise subtracted by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_comp_subm( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise multiplied by the given scalar value.
inline float3x3 float3x3_comp_muls( const float3x3* lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise multiplied by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_comp_mulm( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise divided by the given scalar value.
inline float3x3 float3x3_comp_divs( const float3x3* lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise divided by the corresponding component of the right-hand float3x3.
inline float3x3 float3x3_comp_divm( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 float3x3_cmpl( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 float3x3_cmple( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 float3x3_cmpg( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 float3x3_cmpge( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Sets the matrix to an identity matrix.
inline void float3x3_identity( float3x3* mat );

/// \relates float3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x3 float3x3_transpose( const float3x3* mat );

/// \relates float3x3
/// \brief Returns the determinant of the matrix.
inline float float3x3_determinant( const float3x3* mat );

/// \relates float3x3
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float3x3 float3x3_inverse( const float3x3* mat );

/// \relates float3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 float3x3_mulm( const float3x3* lhs, const float3x3* rhs );

/// \relates float3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline float3 float3x3_mulv( const float3x3* lhs, const float3* rhs );

/// \relates float3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float3x3 float3x3_translate( const float3x3* mat, const float2* vec );

/// \relates float3x3
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline float3x3 float3x3_rotate( const float3x3* mat, const float rad );

/// \relates float3x3
/// \brief Returns a matrix based on the provided pitch, yaw and roll angles (in radians).
inline float3x3 float3x3_rotation_roll_pitch_yaw( const float3x3* mat, const float pitch, const float yaw, const float roll );

/// \relates float3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float3x3 float3x3_scale( const float3x3* mat, const float2* vec );


// float3x4
/// \relates float3x4
/// \brief Returns true if the all the components of the left-hand-side float3x4 match the other one, otherwise returns false.
inline bool float3x4_cmpe( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns true if not all of the components of the left-hand-side float3x4 match the other one, otherwise returns false.
inline bool float3x4_cmpne( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise added by the given scalar value.
inline float3x4 float3x4_comp_adds( const float3x4* lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise added by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_comp_addm( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise subtracted by the given scalar value.
inline float3x4 float3x4_comp_subs( const float3x4* lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise subtracted by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_comp_subm( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise multiplied by the given scalar value.
inline float3x4 float3x4_comp_muls( const float3x4* lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise multiplied by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_comp_mulm( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise divided by the given scalar value.
inline float3x4 float3x4_comp_divs( const float3x4* lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise divided by the corresponding component of the right-hand float3x4.
inline float3x4 float3x4_comp_divm( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 float3x4_cmpl( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 float3x4_cmple( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 float3x4_cmpg( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 float3x4_cmpge( const float3x4* lhs, const float3x4* rhs );

/// \relates float3x4
/// \brief Sets the matrix to an identity matrix.
inline void float3x4_identity( float3x4* mat );

/// \relates float3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x3 float3x4_transpose( const float3x4* mat );

/// \relates float3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 float3x4_mulm( const float3x4* lhs, const float4x3* rhs );

/// \relates float3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float3x4 float3x4_translate( const float3x4* mat, const float3* vec );

/// \relates float3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float3x4 float3x4_scale( const float3x4* mat, const float2* vec );


// float4x2
/// \relates float4x2
/// \brief Returns true if the all the components of the left-hand-side float4x2 match the other one, otherwise returns false.
inline bool float4x2_cmpe( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns true if not all of the components of the left-hand-side float4x2 match the other one, otherwise returns false.
inline bool float4x2_cmpne( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise added by the given scalar value.
inline float4x2 float4x2_comp_adds( const float4x2* lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise added by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_comp_addm( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise subtracted by the given scalar value.
inline float4x2 float4x2_comp_subs( const float4x2* lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise subtracted by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_comp_subm( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise multiplied by the given scalar value.
inline float4x2 float4x2_comp_muls( const float4x2* lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise multiplied by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_comp_mulm( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise divided by the given scalar value.
inline float4x2 float4x2_comp_divs( const float4x2* lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise divided by the corresponding component of the right-hand float4x2.
inline float4x2 float4x2_comp_divm( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 float4x2_cmpl( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 float4x2_cmple( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 float4x2_cmpg( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 float4x2_cmpge( const float4x2* lhs, const float4x2* rhs );

/// \relates float4x2
/// \brief Sets the matrix to an identity matrix.
inline void float4x2_identity( float4x2* mat );

/// \relates float4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x4 float4x2_transpose( const float4x2* mat );

/// \relates float4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 float4x2_mulm( const float4x2* lhs, const float2x4* rhs );


// float4x3
/// \relates float4x3
/// \brief Returns true if the all the components of the left-hand-side float4x3 match the other one, otherwise returns false.
inline bool float4x3_cmpe( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns true if not all of the components of the left-hand-side float4x3 match the other one, otherwise returns false.
inline bool float4x3_cmpne( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise added by the given scalar value.
inline float4x3 float4x3_comp_adds( const float4x3* lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise added by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_comp_addm( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise subtracted by the given scalar value.
inline float4x3 float4x3_comp_subs( const float4x3* lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise subtracted by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_comp_subm( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise multiplied by the given scalar value.
inline float4x3 float4x3_comp_muls( const float4x3* lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise multiplied by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_comp_mulm( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise divided by the given scalar value.
inline float4x3 float4x3_comp_divs( const float4x3* lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise divided by the corresponding component of the right-hand float4x3.
inline float4x3 float4x3_comp_divm( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 float4x3_cmpl( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 float4x3_cmple( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 float4x3_cmpg( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 float4x3_cmpge( const float4x3* lhs, const float4x3* rhs );

/// \relates float4x3
/// \brief Sets the matrix to an identity matrix.
inline void float4x3_identity( float4x3* mat );

/// \relates float4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x4 float4x3_transpose( const float4x3* mat );

/// \relates float4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 float4x3_mulm( const float4x3* lhs, const float3x4* rhs );

/// \relates float4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float4x3 float4x3_scale( const float4x3* mat, const float2* vec );


// float4x4
/// \relates float4x4
/// \brief Returns true if the all the components of the left-hand-side float4x4 match the other one, otherwise returns false.
inline bool float4x4_cmpe( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns true if not all of the components of the left-hand-side float4x4 match the other one, otherwise returns false.
inline bool float4x4_cmpne( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise added by the given scalar value.
inline float4x4 float4x4_comp_adds( const float4x4* lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise added by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_comp_addm( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise subtracted by the given scalar value.
inline float4x4 float4x4_comp_subs( const float4x4* lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise subtracted by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_comp_subm( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise multiplied by the given scalar value.
inline float4x4 float4x4_comp_muls( const float4x4* lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise multiplied by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_comp_mulm( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise divided by the given scalar value.
inline float4x4 float4x4_comp_divs( const float4x4* lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise divided by the corresponding component of the right-hand float4x4.
inline float4x4 float4x4_comp_divm( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 float4x4_cmpl( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 float4x4_cmple( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 float4x4_cmpg( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 float4x4_cmpge( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Sets the matrix to an identity matrix.
inline void float4x4_identity( float4x4* mat );

/// \relates float4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x4 float4x4_transpose( const float4x4* mat );

/// \relates float4x4
/// \brief Returns the determinant of the matrix.
inline float float4x4_determinant( const float4x4* mat );

/// \relates float4x4
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float4x4 float4x4_inverse( const float4x4* mat );

/// \relates float4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 float4x4_mulm( const float4x4* lhs, const float4x4* rhs );

/// \relates float4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline float4 float4x4_mulv( const float4x4* lhs, const float4* rhs );

/// \relates float4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float4x4 float4x4_translate( const float4x4* mat, const float3* vec );

/// \relates float4x4
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline float4x4 float4x4_rotate( const float4x4* mat, const float rad, const float3* axis );

/// \relates float4x4
/// \brief Returns a matrix based on the provided pitch, yaw and roll angles (in radians).
inline float4x4 float4x4_rotation_roll_pitch_yaw( const float4x4* mat, const float pitch, const float yaw, const float roll );

/// \relates float4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float4x4 float4x4_scale( const float4x4* mat, const float3* vec );

/// \relates float4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range zero to one.
inline float4x4 float4x4_ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range minus-one to one.
inline float4x4 float4x4_ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range zero to one.
inline float4x4 float4x4_ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range minus-one to one.
inline float4x4 float4x4_ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline float4x4 float4x4_perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline float4x4 float4x4_perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline float4x4 float4x4_perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline float4x4 float4x4_perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a left-handed orthonormal matrix that is oriented at position eye to look at position target.
inline float4x4 float4x4_lookat_lh( const float3* eye, const float3* target, const float3* up );

/// \relates float4x4
/// \brief Returns a right-handed orthonormal matrix that is oriented at position eye to look at position target.
inline float4x4 float4x4_lookat_rh( const float3* eye, const float3* target, const float3* up );


// double2x2
/// \relates double2x2
/// \brief Returns true if the all the components of the left-hand-side double2x2 match the other one, otherwise returns false.
inline bool double2x2_cmpe( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns true if not all of the components of the left-hand-side double2x2 match the other one, otherwise returns false.
inline bool double2x2_cmpne( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise added by the given scalar value.
inline double2x2 double2x2_comp_adds( const double2x2* lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise added by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_comp_addm( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise subtracted by the given scalar value.
inline double2x2 double2x2_comp_subs( const double2x2* lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise subtracted by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_comp_subm( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise multiplied by the given scalar value.
inline double2x2 double2x2_comp_muls( const double2x2* lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise multiplied by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_comp_mulm( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise divided by the given scalar value.
inline double2x2 double2x2_comp_divs( const double2x2* lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise divided by the corresponding component of the right-hand double2x2.
inline double2x2 double2x2_comp_divm( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 double2x2_cmpl( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 double2x2_cmple( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 double2x2_cmpg( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 double2x2_cmpge( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Sets the matrix to an identity matrix.
inline void double2x2_identity( double2x2* mat );

/// \relates double2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x2 double2x2_transpose( const double2x2* mat );

/// \relates double2x2
/// \brief Returns the determinant of the matrix.
inline double double2x2_determinant( const double2x2* mat );

/// \relates double2x2
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double2x2 double2x2_inverse( const double2x2* mat );

/// \relates double2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 double2x2_mulm( const double2x2* lhs, const double2x2* rhs );

/// \relates double2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline double2 double2x2_mulv( const double2x2* lhs, const double2* rhs );


// double2x3
/// \relates double2x3
/// \brief Returns true if the all the components of the left-hand-side double2x3 match the other one, otherwise returns false.
inline bool double2x3_cmpe( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns true if not all of the components of the left-hand-side double2x3 match the other one, otherwise returns false.
inline bool double2x3_cmpne( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise added by the given scalar value.
inline double2x3 double2x3_comp_adds( const double2x3* lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise added by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_comp_addm( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise subtracted by the given scalar value.
inline double2x3 double2x3_comp_subs( const double2x3* lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise subtracted by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_comp_subm( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise multiplied by the given scalar value.
inline double2x3 double2x3_comp_muls( const double2x3* lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise multiplied by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_comp_mulm( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise divided by the given scalar value.
inline double2x3 double2x3_comp_divs( const double2x3* lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise divided by the corresponding component of the right-hand double2x3.
inline double2x3 double2x3_comp_divm( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 double2x3_cmpl( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 double2x3_cmple( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 double2x3_cmpg( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 double2x3_cmpge( const double2x3* lhs, const double2x3* rhs );

/// \relates double2x3
/// \brief Sets the matrix to an identity matrix.
inline void double2x3_identity( double2x3* mat );

/// \relates double2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x2 double2x3_transpose( const double2x3* mat );

/// \relates double2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 double2x3_mulm( const double2x3* lhs, const double3x2* rhs );

/// \relates double2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double2x3 double2x3_scale( const double2x3* mat, const double2* vec );


// double2x4
/// \relates double2x4
/// \brief Returns true if the all the components of the left-hand-side double2x4 match the other one, otherwise returns false.
inline bool double2x4_cmpe( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns true if not all of the components of the left-hand-side double2x4 match the other one, otherwise returns false.
inline bool double2x4_cmpne( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise added by the given scalar value.
inline double2x4 double2x4_comp_adds( const double2x4* lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise added by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_comp_addm( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise subtracted by the given scalar value.
inline double2x4 double2x4_comp_subs( const double2x4* lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise subtracted by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_comp_subm( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise multiplied by the given scalar value.
inline double2x4 double2x4_comp_muls( const double2x4* lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise multiplied by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_comp_mulm( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise divided by the given scalar value.
inline double2x4 double2x4_comp_divs( const double2x4* lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise divided by the corresponding component of the right-hand double2x4.
inline double2x4 double2x4_comp_divm( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 double2x4_cmpl( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 double2x4_cmple( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 double2x4_cmpg( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 double2x4_cmpge( const double2x4* lhs, const double2x4* rhs );

/// \relates double2x4
/// \brief Sets the matrix to an identity matrix.
inline void double2x4_identity( double2x4* mat );

/// \relates double2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x2 double2x4_transpose( const double2x4* mat );

/// \relates double2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 double2x4_mulm( const double2x4* lhs, const double4x2* rhs );

/// \relates double2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double2x4 double2x4_scale( const double2x4* mat, const double2* vec );


// double3x2
/// \relates double3x2
/// \brief Returns true if the all the components of the left-hand-side double3x2 match the other one, otherwise returns false.
inline bool double3x2_cmpe( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns true if not all of the components of the left-hand-side double3x2 match the other one, otherwise returns false.
inline bool double3x2_cmpne( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise added by the given scalar value.
inline double3x2 double3x2_comp_adds( const double3x2* lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise added by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_comp_addm( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise subtracted by the given scalar value.
inline double3x2 double3x2_comp_subs( const double3x2* lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise subtracted by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_comp_subm( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise multiplied by the given scalar value.
inline double3x2 double3x2_comp_muls( const double3x2* lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise multiplied by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_comp_mulm( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise divided by the given scalar value.
inline double3x2 double3x2_comp_divs( const double3x2* lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise divided by the corresponding component of the right-hand double3x2.
inline double3x2 double3x2_comp_divm( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 double3x2_cmpl( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 double3x2_cmple( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 double3x2_cmpg( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 double3x2_cmpge( const double3x2* lhs, const double3x2* rhs );

/// \relates double3x2
/// \brief Sets the matrix to an identity matrix.
inline void double3x2_identity( double3x2* mat );

/// \relates double3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x3 double3x2_transpose( const double3x2* mat );

/// \relates double3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 double3x2_mulm( const double3x2* lhs, const double2x3* rhs );


// double3x3
/// \relates double3x3
/// \brief Returns true if the all the components of the left-hand-side double3x3 match the other one, otherwise returns false.
inline bool double3x3_cmpe( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns true if not all of the components of the left-hand-side double3x3 match the other one, otherwise returns false.
inline bool double3x3_cmpne( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise added by the given scalar value.
inline double3x3 double3x3_comp_adds( const double3x3* lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise added by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_comp_addm( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise subtracted by the given scalar value.
inline double3x3 double3x3_comp_subs( const double3x3* lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise subtracted by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_comp_subm( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise multiplied by the given scalar value.
inline double3x3 double3x3_comp_muls( const double3x3* lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise multiplied by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_comp_mulm( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise divided by the given scalar value.
inline double3x3 double3x3_comp_divs( const double3x3* lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise divided by the corresponding component of the right-hand double3x3.
inline double3x3 double3x3_comp_divm( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 double3x3_cmpl( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 double3x3_cmple( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 double3x3_cmpg( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 double3x3_cmpge( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Sets the matrix to an identity matrix.
inline void double3x3_identity( double3x3* mat );

/// \relates double3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x3 double3x3_transpose( const double3x3* mat );

/// \relates double3x3
/// \brief Returns the determinant of the matrix.
inline double double3x3_determinant( const double3x3* mat );

/// \relates double3x3
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double3x3 double3x3_inverse( const double3x3* mat );

/// \relates double3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 double3x3_mulm( const double3x3* lhs, const double3x3* rhs );

/// \relates double3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline double3 double3x3_mulv( const double3x3* lhs, const double3* rhs );

/// \relates double3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double3x3 double3x3_translate( const double3x3* mat, const double2* vec );

/// \relates double3x3
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline double3x3 double3x3_rotate( const double3x3* mat, const double rad );

/// \relates double3x3
/// \brief Returns a matrix based on the provided pitch, yaw and roll angles (in radians).
inline double3x3 double3x3_rotation_roll_pitch_yaw( const double3x3* mat, const double pitch, const double yaw, const double roll );

/// \relates double3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double3x3 double3x3_scale( const double3x3* mat, const double2* vec );


// double3x4
/// \relates double3x4
/// \brief Returns true if the all the components of the left-hand-side double3x4 match the other one, otherwise returns false.
inline bool double3x4_cmpe( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns true if not all of the components of the left-hand-side double3x4 match the other one, otherwise returns false.
inline bool double3x4_cmpne( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise added by the given scalar value.
inline double3x4 double3x4_comp_adds( const double3x4* lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise added by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_comp_addm( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise subtracted by the given scalar value.
inline double3x4 double3x4_comp_subs( const double3x4* lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise subtracted by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_comp_subm( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise multiplied by the given scalar value.
inline double3x4 double3x4_comp_muls( const double3x4* lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise multiplied by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_comp_mulm( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise divided by the given scalar value.
inline double3x4 double3x4_comp_divs( const double3x4* lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise divided by the corresponding component of the right-hand double3x4.
inline double3x4 double3x4_comp_divm( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 double3x4_cmpl( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 double3x4_cmple( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 double3x4_cmpg( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 double3x4_cmpge( const double3x4* lhs, const double3x4* rhs );

/// \relates double3x4
/// \brief Sets the matrix to an identity matrix.
inline void double3x4_identity( double3x4* mat );

/// \relates double3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x3 double3x4_transpose( const double3x4* mat );

/// \relates double3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 double3x4_mulm( const double3x4* lhs, const double4x3* rhs );

/// \relates double3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double3x4 double3x4_translate( const double3x4* mat, const double3* vec );

/// \relates double3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double3x4 double3x4_scale( const double3x4* mat, const double2* vec );


// double4x2
/// \relates double4x2
/// \brief Returns true if the all the components of the left-hand-side double4x2 match the other one, otherwise returns false.
inline bool double4x2_cmpe( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns true if not all of the components of the left-hand-side double4x2 match the other one, otherwise returns false.
inline bool double4x2_cmpne( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise added by the given scalar value.
inline double4x2 double4x2_comp_adds( const double4x2* lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise added by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_comp_addm( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise subtracted by the given scalar value.
inline double4x2 double4x2_comp_subs( const double4x2* lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise subtracted by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_comp_subm( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise multiplied by the given scalar value.
inline double4x2 double4x2_comp_muls( const double4x2* lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise multiplied by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_comp_mulm( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise divided by the given scalar value.
inline double4x2 double4x2_comp_divs( const double4x2* lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise divided by the corresponding component of the right-hand double4x2.
inline double4x2 double4x2_comp_divm( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 double4x2_cmpl( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 double4x2_cmple( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 double4x2_cmpg( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 double4x2_cmpge( const double4x2* lhs, const double4x2* rhs );

/// \relates double4x2
/// \brief Sets the matrix to an identity matrix.
inline void double4x2_identity( double4x2* mat );

/// \relates double4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x4 double4x2_transpose( const double4x2* mat );

/// \relates double4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 double4x2_mulm( const double4x2* lhs, const double2x4* rhs );


// double4x3
/// \relates double4x3
/// \brief Returns true if the all the components of the left-hand-side double4x3 match the other one, otherwise returns false.
inline bool double4x3_cmpe( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns true if not all of the components of the left-hand-side double4x3 match the other one, otherwise returns false.
inline bool double4x3_cmpne( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise added by the given scalar value.
inline double4x3 double4x3_comp_adds( const double4x3* lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise added by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_comp_addm( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise subtracted by the given scalar value.
inline double4x3 double4x3_comp_subs( const double4x3* lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise subtracted by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_comp_subm( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise multiplied by the given scalar value.
inline double4x3 double4x3_comp_muls( const double4x3* lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise multiplied by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_comp_mulm( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise divided by the given scalar value.
inline double4x3 double4x3_comp_divs( const double4x3* lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise divided by the corresponding component of the right-hand double4x3.
inline double4x3 double4x3_comp_divm( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 double4x3_cmpl( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 double4x3_cmple( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 double4x3_cmpg( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 double4x3_cmpge( const double4x3* lhs, const double4x3* rhs );

/// \relates double4x3
/// \brief Sets the matrix to an identity matrix.
inline void double4x3_identity( double4x3* mat );

/// \relates double4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x4 double4x3_transpose( const double4x3* mat );

/// \relates double4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 double4x3_mulm( const double4x3* lhs, const double3x4* rhs );

/// \relates double4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double4x3 double4x3_scale( const double4x3* mat, const double2* vec );


// double4x4
/// \relates double4x4
/// \brief Returns true if the all the components of the left-hand-side double4x4 match the other one, otherwise returns false.
inline bool double4x4_cmpe( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns true if not all of the components of the left-hand-side double4x4 match the other one, otherwise returns false.
inline bool double4x4_cmpne( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise added by the given scalar value.
inline double4x4 double4x4_comp_adds( const double4x4* lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise added by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_comp_addm( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise subtracted by the given scalar value.
inline double4x4 double4x4_comp_subs( const double4x4* lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise subtracted by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_comp_subm( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise multiplied by the given scalar value.
inline double4x4 double4x4_comp_muls( const double4x4* lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise multiplied by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_comp_mulm( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise divided by the given scalar value.
inline double4x4 double4x4_comp_divs( const double4x4* lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise divided by the corresponding component of the right-hand double4x4.
inline double4x4 double4x4_comp_divm( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 double4x4_cmpl( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 double4x4_cmple( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 double4x4_cmpg( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 double4x4_cmpge( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Sets the matrix to an identity matrix.
inline void double4x4_identity( double4x4* mat );

/// \relates double4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x4 double4x4_transpose( const double4x4* mat );

/// \relates double4x4
/// \brief Returns the determinant of the matrix.
inline double double4x4_determinant( const double4x4* mat );

/// \relates double4x4
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double4x4 double4x4_inverse( const double4x4* mat );

/// \relates double4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 double4x4_mulm( const double4x4* lhs, const double4x4* rhs );

/// \relates double4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline double4 double4x4_mulv( const double4x4* lhs, const double4* rhs );

/// \relates double4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double4x4 double4x4_translate( const double4x4* mat, const double3* vec );

/// \relates double4x4
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline double4x4 double4x4_rotate( const double4x4* mat, const double rad, const double3* axis );

/// \relates double4x4
/// \brief Returns a matrix based on the provided pitch, yaw and roll angles (in radians).
inline double4x4 double4x4_rotation_roll_pitch_yaw( const double4x4* mat, const double pitch, const double yaw, const double roll );

/// \relates double4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double4x4 double4x4_scale( const double4x4* mat, const double3* vec );

/// \relates double4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range zero to one.
inline double4x4 double4x4_ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range minus-one to one.
inline double4x4 double4x4_ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range zero to one.
inline double4x4 double4x4_ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range minus-one to one.
inline double4x4 double4x4_ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline double4x4 double4x4_perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline double4x4 double4x4_perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline double4x4 double4x4_perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline double4x4 double4x4_perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a left-handed orthonormal matrix that is oriented at position eye to look at position target.
inline double4x4 double4x4_lookat_lh( const double3* eye, const double3* target, const double3* up );

/// \relates double4x4
/// \brief Returns a right-handed orthonormal matrix that is oriented at position eye to look at position target.
inline double4x4 double4x4_lookat_rh( const double3* eye, const double3* target, const double3* up );


#ifdef HLML_IMPLEMENTATION

#pragma once

// ignore missing brace initializers
#if defined( __GNUC__ ) || defined( __clang__ )
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-braces"
#endif

bool bool2x2_cmpe( const bool2x2* lhs, const bool2x2* rhs )
{
	return bool2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool bool2x2_cmpne( const bool2x2* lhs, const bool2x2* rhs )
{
	return !( bool2x2_cmpe( lhs, rhs ) );
}

void bool2x2_identity( bool2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
}

bool2x2 bool2x2_transpose( const bool2x2* mat )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

bool bool2x3_cmpe( const bool2x3* lhs, const bool2x3* rhs )
{
	return bool3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool bool2x3_cmpne( const bool2x3* lhs, const bool2x3* rhs )
{
	return !( bool2x3_cmpe( lhs, rhs ) );
}

void bool2x3_identity( bool2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
}

bool3x2 bool2x3_transpose( const bool2x3* mat )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

bool bool2x4_cmpe( const bool2x4* lhs, const bool2x4* rhs )
{
	return bool4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool bool2x4_cmpne( const bool2x4* lhs, const bool2x4* rhs )
{
	return !( bool2x4_cmpe( lhs, rhs ) );
}

void bool2x4_identity( bool2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
}

bool4x2 bool2x4_transpose( const bool2x4* mat )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

bool bool3x2_cmpe( const bool3x2* lhs, const bool3x2* rhs )
{
	return bool2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool bool3x2_cmpne( const bool3x2* lhs, const bool3x2* rhs )
{
	return !( bool3x2_cmpe( lhs, rhs ) );
}

void bool3x2_identity( bool3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat->rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
}

bool2x3 bool3x2_transpose( const bool3x2* mat )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

bool bool3x3_cmpe( const bool3x3* lhs, const bool3x3* rhs )
{
	return bool3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool bool3x3_cmpne( const bool3x3* lhs, const bool3x3* rhs )
{
	return !( bool3x3_cmpe( lhs, rhs ) );
}

void bool3x3_identity( bool3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat->rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
}

bool3x3 bool3x3_transpose( const bool3x3* mat )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

bool bool3x4_cmpe( const bool3x4* lhs, const bool3x4* rhs )
{
	return bool4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool bool3x4_cmpne( const bool3x4* lhs, const bool3x4* rhs )
{
	return !( bool3x4_cmpe( lhs, rhs ) );
}

void bool3x4_identity( bool3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat->rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
}

bool4x3 bool3x4_transpose( const bool3x4* mat )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

bool bool4x2_cmpe( const bool4x2* lhs, const bool4x2* rhs )
{
	return bool2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& bool2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool bool4x2_cmpne( const bool4x2* lhs, const bool4x2* rhs )
{
	return !( bool4x2_cmpe( lhs, rhs ) );
}

void bool4x2_identity( bool4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat->rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat->rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
	mat->rows[3] = HLML_CONSTRUCT( bool2 ) { false, false };
}

bool2x4 bool4x2_transpose( const bool4x2* mat )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

bool bool4x3_cmpe( const bool4x3* lhs, const bool4x3* rhs )
{
	return bool3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& bool3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool bool4x3_cmpne( const bool4x3* lhs, const bool4x3* rhs )
{
	return !( bool4x3_cmpe( lhs, rhs ) );
}

void bool4x3_identity( bool4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat->rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
	mat->rows[3] = HLML_CONSTRUCT( bool3 ) { false, false, false };
}

bool3x4 bool4x3_transpose( const bool4x3* mat )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

bool bool4x4_cmpe( const bool4x4* lhs, const bool4x4* rhs )
{
	return bool4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& bool4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& bool4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& bool4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool bool4x4_cmpne( const bool4x4* lhs, const bool4x4* rhs )
{
	return !( bool4x4_cmpe( lhs, rhs ) );
}

void bool4x4_identity( bool4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat->rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat->rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
	mat->rows[3] = HLML_CONSTRUCT( bool4 ) { false, false, false, true };
}

bool4x4 bool4x4_transpose( const bool4x4* mat )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

bool int2x2_cmpe( const int2x2* lhs, const int2x2* rhs )
{
	return int2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool int2x2_cmpne( const int2x2* lhs, const int2x2* rhs )
{
	return !( int2x2_cmpe( lhs, rhs ) );
}

int2x2 int2x2_comp_adds( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

int2x2 int2x2_comp_addm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_subs( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

int2x2 int2x2_comp_subm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_muls( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

int2x2 int2x2_comp_mulm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_divs( const int2x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

int2x2 int2x2_comp_divm( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_and( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_and( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_or( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_or( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_xor( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_xor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_unary( const int2x2* lhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y

	};
}

int2x2 int2x2_comp_shift_left( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_shift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x2 int2x2_comp_shift_right( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		int2_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_shift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmpl( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmple( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmpg( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 int2x2_cmpge( const int2x2* lhs, const int2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		int2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void int2x2_identity( int2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
}

int2x2 int2x2_transpose( const int2x2* mat )
{
	return HLML_CONSTRUCT( int2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

int32_t int2x2_determinant( const int2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

int2x2 int2x2_mulm( const int2x2* lhs, const int2x2* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

int2 int2x2_mulv( const int2x2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool int2x3_cmpe( const int2x3* lhs, const int2x3* rhs )
{
	return int3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool int2x3_cmpne( const int2x3* lhs, const int2x3* rhs )
{
	return !( int2x3_cmpe( lhs, rhs ) );
}

int2x3 int2x3_comp_adds( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

int2x3 int2x3_comp_addm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_subs( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

int2x3 int2x3_comp_subm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_muls( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

int2x3 int2x3_comp_mulm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_divs( const int2x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

int2x3 int2x3_comp_divm( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_and( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_and( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_or( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_or( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_xor( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_xor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_unary( const int2x3* lhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z

	};
}

int2x3 int2x3_comp_shift_left( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_shift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x3 int2x3_comp_shift_right( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		int3_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_shift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmpl( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmple( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmpg( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 int2x3_cmpge( const int2x3* lhs, const int2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		int3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void int2x3_identity( int2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
}

int3x2 int2x3_transpose( const int2x3* mat )
{
	return HLML_CONSTRUCT( int3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

int2x2 int2x3_mulm( const int2x3* lhs, const int3x2* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

int2x3 int2x3_scale( const int2x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool int2x4_cmpe( const int2x4* lhs, const int2x4* rhs )
{
	return int4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool int2x4_cmpne( const int2x4* lhs, const int2x4* rhs )
{
	return !( int2x4_cmpe( lhs, rhs ) );
}

int2x4 int2x4_comp_adds( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

int2x4 int2x4_comp_addm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_subs( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

int2x4 int2x4_comp_subm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_muls( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

int2x4 int2x4_comp_mulm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_divs( const int2x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

int2x4 int2x4_comp_divm( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_and( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_and( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_or( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_or( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_xor( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_xor( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_unary( const int2x4* lhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w

	};
}

int2x4 int2x4_comp_shift_left( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_shift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

int2x4 int2x4_comp_shift_right( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		int4_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_shift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmpl( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmple( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmpg( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 int2x4_cmpge( const int2x4* lhs, const int2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		int4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void int2x4_identity( int2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
}

int4x2 int2x4_transpose( const int2x4* mat )
{
	return HLML_CONSTRUCT( int4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

int2x2 int2x4_mulm( const int2x4* lhs, const int4x2* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

int2x4 int2x4_scale( const int2x4* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool int3x2_cmpe( const int3x2* lhs, const int3x2* rhs )
{
	return int2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool int3x2_cmpne( const int3x2* lhs, const int3x2* rhs )
{
	return !( int3x2_cmpe( lhs, rhs ) );
}

int3x2 int3x2_comp_adds( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

int3x2 int3x2_comp_addm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_subs( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

int3x2 int3x2_comp_subm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_muls( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

int3x2 int3x2_comp_mulm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_divs( const int3x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

int3x2 int3x2_comp_divm( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_and( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_and( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_or( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_or( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_xor( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_xor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_unary( const int3x2* lhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y

	};
}

int3x2 int3x2_comp_shift_left( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_shift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x2 int3x2_comp_shift_right( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		int2_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_shift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmpl( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmple( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmpg( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 int3x2_cmpge( const int3x2* lhs, const int3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		int2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void int3x2_identity( int3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat->rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

int2x3 int3x2_transpose( const int3x2* mat )
{
	return HLML_CONSTRUCT( int2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

int3x3 int3x2_mulm( const int3x2* lhs, const int2x3* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];
	int2 row2 = lhs->rows[2];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	int2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool int3x3_cmpe( const int3x3* lhs, const int3x3* rhs )
{
	return int3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool int3x3_cmpne( const int3x3* lhs, const int3x3* rhs )
{
	return !( int3x3_cmpe( lhs, rhs ) );
}

int3x3 int3x3_comp_adds( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

int3x3 int3x3_comp_addm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_subs( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

int3x3 int3x3_comp_subm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_muls( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

int3x3 int3x3_comp_mulm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_divs( const int3x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

int3x3 int3x3_comp_divm( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_and( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_and( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_or( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_or( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_xor( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_xor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_unary( const int3x3* lhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z

	};
}

int3x3 int3x3_comp_shift_left( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_shift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x3 int3x3_comp_shift_right( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		int3_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_shift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmpl( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmple( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmpg( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 int3x3_cmpge( const int3x3* lhs, const int3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		int3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void int3x3_identity( int3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
}

int3x3 int3x3_transpose( const int3x3* mat )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

int32_t int3x3_determinant( const int3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

int3x3 int3x3_mulm( const int3x3* lhs, const int3x3* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];
	int3 row2 = lhs->rows[2];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	int3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

int3 int3x3_mulv( const int3x3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

int3x3 int3x3_translate( const int3x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

int3x3 int3x3_scale( const int3x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool int3x4_cmpe( const int3x4* lhs, const int3x4* rhs )
{
	return int4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool int3x4_cmpne( const int3x4* lhs, const int3x4* rhs )
{
	return !( int3x4_cmpe( lhs, rhs ) );
}

int3x4 int3x4_comp_adds( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

int3x4 int3x4_comp_addm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_subs( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

int3x4 int3x4_comp_subm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_muls( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

int3x4 int3x4_comp_mulm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_divs( const int3x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

int3x4 int3x4_comp_divm( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_and( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_and( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_or( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_or( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_xor( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_xor( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_unary( const int3x4* lhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w

	};
}

int3x4 int3x4_comp_shift_left( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_shift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

int3x4 int3x4_comp_shift_right( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		int4_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_shift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmpl( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmple( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmpg( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 int3x4_cmpge( const int3x4* lhs, const int3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		int4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void int3x4_identity( int3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
}

int4x3 int3x4_transpose( const int3x4* mat )
{
	return HLML_CONSTRUCT( int4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

int3x3 int3x4_mulm( const int3x4* lhs, const int4x3* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];
	int4 row2 = lhs->rows[2];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	int4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

int3x4 int3x4_translate( const int3x4* mat, const int3* vec )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

int3x4 int3x4_scale( const int3x4* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool int4x2_cmpe( const int4x2* lhs, const int4x2* rhs )
{
	return int2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& int2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool int4x2_cmpne( const int4x2* lhs, const int4x2* rhs )
{
	return !( int4x2_cmpe( lhs, rhs ) );
}

int4x2 int4x2_comp_adds( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

int4x2 int4x2_comp_addm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_subs( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

int4x2 int4x2_comp_subm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_muls( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

int4x2 int4x2_comp_mulm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_divs( const int4x2* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

int4x2 int4x2_comp_divm( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_and( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_and( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_and( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_or( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_or( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_or( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_xor( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_xor( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_xor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_unary( const int4x2* lhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y,

		~lhs->rows[3].x,
		~lhs->rows[3].y

	};
}

int4x2 int4x2_comp_shift_left( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_shift_left( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_shift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x2 int4x2_comp_shift_right( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		int2_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int2_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		int2_comp_shift_right( &lhs->rows[2], &rhs->rows[2] ),
		int2_comp_shift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmpl( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmple( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmpg( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 int4x2_cmpge( const int4x2* lhs, const int4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		int2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		int2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void int4x2_identity( int4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat->rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
	mat->rows[3] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

int2x4 int4x2_transpose( const int4x2* mat )
{
	return HLML_CONSTRUCT( int2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

int4x4 int4x2_mulm( const int4x2* lhs, const int2x4* rhs )
{
	int2 row0 = lhs->rows[0];
	int2 row1 = lhs->rows[1];
	int2 row2 = lhs->rows[2];
	int2 row3 = lhs->rows[3];

	int2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	int2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	int2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	int2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool int4x3_cmpe( const int4x3* lhs, const int4x3* rhs )
{
	return int3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& int3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool int4x3_cmpne( const int4x3* lhs, const int4x3* rhs )
{
	return !( int4x3_cmpe( lhs, rhs ) );
}

int4x3 int4x3_comp_adds( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

int4x3 int4x3_comp_addm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_subs( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

int4x3 int4x3_comp_subm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_muls( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

int4x3 int4x3_comp_mulm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_divs( const int4x3* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

int4x3 int4x3_comp_divm( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_and( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_and( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_and( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_or( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_or( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_or( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_xor( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_xor( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_xor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_unary( const int4x3* lhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z

	};
}

int4x3 int4x3_comp_shift_left( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_shift_left( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_shift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x3 int4x3_comp_shift_right( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		int3_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int3_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		int3_comp_shift_right( &lhs->rows[2], &rhs->rows[2] ),
		int3_comp_shift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmpl( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmple( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmpg( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 int4x3_cmpge( const int4x3* lhs, const int4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		int3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		int3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void int4x3_identity( int4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
	mat->rows[3] = HLML_CONSTRUCT( int3 ) { 0, 0, 0 };
}

int3x4 int4x3_transpose( const int4x3* mat )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

int4x4 int4x3_mulm( const int4x3* lhs, const int3x4* rhs )
{
	int3 row0 = lhs->rows[0];
	int3 row1 = lhs->rows[1];
	int3 row2 = lhs->rows[2];
	int3 row3 = lhs->rows[3];

	int3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	int3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	int3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	int3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

int4x3 int4x3_scale( const int4x3* mat, const int2* vec )
{
	return HLML_CONSTRUCT( int4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool int4x4_cmpe( const int4x4* lhs, const int4x4* rhs )
{
	return int4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& int4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& int4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& int4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool int4x4_cmpne( const int4x4* lhs, const int4x4* rhs )
{
	return !( int4x4_cmpe( lhs, rhs ) );
}

int4x4 int4x4_comp_adds( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

int4x4 int4x4_comp_addm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_subs( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

int4x4 int4x4_comp_subm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_muls( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

int4x4 int4x4_comp_mulm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_divs( const int4x4* lhs, const int32_t scalar )
{
	return HLML_CONSTRUCT( int4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

int4x4 int4x4_comp_divm( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_and( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_and( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_and( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_or( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_or( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_or( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_xor( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_xor( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_xor( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_unary( const int4x4* lhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z,
		~lhs->rows[3].w

	};
}

int4x4 int4x4_comp_shift_left( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_shift_left( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_shift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

int4x4 int4x4_comp_shift_right( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		int4_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		int4_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		int4_comp_shift_right( &lhs->rows[2], &rhs->rows[2] ),
		int4_comp_shift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmpl( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmple( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmpg( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 int4x4_cmpge( const int4x4* lhs, const int4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		int4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		int4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		int4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		int4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void int4x4_identity( int4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat->rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat->rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
	mat->rows[3] = HLML_CONSTRUCT( int4 ) { 0, 0, 0, 1 };
}

int4x4 int4x4_transpose( const int4x4* mat )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

int32_t int4x4_determinant( const int4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	int32_t sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	int32_t sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	int32_t sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	int32_t sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	int32_t sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	int32_t sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	int4 cofactor = HLML_CONSTRUCT( int4 ) {
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

int4x4 int4x4_mulm( const int4x4* lhs, const int4x4* rhs )
{
	int4 row0 = lhs->rows[0];
	int4 row1 = lhs->rows[1];
	int4 row2 = lhs->rows[2];
	int4 row3 = lhs->rows[3];

	int4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	int4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	int4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	int4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

int4 int4x4_mulv( const int4x4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

int4x4 int4x4_translate( const int4x4* mat, const int3* vec )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

int4x4 int4x4_scale( const int4x4* mat, const int3* vec )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

bool uint2x2_cmpe( const uint2x2* lhs, const uint2x2* rhs )
{
	return uint2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool uint2x2_cmpne( const uint2x2* lhs, const uint2x2* rhs )
{
	return !( uint2x2_cmpe( lhs, rhs ) );
}

uint2x2 uint2x2_comp_adds( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

uint2x2 uint2x2_comp_addm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_subs( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

uint2x2 uint2x2_comp_subm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_muls( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

uint2x2 uint2x2_comp_mulm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_divs( const uint2x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

uint2x2 uint2x2_comp_divm( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_and( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_and( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_or( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_or( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_xor( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_xor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_unary( const uint2x2* lhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y

	};
}

uint2x2 uint2x2_comp_shift_left( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_shift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x2 uint2x2_comp_shift_right( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		uint2_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_shift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmpl( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmple( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmpg( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 uint2x2_cmpge( const uint2x2* lhs, const uint2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		uint2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void uint2x2_identity( uint2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
}

uint2x2 uint2x2_transpose( const uint2x2* mat )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

uint2x2 uint2x2_mulm( const uint2x2* lhs, const uint2x2* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

uint2 uint2x2_mulv( const uint2x2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool uint2x3_cmpe( const uint2x3* lhs, const uint2x3* rhs )
{
	return uint3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool uint2x3_cmpne( const uint2x3* lhs, const uint2x3* rhs )
{
	return !( uint2x3_cmpe( lhs, rhs ) );
}

uint2x3 uint2x3_comp_adds( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

uint2x3 uint2x3_comp_addm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_subs( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

uint2x3 uint2x3_comp_subm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_muls( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

uint2x3 uint2x3_comp_mulm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_divs( const uint2x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

uint2x3 uint2x3_comp_divm( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_and( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_and( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_or( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_or( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_xor( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_xor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_unary( const uint2x3* lhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z

	};
}

uint2x3 uint2x3_comp_shift_left( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_shift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x3 uint2x3_comp_shift_right( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		uint3_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_shift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmpl( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmple( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmpg( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 uint2x3_cmpge( const uint2x3* lhs, const uint2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		uint3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void uint2x3_identity( uint2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
}

uint3x2 uint2x3_transpose( const uint2x3* mat )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

uint2x2 uint2x3_mulm( const uint2x3* lhs, const uint3x2* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

uint2x3 uint2x3_scale( const uint2x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool uint2x4_cmpe( const uint2x4* lhs, const uint2x4* rhs )
{
	return uint4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool uint2x4_cmpne( const uint2x4* lhs, const uint2x4* rhs )
{
	return !( uint2x4_cmpe( lhs, rhs ) );
}

uint2x4 uint2x4_comp_adds( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

uint2x4 uint2x4_comp_addm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_subs( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

uint2x4 uint2x4_comp_subm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_muls( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

uint2x4 uint2x4_comp_mulm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_divs( const uint2x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

uint2x4 uint2x4_comp_divm( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_and( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_and( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_or( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_or( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_xor( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_xor( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_unary( const uint2x4* lhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w

	};
}

uint2x4 uint2x4_comp_shift_left( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_shift_left( &lhs->rows[1], &rhs->rows[1] )
	};
}

uint2x4 uint2x4_comp_shift_right( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		uint4_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_shift_right( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmpl( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmple( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmpg( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 uint2x4_cmpge( const uint2x4* lhs, const uint2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		uint4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void uint2x4_identity( uint2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
}

uint4x2 uint2x4_transpose( const uint2x4* mat )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

uint2x2 uint2x4_mulm( const uint2x4* lhs, const uint4x2* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

uint2x4 uint2x4_scale( const uint2x4* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool uint3x2_cmpe( const uint3x2* lhs, const uint3x2* rhs )
{
	return uint2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool uint3x2_cmpne( const uint3x2* lhs, const uint3x2* rhs )
{
	return !( uint3x2_cmpe( lhs, rhs ) );
}

uint3x2 uint3x2_comp_adds( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

uint3x2 uint3x2_comp_addm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_subs( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

uint3x2 uint3x2_comp_subm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_muls( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

uint3x2 uint3x2_comp_mulm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_divs( const uint3x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

uint3x2 uint3x2_comp_divm( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_and( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_and( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_or( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_or( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_xor( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_xor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_unary( const uint3x2* lhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y

	};
}

uint3x2 uint3x2_comp_shift_left( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_shift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x2 uint3x2_comp_shift_right( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		uint2_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_shift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmpl( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmple( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmpg( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 uint3x2_cmpge( const uint3x2* lhs, const uint3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		uint2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void uint3x2_identity( uint3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat->rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

uint2x3 uint3x2_transpose( const uint3x2* mat )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

uint3x3 uint3x2_mulm( const uint3x2* lhs, const uint2x3* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];
	uint2 row2 = lhs->rows[2];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	uint2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool uint3x3_cmpe( const uint3x3* lhs, const uint3x3* rhs )
{
	return uint3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool uint3x3_cmpne( const uint3x3* lhs, const uint3x3* rhs )
{
	return !( uint3x3_cmpe( lhs, rhs ) );
}

uint3x3 uint3x3_comp_adds( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

uint3x3 uint3x3_comp_addm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_subs( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

uint3x3 uint3x3_comp_subm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_muls( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

uint3x3 uint3x3_comp_mulm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_divs( const uint3x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

uint3x3 uint3x3_comp_divm( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_and( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_and( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_or( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_or( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_xor( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_xor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_unary( const uint3x3* lhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z

	};
}

uint3x3 uint3x3_comp_shift_left( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_shift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x3 uint3x3_comp_shift_right( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		uint3_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_shift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmpl( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmple( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmpg( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 uint3x3_cmpge( const uint3x3* lhs, const uint3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		uint3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void uint3x3_identity( uint3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
}

uint3x3 uint3x3_transpose( const uint3x3* mat )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

uint3x3 uint3x3_mulm( const uint3x3* lhs, const uint3x3* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];
	uint3 row2 = lhs->rows[2];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	uint3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

uint3 uint3x3_mulv( const uint3x3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

uint3x3 uint3x3_translate( const uint3x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

uint3x3 uint3x3_scale( const uint3x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool uint3x4_cmpe( const uint3x4* lhs, const uint3x4* rhs )
{
	return uint4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool uint3x4_cmpne( const uint3x4* lhs, const uint3x4* rhs )
{
	return !( uint3x4_cmpe( lhs, rhs ) );
}

uint3x4 uint3x4_comp_adds( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

uint3x4 uint3x4_comp_addm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_subs( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

uint3x4 uint3x4_comp_subm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_muls( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

uint3x4 uint3x4_comp_mulm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_divs( const uint3x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

uint3x4 uint3x4_comp_divm( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_and( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_and( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_or( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_or( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_xor( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_xor( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_unary( const uint3x4* lhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w

	};
}

uint3x4 uint3x4_comp_shift_left( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_shift_left( &lhs->rows[2], &rhs->rows[2] )
	};
}

uint3x4 uint3x4_comp_shift_right( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		uint4_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_shift_right( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmpl( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmple( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmpg( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 uint3x4_cmpge( const uint3x4* lhs, const uint3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		uint4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void uint3x4_identity( uint3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
}

uint4x3 uint3x4_transpose( const uint3x4* mat )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

uint3x3 uint3x4_mulm( const uint3x4* lhs, const uint4x3* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];
	uint4 row2 = lhs->rows[2];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	uint4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

uint3x4 uint3x4_translate( const uint3x4* mat, const uint3* vec )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

uint3x4 uint3x4_scale( const uint3x4* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool uint4x2_cmpe( const uint4x2* lhs, const uint4x2* rhs )
{
	return uint2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& uint2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool uint4x2_cmpne( const uint4x2* lhs, const uint4x2* rhs )
{
	return !( uint4x2_cmpe( lhs, rhs ) );
}

uint4x2 uint4x2_comp_adds( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

uint4x2 uint4x2_comp_addm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_subs( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

uint4x2 uint4x2_comp_subm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_muls( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

uint4x2 uint4x2_comp_mulm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_divs( const uint4x2* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

uint4x2 uint4x2_comp_divm( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_and( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_and( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_and( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_or( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_or( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_or( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_xor( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_xor( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_xor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_unary( const uint4x2* lhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,

		~lhs->rows[1].x,
		~lhs->rows[1].y,

		~lhs->rows[2].x,
		~lhs->rows[2].y,

		~lhs->rows[3].x,
		~lhs->rows[3].y

	};
}

uint4x2 uint4x2_comp_shift_left( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_shift_left( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_shift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x2 uint4x2_comp_shift_right( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		uint2_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint2_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint2_comp_shift_right( &lhs->rows[2], &rhs->rows[2] ),
		uint2_comp_shift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmpl( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmple( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmpg( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 uint4x2_cmpge( const uint4x2* lhs, const uint4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		uint2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		uint2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void uint4x2_identity( uint4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat->rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
	mat->rows[3] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

uint2x4 uint4x2_transpose( const uint4x2* mat )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

uint4x4 uint4x2_mulm( const uint4x2* lhs, const uint2x4* rhs )
{
	uint2 row0 = lhs->rows[0];
	uint2 row1 = lhs->rows[1];
	uint2 row2 = lhs->rows[2];
	uint2 row3 = lhs->rows[3];

	uint2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	uint2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	uint2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	uint2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool uint4x3_cmpe( const uint4x3* lhs, const uint4x3* rhs )
{
	return uint3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& uint3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool uint4x3_cmpne( const uint4x3* lhs, const uint4x3* rhs )
{
	return !( uint4x3_cmpe( lhs, rhs ) );
}

uint4x3 uint4x3_comp_adds( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

uint4x3 uint4x3_comp_addm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_subs( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

uint4x3 uint4x3_comp_subm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_muls( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

uint4x3 uint4x3_comp_mulm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_divs( const uint4x3* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

uint4x3 uint4x3_comp_divm( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_and( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_and( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_and( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_or( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_or( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_or( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_xor( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_xor( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_xor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_unary( const uint4x3* lhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z

	};
}

uint4x3 uint4x3_comp_shift_left( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_shift_left( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_shift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x3 uint4x3_comp_shift_right( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		uint3_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint3_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint3_comp_shift_right( &lhs->rows[2], &rhs->rows[2] ),
		uint3_comp_shift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmpl( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmple( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmpg( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 uint4x3_cmpge( const uint4x3* lhs, const uint4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		uint3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		uint3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void uint4x3_identity( uint4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
	mat->rows[3] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 0U };
}

uint3x4 uint4x3_transpose( const uint4x3* mat )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

uint4x4 uint4x3_mulm( const uint4x3* lhs, const uint3x4* rhs )
{
	uint3 row0 = lhs->rows[0];
	uint3 row1 = lhs->rows[1];
	uint3 row2 = lhs->rows[2];
	uint3 row3 = lhs->rows[3];

	uint3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	uint3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	uint3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	uint3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

uint4x3 uint4x3_scale( const uint4x3* mat, const uint2* vec )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool uint4x4_cmpe( const uint4x4* lhs, const uint4x4* rhs )
{
	return uint4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& uint4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& uint4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& uint4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool uint4x4_cmpne( const uint4x4* lhs, const uint4x4* rhs )
{
	return !( uint4x4_cmpe( lhs, rhs ) );
}

uint4x4 uint4x4_comp_adds( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

uint4x4 uint4x4_comp_addm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_subs( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

uint4x4 uint4x4_comp_subm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_muls( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

uint4x4 uint4x4_comp_mulm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_divs( const uint4x4* lhs, const uint32_t scalar )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

uint4x4 uint4x4_comp_divm( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_and( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_and( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_and( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_and( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_and( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_or( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_or( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_or( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_or( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_or( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_xor( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_xor( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_xor( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_xor( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_xor( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_unary( const uint4x4* lhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		~lhs->rows[0].x,
		~lhs->rows[0].y,
		~lhs->rows[0].z,
		~lhs->rows[0].w,

		~lhs->rows[1].x,
		~lhs->rows[1].y,
		~lhs->rows[1].z,
		~lhs->rows[1].w,

		~lhs->rows[2].x,
		~lhs->rows[2].y,
		~lhs->rows[2].z,
		~lhs->rows[2].w,

		~lhs->rows[3].x,
		~lhs->rows[3].y,
		~lhs->rows[3].z,
		~lhs->rows[3].w

	};
}

uint4x4 uint4x4_comp_shift_left( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_shift_left( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_shift_left( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_shift_left( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_shift_left( &lhs->rows[3], &rhs->rows[3] )
	};
}

uint4x4 uint4x4_comp_shift_right( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		uint4_comp_shift_right( &lhs->rows[0], &rhs->rows[0] ),
		uint4_comp_shift_right( &lhs->rows[1], &rhs->rows[1] ),
		uint4_comp_shift_right( &lhs->rows[2], &rhs->rows[2] ),
		uint4_comp_shift_right( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmpl( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmple( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmpg( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 uint4x4_cmpge( const uint4x4* lhs, const uint4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		uint4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		uint4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		uint4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		uint4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void uint4x4_identity( uint4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat->rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat->rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
	mat->rows[3] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 0U, 1U };
}

uint4x4 uint4x4_transpose( const uint4x4* mat )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

uint4x4 uint4x4_mulm( const uint4x4* lhs, const uint4x4* rhs )
{
	uint4 row0 = lhs->rows[0];
	uint4 row1 = lhs->rows[1];
	uint4 row2 = lhs->rows[2];
	uint4 row3 = lhs->rows[3];

	uint4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	uint4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	uint4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	uint4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

uint4 uint4x4_mulv( const uint4x4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

uint4x4 uint4x4_translate( const uint4x4* mat, const uint3* vec )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

uint4x4 uint4x4_scale( const uint4x4* mat, const uint3* vec )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

bool float2x2_cmpe( const float2x2* lhs, const float2x2* rhs )
{
	return float2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool float2x2_cmpne( const float2x2* lhs, const float2x2* rhs )
{
	return !( float2x2_cmpe( lhs, rhs ) );
}

float2x2 float2x2_comp_adds( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

float2x2 float2x2_comp_addm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x2 float2x2_comp_subs( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

float2x2 float2x2_comp_subm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x2 float2x2_comp_muls( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

float2x2 float2x2_comp_mulm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x2 float2x2_comp_divs( const float2x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

float2x2 float2x2_comp_divm( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		float2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmpl( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmple( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmpg( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 float2x2_cmpge( const float2x2* lhs, const float2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		float2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void float2x2_identity( float2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
}

float2x2 float2x2_transpose( const float2x2* mat )
{
	return HLML_CONSTRUCT( float2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

float float2x2_determinant( const float2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

float2x2 float2x2_inverse( const float2x2* mat )
{
	const float invdet = 1.0f / float2x2_determinant( mat );
	return HLML_CONSTRUCT( float2x2 ) {
		 mat->rows[1].y * invdet, -mat->rows[0].y * invdet,
		-mat->rows[1].x * invdet,  mat->rows[0].x * invdet
	};
}

float2x2 float2x2_mulm( const float2x2* lhs, const float2x2* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

float2 float2x2_mulv( const float2x2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( float2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool float2x3_cmpe( const float2x3* lhs, const float2x3* rhs )
{
	return float3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool float2x3_cmpne( const float2x3* lhs, const float2x3* rhs )
{
	return !( float2x3_cmpe( lhs, rhs ) );
}

float2x3 float2x3_comp_adds( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

float2x3 float2x3_comp_addm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x3 float2x3_comp_subs( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

float2x3 float2x3_comp_subm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x3 float2x3_comp_muls( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

float2x3 float2x3_comp_mulm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x3 float2x3_comp_divs( const float2x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

float2x3 float2x3_comp_divm( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		float3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmpl( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmple( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmpg( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 float2x3_cmpge( const float2x3* lhs, const float2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		float3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void float2x3_identity( float2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
}

float3x2 float2x3_transpose( const float2x3* mat )
{
	return HLML_CONSTRUCT( float3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

float2x2 float2x3_mulm( const float2x3* lhs, const float3x2* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

float2x3 float2x3_scale( const float2x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool float2x4_cmpe( const float2x4* lhs, const float2x4* rhs )
{
	return float4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool float2x4_cmpne( const float2x4* lhs, const float2x4* rhs )
{
	return !( float2x4_cmpe( lhs, rhs ) );
}

float2x4 float2x4_comp_adds( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

float2x4 float2x4_comp_addm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x4 float2x4_comp_subs( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

float2x4 float2x4_comp_subm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x4 float2x4_comp_muls( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

float2x4 float2x4_comp_mulm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

float2x4 float2x4_comp_divs( const float2x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

float2x4 float2x4_comp_divm( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		float4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmpl( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmple( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmpg( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 float2x4_cmpge( const float2x4* lhs, const float2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		float4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void float2x4_identity( float2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
}

float4x2 float2x4_transpose( const float2x4* mat )
{
	return HLML_CONSTRUCT( float4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

float2x2 float2x4_mulm( const float2x4* lhs, const float4x2* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

float2x4 float2x4_scale( const float2x4* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool float3x2_cmpe( const float3x2* lhs, const float3x2* rhs )
{
	return float2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool float3x2_cmpne( const float3x2* lhs, const float3x2* rhs )
{
	return !( float3x2_cmpe( lhs, rhs ) );
}

float3x2 float3x2_comp_adds( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

float3x2 float3x2_comp_addm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x2 float3x2_comp_subs( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

float3x2 float3x2_comp_subm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x2 float3x2_comp_muls( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

float3x2 float3x2_comp_mulm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x2 float3x2_comp_divs( const float3x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

float3x2 float3x2_comp_divm( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		float2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmpl( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmple( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmpg( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 float3x2_cmpge( const float3x2* lhs, const float3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		float2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void float3x2_identity( float3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat->rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

float2x3 float3x2_transpose( const float3x2* mat )
{
	return HLML_CONSTRUCT( float2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

float3x3 float3x2_mulm( const float3x2* lhs, const float2x3* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];
	float2 row2 = lhs->rows[2];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	float2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool float3x3_cmpe( const float3x3* lhs, const float3x3* rhs )
{
	return float3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool float3x3_cmpne( const float3x3* lhs, const float3x3* rhs )
{
	return !( float3x3_cmpe( lhs, rhs ) );
}

float3x3 float3x3_comp_adds( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

float3x3 float3x3_comp_addm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x3 float3x3_comp_subs( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

float3x3 float3x3_comp_subm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x3 float3x3_comp_muls( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

float3x3 float3x3_comp_mulm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x3 float3x3_comp_divs( const float3x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

float3x3 float3x3_comp_divm( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		float3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmpl( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmple( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmpg( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 float3x3_cmpge( const float3x3* lhs, const float3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		float3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void float3x3_identity( float3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
}

float3x3 float3x3_transpose( const float3x3* mat )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

float float3x3_determinant( const float3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

float3x3 float3x3_inverse( const float3x3* mat )
{
	const float invdet = 1.0f / float3x3_determinant( mat );
	return HLML_CONSTRUCT( float3x3 ) {
		 ( mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y ) * invdet,
		-( mat->rows[0].y * mat->rows[2].z - mat->rows[0].z * mat->rows[2].y ) * invdet,
		 ( mat->rows[0].y * mat->rows[1].z - mat->rows[0].z * mat->rows[1].y ) * invdet,

		-( mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[2].z - mat->rows[0].z * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[1].z - mat->rows[0].z * mat->rows[1].x ) * invdet,

		 ( mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[2].y - mat->rows[0].y * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[1].y - mat->rows[0].y * mat->rows[1].x ) * invdet
	};
}

float3x3 float3x3_mulm( const float3x3* lhs, const float3x3* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];
	float3 row2 = lhs->rows[2];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	float3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

float3 float3x3_mulv( const float3x3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( float3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

float3x3 float3x3_translate( const float3x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

float3x3 float3x3_rotate( const float3x3* mat, const float rad )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 row0_cos  = float3_comp_muls( &mat->rows[0], c );
	float3 row0_sin  = float3_comp_muls( &mat->rows[0], s );
	float3 row1_nsin = float3_comp_muls( &mat->rows[1], -s );
	float3 row1_cos  = float3_comp_muls( &mat->rows[1], c );

	return HLML_CONSTRUCT( float3x3 ) {
		float3_comp_addv( &row0_cos, &row1_nsin ),
		float3_comp_addv( &row0_sin, &row1_cos  ),
		mat->rows[2]
	};
}

float3x3 float3x3_rotation_roll_pitch_yaw( const float3x3* mat, const float pitch, const float yaw, const float roll )
{
	const float cosYaw = cosf( yaw );
	const float cosPitch = cosf( pitch );
	const float cosRoll = cosf( roll );
	const float sinYaw = sinf( yaw );
	const float sinPitch = sinf( pitch );
	const float sinRoll = sinf( roll );

	float3 row0  = HLML_CONSTRUCT ( float3 ) { cosYaw * cosPitch, cosYaw * sinPitch * sinRoll - sinYaw * cosRoll, cosYaw * sinPitch * cosRoll + sinYaw * sinRoll };
	float3 row1  = HLML_CONSTRUCT ( float3 ) { sinYaw * cosPitch, sinYaw * sinPitch * sinRoll + cosYaw * cosRoll, sinYaw * sinPitch * cosRoll - cosYaw * sinRoll };
	float3 row2  = HLML_CONSTRUCT ( float3 ) { -sinPitch, cosPitch * sinRoll, cosPitch * cosRoll };
	return HLML_CONSTRUCT( float3x3 ) { row0, row1, row2 };
}

float3x3 float3x3_scale( const float3x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool float3x4_cmpe( const float3x4* lhs, const float3x4* rhs )
{
	return float4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool float3x4_cmpne( const float3x4* lhs, const float3x4* rhs )
{
	return !( float3x4_cmpe( lhs, rhs ) );
}

float3x4 float3x4_comp_adds( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

float3x4 float3x4_comp_addm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x4 float3x4_comp_subs( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

float3x4 float3x4_comp_subm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x4 float3x4_comp_muls( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

float3x4 float3x4_comp_mulm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

float3x4 float3x4_comp_divs( const float3x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

float3x4 float3x4_comp_divm( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		float4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmpl( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmple( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmpg( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 float3x4_cmpge( const float3x4* lhs, const float3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		float4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void float3x4_identity( float3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
}

float4x3 float3x4_transpose( const float3x4* mat )
{
	return HLML_CONSTRUCT( float4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

float3x3 float3x4_mulm( const float3x4* lhs, const float4x3* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];
	float4 row2 = lhs->rows[2];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	float4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

float3x4 float3x4_translate( const float3x4* mat, const float3* vec )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

float3x4 float3x4_scale( const float3x4* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool float4x2_cmpe( const float4x2* lhs, const float4x2* rhs )
{
	return float2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& float2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool float4x2_cmpne( const float4x2* lhs, const float4x2* rhs )
{
	return !( float4x2_cmpe( lhs, rhs ) );
}

float4x2 float4x2_comp_adds( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

float4x2 float4x2_comp_addm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		float2_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x2 float4x2_comp_subs( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

float4x2 float4x2_comp_subm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		float2_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x2 float4x2_comp_muls( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

float4x2 float4x2_comp_mulm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		float2_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x2 float4x2_comp_divs( const float4x2* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

float4x2 float4x2_comp_divm( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		float2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		float2_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		float2_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmpl( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmple( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmpg( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 float4x2_cmpge( const float4x2* lhs, const float4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		float2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		float2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void float4x2_identity( float4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat->rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
	mat->rows[3] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

float2x4 float4x2_transpose( const float4x2* mat )
{
	return HLML_CONSTRUCT( float2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

float4x4 float4x2_mulm( const float4x2* lhs, const float2x4* rhs )
{
	float2 row0 = lhs->rows[0];
	float2 row1 = lhs->rows[1];
	float2 row2 = lhs->rows[2];
	float2 row3 = lhs->rows[3];

	float2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	float2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	float2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	float2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool float4x3_cmpe( const float4x3* lhs, const float4x3* rhs )
{
	return float3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& float3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool float4x3_cmpne( const float4x3* lhs, const float4x3* rhs )
{
	return !( float4x3_cmpe( lhs, rhs ) );
}

float4x3 float4x3_comp_adds( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

float4x3 float4x3_comp_addm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		float3_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x3 float4x3_comp_subs( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

float4x3 float4x3_comp_subm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		float3_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x3 float4x3_comp_muls( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

float4x3 float4x3_comp_mulm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		float3_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x3 float4x3_comp_divs( const float4x3* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

float4x3 float4x3_comp_divm( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		float3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		float3_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		float3_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmpl( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmple( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmpg( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 float4x3_cmpge( const float4x3* lhs, const float4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		float3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		float3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void float4x3_identity( float4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
	mat->rows[3] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 0.0f };
}

float3x4 float4x3_transpose( const float4x3* mat )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

float4x4 float4x3_mulm( const float4x3* lhs, const float3x4* rhs )
{
	float3 row0 = lhs->rows[0];
	float3 row1 = lhs->rows[1];
	float3 row2 = lhs->rows[2];
	float3 row3 = lhs->rows[3];

	float3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	float3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	float3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	float3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

float4x3 float4x3_scale( const float4x3* mat, const float2* vec )
{
	return HLML_CONSTRUCT( float4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool float4x4_cmpe( const float4x4* lhs, const float4x4* rhs )
{
	return float4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& float4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& float4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& float4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool float4x4_cmpne( const float4x4* lhs, const float4x4* rhs )
{
	return !( float4x4_cmpe( lhs, rhs ) );
}

float4x4 float4x4_comp_adds( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

float4x4 float4x4_comp_addm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		float4_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x4 float4x4_comp_subs( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

float4x4 float4x4_comp_subm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		float4_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x4 float4x4_comp_muls( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

float4x4 float4x4_comp_mulm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		float4_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

float4x4 float4x4_comp_divs( const float4x4* lhs, const float scalar )
{
	return HLML_CONSTRUCT( float4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

float4x4 float4x4_comp_divm( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		float4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		float4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		float4_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		float4_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmpl( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmple( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmpg( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 float4x4_cmpge( const float4x4* lhs, const float4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		float4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		float4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		float4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		float4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void float4x4_identity( float4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat->rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat->rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
	mat->rows[3] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 0.0f, 1.0f };
}

float4x4 float4x4_transpose( const float4x4* mat )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

float float4x4_determinant( const float4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	float sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	float sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	float sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	float sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	float sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	float sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	float4 cofactor = HLML_CONSTRUCT( float4 ) {
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

float4x4 float4x4_inverse( const float4x4* mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	float sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	float sub01 = mat->rows[1].z * mat->rows[3].w - mat->rows[1].w * mat->rows[2].w;
	float sub02 = mat->rows[1].z * mat->rows[2].w - mat->rows[1].w * mat->rows[2].z;

	float sub03 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	float sub04 = mat->rows[1].y * mat->rows[3].w - mat->rows[1].w * mat->rows[3].y;
	float sub05 = mat->rows[1].y * mat->rows[2].w - mat->rows[1].w * mat->rows[2].y;

	float sub06 = mat->rows[2].y * mat->rows[3].z - mat->rows[2].z * mat->rows[3].y;
	float sub07 = mat->rows[1].y * mat->rows[3].z - mat->rows[1].z * mat->rows[3].y;
	float sub08 = mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y;

	float sub09 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	float sub10 = mat->rows[1].x * mat->rows[3].w - mat->rows[3].x * mat->rows[1].w;
	float sub11 = mat->rows[1].x * mat->rows[2].w - mat->rows[2].x * mat->rows[1].w;

	float sub12 = mat->rows[2].x * mat->rows[3].z - mat->rows[2].z * mat->rows[3].x;
	float sub13 = mat->rows[1].x * mat->rows[3].z - mat->rows[1].z * mat->rows[3].x;
	float sub14 = mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x;

	float sub15 = mat->rows[2].x * mat->rows[3].y - mat->rows[2].y * mat->rows[3].x;
	float sub16 = mat->rows[1].x * mat->rows[3].y - mat->rows[1].y * mat->rows[3].x;
	float sub17 = mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x;

	float4 fac0 = (float4) { sub00, sub00, sub01, sub02 };
	float4 fac1 = (float4) { sub03, sub03, sub04, sub05 };
	float4 fac2 = (float4) { sub06, sub06, sub07, sub08 };
	float4 fac3 = (float4) { sub09, sub09, sub10, sub11 };
	float4 fac4 = (float4) { sub12, sub12, sub13, sub14 };
	float4 fac5 = (float4) { sub15, sub15, sub16, sub17 };

	float4 vec0 = (float4) { mat->rows[1].x, mat->rows[0].x, mat->rows[0].x, mat->rows[0].x };
	float4 vec1 = (float4) { mat->rows[1].y, mat->rows[0].y, mat->rows[0].y, mat->rows[0].y };
	float4 vec2 = (float4) { mat->rows[1].z, mat->rows[0].z, mat->rows[0].z, mat->rows[0].z };
	float4 vec3 = (float4) { mat->rows[1].w, mat->rows[0].w, mat->rows[0].w, mat->rows[0].w };

	float4 inv0mula = float4_comp_mulv( &vec1, &fac0 );
	float4 inv0mulb = float4_comp_mulv( &vec2, &fac1 );
	float4 inv0mulc = float4_comp_mulv( &vec3, &fac2 );
	float4 inv0     = float4_comp_subv( &inv0mula, &inv0mulb );
	inv0 = float4_comp_addv( &inv0, &inv0mulc );

	float4 inv1mula = float4_comp_mulv( &vec0, &fac0 );
	float4 inv1mulb = float4_comp_mulv( &vec2, &fac3 );
	float4 inv1mulc = float4_comp_mulv( &vec3, &fac4 );
	float4 inv1     = float4_comp_subv( &inv1mula, &inv1mulb );
	inv1 = float4_comp_addv( &inv1, &inv1mulc );

	float4 inv2mula = float4_comp_mulv( &vec0, &fac1 );
	float4 inv2mulb = float4_comp_mulv( &vec1, &fac3 );
	float4 inv2mulc = float4_comp_mulv( &vec3, &fac5 );
	float4 inv2     = float4_comp_subv( &inv2mula, &inv2mulb );
	inv2 = float4_comp_addv( &inv2, &inv2mulc );

	float4 inv3mula = float4_comp_mulv( &vec0, &fac2 );
	float4 inv3mulb = float4_comp_mulv( &vec1, &fac4 );
	float4 inv3mulc = float4_comp_mulv( &vec2, &fac5 );
	float4 inv3     = float4_comp_subv( &inv3mula, &inv3mulb );
	inv3 = float4_comp_addv( &inv3, &inv3mulc );


	float4 sign0 = (float4) {  1, -1,  1, -1 };
	float4 sign1 = (float4) { -1,  1, -1,  1 };

	float4x4 result = (float4x4) {
		float4_comp_mulv( &inv0, &sign0 ),
		float4_comp_mulv( &inv1, &sign1 ),
		float4_comp_mulv( &inv2, &sign0 ),
		float4_comp_mulv( &inv3, &sign1 )
	};

	float4 col0 = (float4) { result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x };
	float4 dot0 = float4_comp_mulv( &mat->rows[0], &col0 );

	const float dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const float invdet = 1.0f / dot1;

	return float4x4_comp_muls( &result, invdet );
}

float4x4 float4x4_mulm( const float4x4* lhs, const float4x4* rhs )
{
	float4 row0 = lhs->rows[0];
	float4 row1 = lhs->rows[1];
	float4 row2 = lhs->rows[2];
	float4 row3 = lhs->rows[3];

	float4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	float4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	float4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	float4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

float4 float4x4_mulv( const float4x4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( float4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

float4x4 float4x4_translate( const float4x4* mat, const float3* vec )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

float4x4 float4x4_rotate( const float4x4* mat, const float rad, const float3* axis )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 u = float3_normalized( axis );
	float ic = 1.0f - c;

	float4x4 rotation = *mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return float4x4_mulm( mat, &rotation );
}

float4x4 float4x4_rotation_roll_pitch_yaw( const float4x4* mat, const float pitch, const float yaw, const float roll )
{
	const float cosYaw = cosf( yaw );
	const float cosPitch = cosf( pitch );
	const float cosRoll = cosf( roll );
	const float sinYaw = sinf( yaw );
	const float sinPitch = sinf( pitch );
	const float sinRoll = sinf( roll );

	float3 row0  = HLML_CONSTRUCT ( float3 ) { cosYaw * cosPitch, cosYaw * sinPitch * sinRoll - sinYaw * cosRoll, cosYaw * sinPitch * cosRoll + sinYaw * sinRoll, 0.0f };
	float3 row1  = HLML_CONSTRUCT ( float3 ) { sinYaw * cosPitch, sinYaw * sinPitch * sinRoll + cosYaw * cosRoll, sinYaw * sinPitch * cosRoll - cosYaw * sinRoll, 0.0f };
	float3 row2  = HLML_CONSTRUCT ( float3 ) { -sinPitch, cosPitch * sinRoll, cosPitch * cosRoll, 0.0f };
	float3 row3  = HLML_CONSTRUCT ( float3 ) { 0.0f, 0.0f, 0.0f, 1.0f};
	return HLML_CONSTRUCT( float4x4 ) { row0, row1, row2, row3 };
}

float4x4 float4x4_scale( const float4x4* mat, const float3* vec )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

float4x4 float4x4_ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip-space range: zero to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip-space range: minus-one to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip-space range: zero to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip-space range: minus-one to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: zero to one
	const float far_minus_near = zfar - znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

float4x4 float4x4_perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: minus-one to one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

float4x4 float4x4_perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: zero to one
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

float4x4 float4x4_perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: minus-one to one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, -far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

float4x4 float4x4_lookat_lh( const float3* eye, const float3* target, const float3* up )
{
	// left handed
	const float3 eye_to_target = float3_comp_subv( target, eye );
	const float3 forward = float3_normalized( &eye_to_target );
	const float3 up_cross_forward = float3_cross( up, &forward );
	const float3 right = float3_normalized( &up_cross_forward );
	const float3 up1 = float3_cross( &forward, &right );

	return HLML_CONSTRUCT( float4x4 ) {
		right.x,   right.y,   right.z,   -float3_dot( &right, eye ),
		up1.x,     up1.y,     up1.z,     -float3_dot( &up1, eye ),
		forward.x, forward.y, forward.z, -float3_dot( &forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 float4x4_lookat_rh( const float3* eye, const float3* target, const float3* up )
{
	// right handed
	const float3 eye_to_target = float3_comp_subv( target, eye );
	const float3 forward = float3_normalized( &eye_to_target );
	const float3 forward_cross_up = float3_cross( &forward, up );
	const float3 right = float3_normalized( &forward_cross_up );
	const float3 up1 = float3_cross( &right, &forward );

	return HLML_CONSTRUCT( float4x4 ) {
		 right.x,    right.y,    right.z,   -float3_dot( &right, eye ),
		 up1.x,      up1.y,      up1.z,     -float3_dot( &up1, eye ),
		-forward.x, -forward.y, -forward.z,  float3_dot( &forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

bool double2x2_cmpe( const double2x2* lhs, const double2x2* rhs )
{
	return double2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double2_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool double2x2_cmpne( const double2x2* lhs, const double2x2* rhs )
{
	return !( double2x2_cmpe( lhs, rhs ) );
}

double2x2 double2x2_comp_adds( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar
	};
}

double2x2 double2x2_comp_addm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x2 double2x2_comp_subs( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar
	};
}

double2x2 double2x2_comp_subm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x2 double2x2_comp_muls( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar
	};
}

double2x2 double2x2_comp_mulm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x2 double2x2_comp_divs( const double2x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar
	};
}

double2x2 double2x2_comp_divm( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		double2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmpl( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmple( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmpg( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x2 double2x2_cmpge( const double2x2* lhs, const double2x2* rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		double2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void double2x2_identity( double2x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
}

double2x2 double2x2_transpose( const double2x2* mat )
{
	return HLML_CONSTRUCT( double2x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y
	};
}

double double2x2_determinant( const double2x2* mat )
{
	return mat->rows[0].x * mat->rows[1].y - mat->rows[1].x * mat->rows[0].y;
}

double2x2 double2x2_inverse( const double2x2* mat )
{
	const double invdet = 1.0 / double2x2_determinant( mat );
	return HLML_CONSTRUCT( double2x2 ) {
		 mat->rows[1].y * invdet, -mat->rows[0].y * invdet,
		-mat->rows[1].x * invdet,  mat->rows[0].x * invdet
	};
}

double2x2 double2x2_mulm( const double2x2* lhs, const double2x2* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

double2 double2x2_mulv( const double2x2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( double2 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y
	};
}

bool double2x3_cmpe( const double2x3* lhs, const double2x3* rhs )
{
	return double3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double3_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool double2x3_cmpne( const double2x3* lhs, const double2x3* rhs )
{
	return !( double2x3_cmpe( lhs, rhs ) );
}

double2x3 double2x3_comp_adds( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar
	};
}

double2x3 double2x3_comp_addm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x3 double2x3_comp_subs( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar
	};
}

double2x3 double2x3_comp_subm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x3 double2x3_comp_muls( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar
	};
}

double2x3 double2x3_comp_mulm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x3 double2x3_comp_divs( const double2x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar
	};
}

double2x3 double2x3_comp_divm( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		double3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmpl( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmple( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmpg( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x3 double2x3_cmpge( const double2x3* lhs, const double2x3* rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		double3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void double2x3_identity( double2x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
}

double3x2 double2x3_transpose( const double2x3* mat )
{
	return HLML_CONSTRUCT( double3x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z
	};
}

double2x2 double2x3_mulm( const double2x3* lhs, const double3x2* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

double2x3 double2x3_scale( const double2x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double2x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z
	};
}

bool double2x4_cmpe( const double2x4* lhs, const double2x4* rhs )
{
	return double4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double4_cmpe( &lhs->rows[1], &rhs->rows[1] );
}

bool double2x4_cmpne( const double2x4* lhs, const double2x4* rhs )
{
	return !( double2x4_cmpe( lhs, rhs ) );
}

double2x4 double2x4_comp_adds( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar
	};
}

double2x4 double2x4_comp_addm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_addv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x4 double2x4_comp_subs( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar
	};
}

double2x4 double2x4_comp_subm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_subv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x4 double2x4_comp_muls( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar
	};
}

double2x4 double2x4_comp_mulm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_mulv( &lhs->rows[1], &rhs->rows[1] )
	};
}

double2x4 double2x4_comp_divs( const double2x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double2x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar
	};
}

double2x4 double2x4_comp_divm( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		double4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_divv( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmpl( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpl( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmple( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmple( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmpg( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpg( &lhs->rows[1], &rhs->rows[1] )
	};
}

bool2x4 double2x4_cmpge( const double2x4* lhs, const double2x4* rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		double4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpge( &lhs->rows[1], &rhs->rows[1] )
	};
}

void double2x4_identity( double2x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
}

double4x2 double2x4_transpose( const double2x4* mat )
{
	return HLML_CONSTRUCT( double4x2 ) {
		mat->rows[0].x, mat->rows[1].x,
		mat->rows[0].y, mat->rows[1].y,
		mat->rows[0].z, mat->rows[1].z,
		mat->rows[0].w, mat->rows[1].w
	};
}

double2x2 double2x4_mulm( const double2x4* lhs, const double4x2* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

double2x4 double2x4_scale( const double2x4* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double2x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w
	};
}

bool double3x2_cmpe( const double3x2* lhs, const double3x2* rhs )
{
	return double2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double2_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool double3x2_cmpne( const double3x2* lhs, const double3x2* rhs )
{
	return !( double3x2_cmpe( lhs, rhs ) );
}

double3x2 double3x2_comp_adds( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar
	};
}

double3x2 double3x2_comp_addm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x2 double3x2_comp_subs( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar
	};
}

double3x2 double3x2_comp_subm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x2 double3x2_comp_muls( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar
	};
}

double3x2 double3x2_comp_mulm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x2 double3x2_comp_divs( const double3x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar
	};
}

double3x2 double3x2_comp_divm( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		double2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmpl( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmple( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmpg( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x2 double3x2_cmpge( const double3x2* lhs, const double3x2* rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		double2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void double3x2_identity( double3x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat->rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

double2x3 double3x2_transpose( const double3x2* mat )
{
	return HLML_CONSTRUCT( double2x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y
	};
}

double3x3 double3x2_mulm( const double3x2* lhs, const double2x3* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];
	double2 row2 = lhs->rows[2];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	double2 col2 = { rhs->rows[0].z, rhs->rows[1].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool double3x3_cmpe( const double3x3* lhs, const double3x3* rhs )
{
	return double3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double3_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool double3x3_cmpne( const double3x3* lhs, const double3x3* rhs )
{
	return !( double3x3_cmpe( lhs, rhs ) );
}

double3x3 double3x3_comp_adds( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar
	};
}

double3x3 double3x3_comp_addm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x3 double3x3_comp_subs( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar
	};
}

double3x3 double3x3_comp_subm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x3 double3x3_comp_muls( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar
	};
}

double3x3 double3x3_comp_mulm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x3 double3x3_comp_divs( const double3x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar
	};
}

double3x3 double3x3_comp_divm( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		double3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmpl( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmple( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmpg( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x3 double3x3_cmpge( const double3x3* lhs, const double3x3* rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		double3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void double3x3_identity( double3x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
}

double3x3 double3x3_transpose( const double3x3* mat )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z
	};
}

double double3x3_determinant( const double3x3* mat )
{
	return
		+ mat->rows[0].x * ( mat->rows[1].y * mat->rows[2].z - mat->rows[2].y * mat->rows[1].z ) 
		- mat->rows[0].y * ( mat->rows[1].x * mat->rows[2].z - mat->rows[2].x * mat->rows[1].z ) 
		+ mat->rows[0].z * ( mat->rows[1].x * mat->rows[2].y - mat->rows[2].x * mat->rows[1].y );
}

double3x3 double3x3_inverse( const double3x3* mat )
{
	const double invdet = 1.0 / double3x3_determinant( mat );
	return HLML_CONSTRUCT( double3x3 ) {
		 ( mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y ) * invdet,
		-( mat->rows[0].y * mat->rows[2].z - mat->rows[0].z * mat->rows[2].y ) * invdet,
		 ( mat->rows[0].y * mat->rows[1].z - mat->rows[0].z * mat->rows[1].y ) * invdet,

		-( mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[2].z - mat->rows[0].z * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[1].z - mat->rows[0].z * mat->rows[1].x ) * invdet,

		 ( mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x ) * invdet,
		-( mat->rows[0].x * mat->rows[2].y - mat->rows[0].y * mat->rows[2].x ) * invdet,
		 ( mat->rows[0].x * mat->rows[1].y - mat->rows[0].y * mat->rows[1].x ) * invdet
	};
}

double3x3 double3x3_mulm( const double3x3* lhs, const double3x3* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];
	double3 row2 = lhs->rows[2];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	double3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

double3 double3x3_mulv( const double3x3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( double3 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z
	};
}

double3x3 double3x3_translate( const double3x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z
	};
}

double3x3 double3x3_rotate( const double3x3* mat, const double rad )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 row0_cos  = double3_comp_muls( &mat->rows[0], c );
	double3 row0_sin  = double3_comp_muls( &mat->rows[0], s );
	double3 row1_nsin = double3_comp_muls( &mat->rows[1], -s );
	double3 row1_cos  = double3_comp_muls( &mat->rows[1], c );

	return HLML_CONSTRUCT( double3x3 ) {
		double3_comp_addv( &row0_cos, &row1_nsin ),
		double3_comp_addv( &row0_sin, &row1_cos  ),
		mat->rows[2]
	};
}

double3x3 double3x3_rotation_roll_pitch_yaw( const double3x3* mat, const double pitch, const double yaw, const double roll )
{
	const double cosYaw = cos( yaw );
	const double cosPitch = cos( pitch );
	const double cosRoll = cos( roll );
	const double sinYaw = sin( yaw );
	const double sinPitch = sin( pitch );
	const double sinRoll = sin( roll );

	double3 row0  = HLML_CONSTRUCT ( double3 ) { cosYaw * cosPitch, cosYaw * sinPitch * sinRoll - sinYaw * cosRoll, cosYaw * sinPitch * cosRoll + sinYaw * sinRoll };
	double3 row1  = HLML_CONSTRUCT ( double3 ) { sinYaw * cosPitch, sinYaw * sinPitch * sinRoll + cosYaw * cosRoll, sinYaw * sinPitch * cosRoll - cosYaw * sinRoll };
	double3 row2  = HLML_CONSTRUCT ( double3 ) { -sinPitch, cosPitch * sinRoll, cosPitch * cosRoll };
	return HLML_CONSTRUCT( double3x3 ) { row0, row1, row2 };
}

double3x3 double3x3_scale( const double3x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z
	};
}

bool double3x4_cmpe( const double3x4* lhs, const double3x4* rhs )
{
	return double4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double4_cmpe( &lhs->rows[2], &rhs->rows[2] );
}

bool double3x4_cmpne( const double3x4* lhs, const double3x4* rhs )
{
	return !( double3x4_cmpe( lhs, rhs ) );
}

double3x4 double3x4_comp_adds( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar
	};
}

double3x4 double3x4_comp_addm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_addv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x4 double3x4_comp_subs( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar
	};
}

double3x4 double3x4_comp_subm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_subv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x4 double3x4_comp_muls( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar
	};
}

double3x4 double3x4_comp_mulm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_mulv( &lhs->rows[2], &rhs->rows[2] )
	};
}

double3x4 double3x4_comp_divs( const double3x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double3x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar
	};
}

double3x4 double3x4_comp_divm( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		double4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_divv( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmpl( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpl( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmple( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmple( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmpg( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpg( &lhs->rows[2], &rhs->rows[2] )
	};
}

bool3x4 double3x4_cmpge( const double3x4* lhs, const double3x4* rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		double4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpge( &lhs->rows[2], &rhs->rows[2] )
	};
}

void double3x4_identity( double3x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
}

double4x3 double3x4_transpose( const double3x4* mat )
{
	return HLML_CONSTRUCT( double4x3 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w
	};
}

double3x3 double3x4_mulm( const double3x4* lhs, const double4x3* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];
	double4 row2 = lhs->rows[2];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	double4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

double3x4 double3x4_translate( const double3x4* mat, const double3* vec )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z
	};
}

double3x4 double3x4_scale( const double3x4* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,
		mat->rows[2].w
	};
}

bool double4x2_cmpe( const double4x2* lhs, const double4x2* rhs )
{
	return double2_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double2_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double2_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& double2_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool double4x2_cmpne( const double4x2* lhs, const double4x2* rhs )
{
	return !( double4x2_cmpe( lhs, rhs ) );
}

double4x2 double4x2_comp_adds( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar
	};
}

double4x2 double4x2_comp_addm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		double2_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x2 double4x2_comp_subs( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar
	};
}

double4x2 double4x2_comp_subm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		double2_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x2 double4x2_comp_muls( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar
	};
}

double4x2 double4x2_comp_mulm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		double2_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x2 double4x2_comp_divs( const double4x2* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x2 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar
	};
}

double4x2 double4x2_comp_divm( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		double2_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double2_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		double2_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		double2_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmpl( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmple( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmple( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmpg( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x2 double4x2_cmpge( const double4x2* lhs, const double4x2* rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		double2_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double2_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double2_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		double2_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void double4x2_identity( double4x2* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat->rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
	mat->rows[3] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

double2x4 double4x2_transpose( const double4x2* mat )
{
	return HLML_CONSTRUCT( double2x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y
	};
}

double4x4 double4x2_mulm( const double4x2* lhs, const double2x4* rhs )
{
	double2 row0 = lhs->rows[0];
	double2 row1 = lhs->rows[1];
	double2 row2 = lhs->rows[2];
	double2 row3 = lhs->rows[3];

	double2 col0 = { rhs->rows[0].x, rhs->rows[1].x };
	double2 col1 = { rhs->rows[0].y, rhs->rows[1].y };
	double2 col2 = { rhs->rows[0].z, rhs->rows[1].z };
	double2 col3 = { rhs->rows[0].w, rhs->rows[1].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool double4x3_cmpe( const double4x3* lhs, const double4x3* rhs )
{
	return double3_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double3_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double3_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& double3_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool double4x3_cmpne( const double4x3* lhs, const double4x3* rhs )
{
	return !( double4x3_cmpe( lhs, rhs ) );
}

double4x3 double4x3_comp_adds( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar
	};
}

double4x3 double4x3_comp_addm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		double3_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x3 double4x3_comp_subs( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar
	};
}

double4x3 double4x3_comp_subm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		double3_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x3 double4x3_comp_muls( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar
	};
}

double4x3 double4x3_comp_mulm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		double3_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x3 double4x3_comp_divs( const double4x3* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x3 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar
	};
}

double4x3 double4x3_comp_divm( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		double3_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double3_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		double3_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		double3_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmpl( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmple( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmple( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmpg( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x3 double4x3_cmpge( const double4x3* lhs, const double4x3* rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		double3_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double3_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double3_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		double3_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void double4x3_identity( double4x3* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
	mat->rows[3] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 0.0 };
}

double3x4 double4x3_transpose( const double4x3* mat )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z
	};
}

double4x4 double4x3_mulm( const double4x3* lhs, const double3x4* rhs )
{
	double3 row0 = lhs->rows[0];
	double3 row1 = lhs->rows[1];
	double3 row2 = lhs->rows[2];
	double3 row3 = lhs->rows[3];

	double3 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x };
	double3 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y };
	double3 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z };
	double3 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

double4x3 double4x3_scale( const double4x3* mat, const double2* vec )
{
	return HLML_CONSTRUCT( double4x3 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z
	};
}

bool double4x4_cmpe( const double4x4* lhs, const double4x4* rhs )
{
	return double4_cmpe( &lhs->rows[0], &rhs->rows[0] )
		&& double4_cmpe( &lhs->rows[1], &rhs->rows[1] )
		&& double4_cmpe( &lhs->rows[2], &rhs->rows[2] )
		&& double4_cmpe( &lhs->rows[3], &rhs->rows[3] );
}

bool double4x4_cmpne( const double4x4* lhs, const double4x4* rhs )
{
	return !( double4x4_cmpe( lhs, rhs ) );
}

double4x4 double4x4_comp_adds( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x + scalar, lhs->rows[0].y + scalar, lhs->rows[0].z + scalar, lhs->rows[0].w + scalar,
		lhs->rows[1].x + scalar, lhs->rows[1].y + scalar, lhs->rows[1].z + scalar, lhs->rows[1].w + scalar,
		lhs->rows[2].x + scalar, lhs->rows[2].y + scalar, lhs->rows[2].z + scalar, lhs->rows[2].w + scalar,
		lhs->rows[3].x + scalar, lhs->rows[3].y + scalar, lhs->rows[3].z + scalar, lhs->rows[3].w + scalar
	};
}

double4x4 double4x4_comp_addm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_comp_addv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_addv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_addv( &lhs->rows[2], &rhs->rows[2] ),
		double4_comp_addv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x4 double4x4_comp_subs( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x - scalar, lhs->rows[0].y - scalar, lhs->rows[0].z - scalar, lhs->rows[0].w - scalar,
		lhs->rows[1].x - scalar, lhs->rows[1].y - scalar, lhs->rows[1].z - scalar, lhs->rows[1].w - scalar,
		lhs->rows[2].x - scalar, lhs->rows[2].y - scalar, lhs->rows[2].z - scalar, lhs->rows[2].w - scalar,
		lhs->rows[3].x - scalar, lhs->rows[3].y - scalar, lhs->rows[3].z - scalar, lhs->rows[3].w - scalar
	};
}

double4x4 double4x4_comp_subm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_comp_subv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_subv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_subv( &lhs->rows[2], &rhs->rows[2] ),
		double4_comp_subv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x4 double4x4_comp_muls( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x * scalar, lhs->rows[0].y * scalar, lhs->rows[0].z * scalar, lhs->rows[0].w * scalar,
		lhs->rows[1].x * scalar, lhs->rows[1].y * scalar, lhs->rows[1].z * scalar, lhs->rows[1].w * scalar,
		lhs->rows[2].x * scalar, lhs->rows[2].y * scalar, lhs->rows[2].z * scalar, lhs->rows[2].w * scalar,
		lhs->rows[3].x * scalar, lhs->rows[3].y * scalar, lhs->rows[3].z * scalar, lhs->rows[3].w * scalar
	};
}

double4x4 double4x4_comp_mulm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_comp_mulv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_mulv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_mulv( &lhs->rows[2], &rhs->rows[2] ),
		double4_comp_mulv( &lhs->rows[3], &rhs->rows[3] )
	};
}

double4x4 double4x4_comp_divs( const double4x4* lhs, const double scalar )
{
	return HLML_CONSTRUCT( double4x4 ) {
		lhs->rows[0].x / scalar, lhs->rows[0].y / scalar, lhs->rows[0].z / scalar, lhs->rows[0].w / scalar,
		lhs->rows[1].x / scalar, lhs->rows[1].y / scalar, lhs->rows[1].z / scalar, lhs->rows[1].w / scalar,
		lhs->rows[2].x / scalar, lhs->rows[2].y / scalar, lhs->rows[2].z / scalar, lhs->rows[2].w / scalar,
		lhs->rows[3].x / scalar, lhs->rows[3].y / scalar, lhs->rows[3].z / scalar, lhs->rows[3].w / scalar
	};
}

double4x4 double4x4_comp_divm( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		double4_comp_divv( &lhs->rows[0], &rhs->rows[0] ),
		double4_comp_divv( &lhs->rows[1], &rhs->rows[1] ),
		double4_comp_divv( &lhs->rows[2], &rhs->rows[2] ),
		double4_comp_divv( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmpl( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmpl( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpl( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpl( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmpl( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmple( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmple( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmple( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmple( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmple( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmpg( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmpg( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpg( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpg( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmpg( &lhs->rows[3], &rhs->rows[3] )
	};
}

bool4x4 double4x4_cmpge( const double4x4* lhs, const double4x4* rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		double4_cmpge( &lhs->rows[0], &rhs->rows[0] ),
		double4_cmpge( &lhs->rows[1], &rhs->rows[1] ),
		double4_cmpge( &lhs->rows[2], &rhs->rows[2] ),
		double4_cmpge( &lhs->rows[3], &rhs->rows[3] )
	};
}

void double4x4_identity( double4x4* mat )
{
	mat->rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat->rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat->rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
	mat->rows[3] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 0.0, 1.0 };
}

double4x4 double4x4_transpose( const double4x4* mat )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat->rows[0].x, mat->rows[1].x, mat->rows[2].x, mat->rows[3].x,
		mat->rows[0].y, mat->rows[1].y, mat->rows[2].y, mat->rows[3].y,
		mat->rows[0].z, mat->rows[1].z, mat->rows[2].z, mat->rows[3].z,
		mat->rows[0].w, mat->rows[1].w, mat->rows[2].w, mat->rows[3].w
	};
}

double double4x4_determinant( const double4x4* mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	double sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	double sub01 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	double sub02 = mat->rows[2].y * mat->rows[3].z - mat->rows[3].y * mat->rows[2].z;
	double sub03 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	double sub04 = mat->rows[2].x * mat->rows[3].z - mat->rows[3].x * mat->rows[2].z;
	double sub05 = mat->rows[2].x * mat->rows[3].y - mat->rows[3].x * mat->rows[2].y;

	double4 cofactor = HLML_CONSTRUCT( double4 ) {
		 ( ( ( mat->rows[1].y * sub00 ) - ( mat->rows[1].z * sub01 ) ) + ( mat->rows[1].w * sub02 ) ),
		-( ( ( mat->rows[1].x * sub00 ) - ( mat->rows[1].z * sub03 ) ) + ( mat->rows[1].w * sub04 ) ),
		 ( ( ( mat->rows[1].x * sub01 ) - ( mat->rows[1].y * sub03 ) ) + ( mat->rows[1].w * sub05 ) ),
		-( ( ( mat->rows[1].x * sub02 ) - ( mat->rows[1].y * sub04 ) ) + ( mat->rows[1].z * sub05 ) ) 
	};

	return
		mat->rows[0].x * cofactor.x + mat->rows[0].y * cofactor.y +
		mat->rows[0].z * cofactor.z + mat->rows[0].w * cofactor.w; 
}

double4x4 double4x4_inverse( const double4x4* mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	double sub00 = mat->rows[2].z * mat->rows[3].w - mat->rows[3].z * mat->rows[2].w;
	double sub01 = mat->rows[1].z * mat->rows[3].w - mat->rows[1].w * mat->rows[2].w;
	double sub02 = mat->rows[1].z * mat->rows[2].w - mat->rows[1].w * mat->rows[2].z;

	double sub03 = mat->rows[2].y * mat->rows[3].w - mat->rows[2].w * mat->rows[3].y;
	double sub04 = mat->rows[1].y * mat->rows[3].w - mat->rows[1].w * mat->rows[3].y;
	double sub05 = mat->rows[1].y * mat->rows[2].w - mat->rows[1].w * mat->rows[2].y;

	double sub06 = mat->rows[2].y * mat->rows[3].z - mat->rows[2].z * mat->rows[3].y;
	double sub07 = mat->rows[1].y * mat->rows[3].z - mat->rows[1].z * mat->rows[3].y;
	double sub08 = mat->rows[1].y * mat->rows[2].z - mat->rows[1].z * mat->rows[2].y;

	double sub09 = mat->rows[2].x * mat->rows[3].w - mat->rows[3].x * mat->rows[2].w;
	double sub10 = mat->rows[1].x * mat->rows[3].w - mat->rows[3].x * mat->rows[1].w;
	double sub11 = mat->rows[1].x * mat->rows[2].w - mat->rows[2].x * mat->rows[1].w;

	double sub12 = mat->rows[2].x * mat->rows[3].z - mat->rows[2].z * mat->rows[3].x;
	double sub13 = mat->rows[1].x * mat->rows[3].z - mat->rows[1].z * mat->rows[3].x;
	double sub14 = mat->rows[1].x * mat->rows[2].z - mat->rows[1].z * mat->rows[2].x;

	double sub15 = mat->rows[2].x * mat->rows[3].y - mat->rows[2].y * mat->rows[3].x;
	double sub16 = mat->rows[1].x * mat->rows[3].y - mat->rows[1].y * mat->rows[3].x;
	double sub17 = mat->rows[1].x * mat->rows[2].y - mat->rows[1].y * mat->rows[2].x;

	double4 fac0 = (double4) { sub00, sub00, sub01, sub02 };
	double4 fac1 = (double4) { sub03, sub03, sub04, sub05 };
	double4 fac2 = (double4) { sub06, sub06, sub07, sub08 };
	double4 fac3 = (double4) { sub09, sub09, sub10, sub11 };
	double4 fac4 = (double4) { sub12, sub12, sub13, sub14 };
	double4 fac5 = (double4) { sub15, sub15, sub16, sub17 };

	double4 vec0 = (double4) { mat->rows[1].x, mat->rows[0].x, mat->rows[0].x, mat->rows[0].x };
	double4 vec1 = (double4) { mat->rows[1].y, mat->rows[0].y, mat->rows[0].y, mat->rows[0].y };
	double4 vec2 = (double4) { mat->rows[1].z, mat->rows[0].z, mat->rows[0].z, mat->rows[0].z };
	double4 vec3 = (double4) { mat->rows[1].w, mat->rows[0].w, mat->rows[0].w, mat->rows[0].w };

	double4 inv0mula = double4_comp_mulv( &vec1, &fac0 );
	double4 inv0mulb = double4_comp_mulv( &vec2, &fac1 );
	double4 inv0mulc = double4_comp_mulv( &vec3, &fac2 );
	double4 inv0     = double4_comp_subv( &inv0mula, &inv0mulb );
	inv0 = double4_comp_addv( &inv0, &inv0mulc );

	double4 inv1mula = double4_comp_mulv( &vec0, &fac0 );
	double4 inv1mulb = double4_comp_mulv( &vec2, &fac3 );
	double4 inv1mulc = double4_comp_mulv( &vec3, &fac4 );
	double4 inv1     = double4_comp_subv( &inv1mula, &inv1mulb );
	inv1 = double4_comp_addv( &inv1, &inv1mulc );

	double4 inv2mula = double4_comp_mulv( &vec0, &fac1 );
	double4 inv2mulb = double4_comp_mulv( &vec1, &fac3 );
	double4 inv2mulc = double4_comp_mulv( &vec3, &fac5 );
	double4 inv2     = double4_comp_subv( &inv2mula, &inv2mulb );
	inv2 = double4_comp_addv( &inv2, &inv2mulc );

	double4 inv3mula = double4_comp_mulv( &vec0, &fac2 );
	double4 inv3mulb = double4_comp_mulv( &vec1, &fac4 );
	double4 inv3mulc = double4_comp_mulv( &vec2, &fac5 );
	double4 inv3     = double4_comp_subv( &inv3mula, &inv3mulb );
	inv3 = double4_comp_addv( &inv3, &inv3mulc );


	double4 sign0 = (double4) {  1, -1,  1, -1 };
	double4 sign1 = (double4) { -1,  1, -1,  1 };

	double4x4 result = (double4x4) {
		double4_comp_mulv( &inv0, &sign0 ),
		double4_comp_mulv( &inv1, &sign1 ),
		double4_comp_mulv( &inv2, &sign0 ),
		double4_comp_mulv( &inv3, &sign1 )
	};

	double4 col0 = (double4) { result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x };
	double4 dot0 = double4_comp_mulv( &mat->rows[0], &col0 );

	const double dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const double invdet = 1.0 / dot1;

	return double4x4_comp_muls( &result, invdet );
}

double4x4 double4x4_mulm( const double4x4* lhs, const double4x4* rhs )
{
	double4 row0 = lhs->rows[0];
	double4 row1 = lhs->rows[1];
	double4 row2 = lhs->rows[2];
	double4 row3 = lhs->rows[3];

	double4 col0 = { rhs->rows[0].x, rhs->rows[1].x, rhs->rows[2].x, rhs->rows[3].x };
	double4 col1 = { rhs->rows[0].y, rhs->rows[1].y, rhs->rows[2].y, rhs->rows[3].y };
	double4 col2 = { rhs->rows[0].z, rhs->rows[1].z, rhs->rows[2].z, rhs->rows[3].z };
	double4 col3 = { rhs->rows[0].w, rhs->rows[1].w, rhs->rows[2].w, rhs->rows[3].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

double4 double4x4_mulv( const double4x4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( double4 ) {
		lhs->rows[0].x * rhs->x + lhs->rows[0].y * rhs->y + lhs->rows[0].z * rhs->z + lhs->rows[0].w * rhs->w,
		lhs->rows[1].x * rhs->x + lhs->rows[1].y * rhs->y + lhs->rows[1].z * rhs->z + lhs->rows[1].w * rhs->w,
		lhs->rows[2].x * rhs->x + lhs->rows[2].y * rhs->y + lhs->rows[2].z * rhs->z + lhs->rows[2].w * rhs->w,
		lhs->rows[3].x * rhs->x + lhs->rows[3].y * rhs->y + lhs->rows[3].z * rhs->z + lhs->rows[3].w * rhs->w
	};
}

double4x4 double4x4_translate( const double4x4* mat, const double3* vec )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat->rows[0].x, mat->rows[0].y, mat->rows[0].z, mat->rows[0].w + vec->x,
		mat->rows[1].x, mat->rows[1].y, mat->rows[1].z, mat->rows[1].w + vec->y,
		mat->rows[2].x, mat->rows[2].y, mat->rows[2].z, mat->rows[2].w + vec->z,
		mat->rows[3].x, mat->rows[3].y, mat->rows[3].z, mat->rows[3].w
	};
}

double4x4 double4x4_rotate( const double4x4* mat, const double rad, const double3* axis )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 u = double3_normalized( axis );
	double ic = 1.0 - c;

	double4x4 rotation = *mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return double4x4_mulm( mat, &rotation );
}

double4x4 double4x4_rotation_roll_pitch_yaw( const double4x4* mat, const double pitch, const double yaw, const double roll )
{
	const double cosYaw = cos( yaw );
	const double cosPitch = cos( pitch );
	const double cosRoll = cos( roll );
	const double sinYaw = sin( yaw );
	const double sinPitch = sin( pitch );
	const double sinRoll = sin( roll );

	double3 row0  = HLML_CONSTRUCT ( double3 ) { cosYaw * cosPitch, cosYaw * sinPitch * sinRoll - sinYaw * cosRoll, cosYaw * sinPitch * cosRoll + sinYaw * sinRoll, 0.0 };
	double3 row1  = HLML_CONSTRUCT ( double3 ) { sinYaw * cosPitch, sinYaw * sinPitch * sinRoll + cosYaw * cosRoll, sinYaw * sinPitch * cosRoll - cosYaw * sinRoll, 0.0 };
	double3 row2  = HLML_CONSTRUCT ( double3 ) { -sinPitch, cosPitch * sinRoll, cosPitch * cosRoll, 0.0 };
	double3 row3  = HLML_CONSTRUCT ( double3 ) { 0.0, 0.0, 0.0, 1.0};
	return HLML_CONSTRUCT( double4x4 ) { row0, row1, row2, row3 };
}

double4x4 double4x4_scale( const double4x4* mat, const double3* vec )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat->rows[0].x * vec->x,
		mat->rows[0].y,
		mat->rows[0].z,
		mat->rows[0].w,

		mat->rows[1].x,
		mat->rows[1].y * vec->y,
		mat->rows[1].z,
		mat->rows[1].w,

		mat->rows[2].x,
		mat->rows[2].y,
		mat->rows[2].z * vec->z,
		mat->rows[2].w,

		mat->rows[3].x,
		mat->rows[3].y,
		mat->rows[3].z,
		mat->rows[3].w
	};
}

double4x4 double4x4_ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip-space range: zero to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip-space range: minus-one to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip-space range: zero to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip-space range: minus-one to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: zero to one
	const double far_minus_near = zfar - znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

double4x4 double4x4_perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: minus-one to one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

double4x4 double4x4_perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: zero to one
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0, 0.0, -1.0, 0.0
	};
}

double4x4 double4x4_perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: minus-one to one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, -far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, -1.0, 0.0
	};
}

double4x4 double4x4_lookat_lh( const double3* eye, const double3* target, const double3* up )
{
	// left handed
	const double3 eye_to_target = double3_comp_subv( target, eye );
	const double3 forward = double3_normalized( &eye_to_target );
	const double3 up_cross_forward = double3_cross( up, &forward );
	const double3 right = double3_normalized( &up_cross_forward );
	const double3 up1 = double3_cross( &forward, &right );

	return HLML_CONSTRUCT( double4x4 ) {
		right.x,   right.y,   right.z,   -double3_dot( &right, eye ),
		up1.x,     up1.y,     up1.z,     -double3_dot( &up1, eye ),
		forward.x, forward.y, forward.z, -double3_dot( &forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 double4x4_lookat_rh( const double3* eye, const double3* target, const double3* up )
{
	// right handed
	const double3 eye_to_target = double3_comp_subv( target, eye );
	const double3 forward = double3_normalized( &eye_to_target );
	const double3 forward_cross_up = double3_cross( &forward, up );
	const double3 right = double3_normalized( &forward_cross_up );
	const double3 up1 = double3_cross( &right, &forward );

	return HLML_CONSTRUCT( double4x4 ) {
		 right.x,    right.y,    right.z,   -double3_dot( &right, eye ),
		 up1.x,      up1.y,      up1.z,     -double3_dot( &up1, eye ),
		-forward.x, -forward.y, -forward.z,  double3_dot( &forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

#if defined( __GNUC__ ) || defined( __clang__ )
#pragma GCC diagnostic pop
#endif
#endif // HLML_IMPLEMENTATION

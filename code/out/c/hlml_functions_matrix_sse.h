/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#include <immintrin.h>

#include "hlml_functions_vector_sse.h"

/// \brief Changes the sign of the values in the register.
#define NEGATE_PS( reg ) _mm_sub_ps( HLML_ZERO_SSE, (reg) )

/// \brief Holds 2 x 2 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float2x2_sse_t
{
	__m128 m[2][2];
} float2x2_sse_t;

/// \brief Holds 2 x 3 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float2x3_sse_t
{
	__m128 m[2][3];
} float2x3_sse_t;

/// \brief Holds 2 x 4 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float2x4_sse_t
{
	__m128 m[2][4];
} float2x4_sse_t;

/// \brief Holds 3 x 2 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float3x2_sse_t
{
	__m128 m[3][2];
} float3x2_sse_t;

/// \brief Holds 3 x 3 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float3x3_sse_t
{
	__m128 m[3][3];
} float3x3_sse_t;

/// \brief Holds 3 x 4 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float3x4_sse_t
{
	__m128 m[3][4];
} float3x4_sse_t;

/// \brief Holds 4 x 2 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float4x2_sse_t
{
	__m128 m[4][2];
} float4x2_sse_t;

/// \brief Holds 4 x 3 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float4x3_sse_t
{
	__m128 m[4][3];
} float4x3_sse_t;

/// \brief Holds 4 x 4 __m128s where each regster is a vertical stream of that matrix component.
/// Basically, this struct holds 4 matrices.
typedef struct float4x4_sse_t
{
	__m128 m[4][4];
} float4x4_sse_t;


// float2x2
/// \relates float2x2_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float2x2_identity_sse( float2x2_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );
}

/// \relates float2x2_sse_t
/// \brief Stores a transposed matrix of 2 x 2 __m128 registers in the output given the input 2 x 2 register matrix.
inline static void float2x2_transpose_sse( const float2x2_sse_t* in, float2x2_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];
}

/// \relates float2x2_sse_t
/// \brief Stores the determinants of a matrix of 2 x 2 __m128 registers.
inline static void float2x2_determinant_sse( const float2x2_sse_t* in, __m128* out_result )
{
	assert( in );
	assert( out_result );

	__m128 mul0 = _mm_mul_ps( in->m[0][0], in->m[1][1] );
	__m128 mul1 = _mm_mul_ps( in->m[1][0], in->m[0][1] );

	*out_result = _mm_sub_ps( mul0, mul1 );
}

/// \relates float2x2_sse_t
/// \brief Stores an inverted matrix of 2 x 2 __m128 registers.
inline static void float2x2_inverse_sse( const float2x2_sse_t* in, float2x2_sse_t* out )
{
	assert( in );
	assert( out );

	__m128 determinants;
	float2x2_determinant_sse( in, &determinants );

	determinants = _mm_rcp_ps( determinants );

	__m128 neg0 = NEGATE_PS( in->m[0][1] );
	__m128 neg1 = NEGATE_PS( in->m[1][0] );

	out->m[0][0] = _mm_mul_ps( in->m[1][1], determinants );
	out->m[0][1] = _mm_mul_ps( neg0, determinants );
	out->m[1][0] = _mm_mul_ps( neg1, determinants );
	out->m[1][1] = _mm_mul_ps( in->m[0][0], determinants );
}

/// \relates float2x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float2x2_comp_addm_sse( const float2x2_sse_t* lhs, const float2x2_sse_t* rhs, float2x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );
}

/// \relates float2x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float2x2_comp_subm_sse( const float2x2_sse_t* lhs, const float2x2_sse_t* rhs, float2x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );
}

/// \relates float2x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float2x2_comp_mulm_sse( const float2x2_sse_t* lhs, const float2x2_sse_t* rhs, float2x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );
}

/// \relates float2x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float2x2_comp_divm_sse( const float2x2_sse_t* lhs, const float2x2_sse_t* rhs, float2x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );
}

/// \relates float2x2
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float2x2_mulm_sse( const float2x2_sse_t* lhs, const float2x2_sse_t* rhs, float2x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float2_sse_t dot_lhs;
	float2_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );
}


// float2x3
/// \relates float2x3_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float2x3_identity_sse( float2x3_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );
	mat->m[0][2] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );
	mat->m[1][2] = _mm_set1_ps( 0.0f );
}

/// \relates float2x3_sse_t
/// \brief Stores a transposed matrix of 3 x 2 __m128 registers in the output given the input 2 x 3 register matrix.
inline static void float2x3_transpose_sse( const float2x3_sse_t* in, float3x2_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];
	out->m[2][0] = in->m[0][2];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];
	out->m[2][1] = in->m[1][2];
}

/// \relates float2x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float2x3_comp_addm_sse( const float2x3_sse_t* lhs, const float2x3_sse_t* rhs, float2x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_add_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_add_ps( lhs->m[1][2], rhs->m[1][2] );
}

/// \relates float2x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float2x3_comp_subm_sse( const float2x3_sse_t* lhs, const float2x3_sse_t* rhs, float2x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_sub_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_sub_ps( lhs->m[1][2], rhs->m[1][2] );
}

/// \relates float2x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float2x3_comp_mulm_sse( const float2x3_sse_t* lhs, const float2x3_sse_t* rhs, float2x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_mul_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_mul_ps( lhs->m[1][2], rhs->m[1][2] );
}

/// \relates float2x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float2x3_comp_divm_sse( const float2x3_sse_t* lhs, const float2x3_sse_t* rhs, float2x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_div_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_div_ps( lhs->m[1][2], rhs->m[1][2] );
}

/// \relates float2x3
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float2x3_mulm_sse( const float2x3_sse_t* lhs, const float3x2_sse_t* rhs, float2x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float3_sse_t dot_lhs;
	float3_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );
}


// float2x4
/// \relates float2x4_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float2x4_identity_sse( float2x4_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );
	mat->m[0][2] = _mm_set1_ps( 0.0f );
	mat->m[0][3] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );
	mat->m[1][2] = _mm_set1_ps( 0.0f );
	mat->m[1][3] = _mm_set1_ps( 0.0f );
}

/// \relates float2x4_sse_t
/// \brief Stores a transposed matrix of 4 x 2 __m128 registers in the output given the input 2 x 4 register matrix.
inline static void float2x4_transpose_sse( const float2x4_sse_t* in, float4x2_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];
	out->m[2][0] = in->m[0][2];
	out->m[3][0] = in->m[0][3];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];
	out->m[2][1] = in->m[1][2];
	out->m[3][1] = in->m[1][3];
}

/// \relates float2x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float2x4_comp_addm_sse( const float2x4_sse_t* lhs, const float2x4_sse_t* rhs, float2x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_add_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_add_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_add_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_add_ps( lhs->m[1][3], rhs->m[1][3] );
}

/// \relates float2x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float2x4_comp_subm_sse( const float2x4_sse_t* lhs, const float2x4_sse_t* rhs, float2x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_sub_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_sub_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_sub_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_sub_ps( lhs->m[1][3], rhs->m[1][3] );
}

/// \relates float2x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float2x4_comp_mulm_sse( const float2x4_sse_t* lhs, const float2x4_sse_t* rhs, float2x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_mul_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_mul_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_mul_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_mul_ps( lhs->m[1][3], rhs->m[1][3] );
}

/// \relates float2x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float2x4_comp_divm_sse( const float2x4_sse_t* lhs, const float2x4_sse_t* rhs, float2x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_div_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_div_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_div_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_div_ps( lhs->m[1][3], rhs->m[1][3] );
}

/// \relates float2x4
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float2x4_mulm_sse( const float2x4_sse_t* lhs, const float4x2_sse_t* rhs, float2x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float4_sse_t dot_lhs;
	float4_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );
}


// float3x2
/// \relates float3x2_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float3x2_identity_sse( float3x2_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );

	// row 2
	mat->m[2][0] = _mm_set1_ps( 0.0f );
	mat->m[2][1] = _mm_set1_ps( 0.0f );
}

/// \relates float3x2_sse_t
/// \brief Stores a transposed matrix of 2 x 3 __m128 registers in the output given the input 3 x 2 register matrix.
inline static void float3x2_transpose_sse( const float3x2_sse_t* in, float2x3_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];

	out->m[0][2] = in->m[2][0];
	out->m[1][2] = in->m[2][1];
}

/// \relates float3x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float3x2_comp_addm_sse( const float3x2_sse_t* lhs, const float3x2_sse_t* rhs, float3x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_add_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_add_ps( lhs->m[2][1], rhs->m[2][1] );
}

/// \relates float3x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float3x2_comp_subm_sse( const float3x2_sse_t* lhs, const float3x2_sse_t* rhs, float3x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_sub_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_sub_ps( lhs->m[2][1], rhs->m[2][1] );
}

/// \relates float3x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float3x2_comp_mulm_sse( const float3x2_sse_t* lhs, const float3x2_sse_t* rhs, float3x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_mul_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_mul_ps( lhs->m[2][1], rhs->m[2][1] );
}

/// \relates float3x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float3x2_comp_divm_sse( const float3x2_sse_t* lhs, const float3x2_sse_t* rhs, float3x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_div_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_div_ps( lhs->m[2][1], rhs->m[2][1] );
}

/// \relates float3x2
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float3x2_mulm_sse( const float3x2_sse_t* lhs, const float2x3_sse_t* rhs, float3x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float2_sse_t dot_lhs;
	float2_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][2] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][2] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][0] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][1] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][2] );
}


// float3x3
/// \relates float3x3_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float3x3_identity_sse( float3x3_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );
	mat->m[0][2] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );
	mat->m[1][2] = _mm_set1_ps( 0.0f );

	// row 2
	mat->m[2][0] = _mm_set1_ps( 0.0f );
	mat->m[2][1] = _mm_set1_ps( 0.0f );
	mat->m[2][2] = _mm_set1_ps( 1.0f );
}

/// \relates float3x3_sse_t
/// \brief Stores a transposed matrix of 3 x 3 __m128 registers in the output given the input 3 x 3 register matrix.
inline static void float3x3_transpose_sse( const float3x3_sse_t* in, float3x3_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];
	out->m[2][0] = in->m[0][2];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];
	out->m[2][1] = in->m[1][2];

	out->m[0][2] = in->m[2][0];
	out->m[1][2] = in->m[2][1];
	out->m[2][2] = in->m[2][2];
}

/// \relates float3x3_sse_t
/// \brief Stores the determinants of a matrix of 3 x 3 __m128 registers.
inline static void float3x3_determinant_sse( const float3x3_sse_t* in, __m128* out_result )
{
	assert( in );
	assert( out_result );

	__m128 mul0a = _mm_mul_ps( in->m[1][1], in->m[2][2] );
	__m128 mul0b = _mm_mul_ps( in->m[2][1], in->m[1][2] );
	__m128 sub0  = _mm_sub_ps( mul0a, mul0b );

	__m128 mul1a = _mm_mul_ps( in->m[1][0], in->m[2][2] );
	__m128 mul1b = _mm_mul_ps( in->m[2][0], in->m[1][2] );
	__m128 sub1  = _mm_sub_ps( mul1a, mul1b );

	__m128 mul2a = _mm_mul_ps( in->m[1][0], in->m[2][1] );
	__m128 mul2b = _mm_mul_ps( in->m[2][0], in->m[1][1] );
	__m128 sub2  = _mm_sub_ps( mul2a, mul2b );

	__m128 mul0  = _mm_mul_ps( in->m[0][0], sub0 );
	__m128 mul1  = _mm_mul_ps( in->m[0][1], sub1 );
	__m128 mul2  = _mm_mul_ps( in->m[0][2], sub2 );

	__m128 add0  = _mm_sub_ps( mul0, mul1 );

	*out_result = _mm_add_ps( add0, mul2 );
}

/// \relates float3x3_sse_t
/// \brief Stores an inverted matrix of 3 x 3 __m128 registers.
inline static void float3x3_inverse_sse( const float3x3_sse_t* in, float3x3_sse_t* out )
{
	assert( in );
	assert( out );

	__m128 determinants;
	float3x3_determinant_sse( in, &determinants );

	determinants = _mm_rcp_ps( determinants );

	// row 0
	__m128 mul00a = _mm_mul_ps( in->m[1][1], in->m[2][2] );
	__m128 mul00b = _mm_mul_ps( in->m[1][2], in->m[2][1] );
	__m128 mul01a = _mm_mul_ps( in->m[0][1], in->m[2][2] );
	__m128 mul01b = _mm_mul_ps( in->m[0][2], in->m[2][1] );
	__m128 mul02a = _mm_mul_ps( in->m[0][1], in->m[1][2] );
	__m128 mul02b = _mm_mul_ps( in->m[0][2], in->m[1][1] );

	__m128 sub00 = _mm_sub_ps( mul00a, mul00b );
	__m128 sub01 = _mm_sub_ps( mul01a, mul01b );
	__m128 sub02 = _mm_sub_ps( mul02a, mul02b );

	sub00 = _mm_mul_ps( sub00, determinants );
	sub01 = _mm_mul_ps( sub01, determinants );
	sub02 = _mm_mul_ps( sub02, determinants );
	sub01 = NEGATE_PS( sub01 );

	// row 1
	__m128 mul10a = _mm_mul_ps( in->m[1][0], in->m[2][2] );
	__m128 mul10b = _mm_mul_ps( in->m[1][2], in->m[2][0] );
	__m128 mul11a = _mm_mul_ps( in->m[0][0], in->m[2][2] );
	__m128 mul11b = _mm_mul_ps( in->m[0][2], in->m[2][0] );
	__m128 mul12a = _mm_mul_ps( in->m[0][0], in->m[1][2] );
	__m128 mul12b = _mm_mul_ps( in->m[0][2], in->m[1][0] );

	__m128 sub10 = _mm_sub_ps( mul10a, mul10b );
	__m128 sub11 = _mm_sub_ps( mul11a, mul11b );
	__m128 sub12 = _mm_sub_ps( mul12a, mul12b );

	sub10 = _mm_mul_ps( sub10, determinants );
	sub11 = _mm_mul_ps( sub11, determinants );
	sub12 = _mm_mul_ps( sub12, determinants );
	sub10 = NEGATE_PS( sub10 );
	sub12 = NEGATE_PS( sub12 );

	// row 2
	__m128 mul20a = _mm_mul_ps( in->m[1][0], in->m[2][1] );
	__m128 mul20b = _mm_mul_ps( in->m[1][1], in->m[2][0] );
	__m128 mul21a = _mm_mul_ps( in->m[0][0], in->m[2][1] );
	__m128 mul21b = _mm_mul_ps( in->m[0][1], in->m[2][0] );
	__m128 mul22a = _mm_mul_ps( in->m[0][0], in->m[1][1] );
	__m128 mul22b = _mm_mul_ps( in->m[0][1], in->m[1][0] );

	__m128 sub20 = _mm_sub_ps( mul20a, mul20b );
	__m128 sub21 = _mm_sub_ps( mul21a, mul21b );
	__m128 sub22 = _mm_sub_ps( mul22a, mul22b );

	sub20 = _mm_mul_ps( sub20, determinants );
	sub21 = _mm_mul_ps( sub21, determinants );
	sub22 = _mm_mul_ps( sub22, determinants );
	sub21 = NEGATE_PS( sub21 );

	out->m[0][0] = sub00;
	out->m[0][1] = sub01;
	out->m[0][2] = sub02;

	out->m[1][0] = sub10;
	out->m[1][1] = sub11;
	out->m[1][2] = sub12;

	out->m[2][0] = sub20;
	out->m[2][1] = sub21;
	out->m[2][2] = sub22;
}

/// \relates float3x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float3x3_comp_addm_sse( const float3x3_sse_t* lhs, const float3x3_sse_t* rhs, float3x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_add_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_add_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_add_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_add_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_add_ps( lhs->m[2][2], rhs->m[2][2] );
}

/// \relates float3x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float3x3_comp_subm_sse( const float3x3_sse_t* lhs, const float3x3_sse_t* rhs, float3x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_sub_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_sub_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_sub_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_sub_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_sub_ps( lhs->m[2][2], rhs->m[2][2] );
}

/// \relates float3x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float3x3_comp_mulm_sse( const float3x3_sse_t* lhs, const float3x3_sse_t* rhs, float3x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_mul_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_mul_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_mul_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_mul_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_mul_ps( lhs->m[2][2], rhs->m[2][2] );
}

/// \relates float3x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float3x3_comp_divm_sse( const float3x3_sse_t* lhs, const float3x3_sse_t* rhs, float3x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_div_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_div_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_div_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_div_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_div_ps( lhs->m[2][2], rhs->m[2][2] );
}

/// \relates float3x3
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float3x3_mulm_sse( const float3x3_sse_t* lhs, const float3x3_sse_t* rhs, float3x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float3_sse_t dot_lhs;
	float3_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][2] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][2] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][0] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][1] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][2] );
}

/// \relates float3x3_sse_t
/// \brief Stores a last matrix column that has been translated by the given __m128 register vector in the input.
inline static void float3x3_translate_sse( const float2_sse_t* column, const float2_sse_t* vec, float2_sse_t* out_column )
{
	assert( column );
	assert( vec );
	assert( out_column );

	out_column->x = _mm_add_ps( column->x, vec->x );
	out_column->y = _mm_add_ps( column->y, vec->y );
}

/// \relates float3x3_sse_t
/// \brief Stores an array of float3x3_sse_t diagonals that have been scaled by the given vector in the input.
inline static void float3x3_scale_sse( const float2_sse_t* diagonal, const float2_sse_t* scale, float2_sse_t* out_diagonal )
{
	assert( diagonal );
	assert( scale );
	assert( out_diagonal );

	out_diagonal->x = _mm_mul_ps( diagonal->x, scale->x );
	out_diagonal->y = _mm_mul_ps( diagonal->y, scale->y );
}


// float3x4
/// \relates float3x4_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float3x4_identity_sse( float3x4_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );
	mat->m[0][2] = _mm_set1_ps( 0.0f );
	mat->m[0][3] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );
	mat->m[1][2] = _mm_set1_ps( 0.0f );
	mat->m[1][3] = _mm_set1_ps( 0.0f );

	// row 2
	mat->m[2][0] = _mm_set1_ps( 0.0f );
	mat->m[2][1] = _mm_set1_ps( 0.0f );
	mat->m[2][2] = _mm_set1_ps( 1.0f );
	mat->m[2][3] = _mm_set1_ps( 0.0f );
}

/// \relates float3x4_sse_t
/// \brief Stores a transposed matrix of 4 x 3 __m128 registers in the output given the input 3 x 4 register matrix.
inline static void float3x4_transpose_sse( const float3x4_sse_t* in, float4x3_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];
	out->m[2][0] = in->m[0][2];
	out->m[3][0] = in->m[0][3];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];
	out->m[2][1] = in->m[1][2];
	out->m[3][1] = in->m[1][3];

	out->m[0][2] = in->m[2][0];
	out->m[1][2] = in->m[2][1];
	out->m[2][2] = in->m[2][2];
	out->m[3][2] = in->m[2][3];
}

/// \relates float3x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float3x4_comp_addm_sse( const float3x4_sse_t* lhs, const float3x4_sse_t* rhs, float3x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_add_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_add_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_add_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_add_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_add_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_add_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_add_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_add_ps( lhs->m[2][3], rhs->m[2][3] );
}

/// \relates float3x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float3x4_comp_subm_sse( const float3x4_sse_t* lhs, const float3x4_sse_t* rhs, float3x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_sub_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_sub_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_sub_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_sub_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_sub_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_sub_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_sub_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_sub_ps( lhs->m[2][3], rhs->m[2][3] );
}

/// \relates float3x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float3x4_comp_mulm_sse( const float3x4_sse_t* lhs, const float3x4_sse_t* rhs, float3x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_mul_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_mul_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_mul_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_mul_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_mul_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_mul_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_mul_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_mul_ps( lhs->m[2][3], rhs->m[2][3] );
}

/// \relates float3x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float3x4_comp_divm_sse( const float3x4_sse_t* lhs, const float3x4_sse_t* rhs, float3x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_div_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_div_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_div_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_div_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_div_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_div_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_div_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_div_ps( lhs->m[2][3], rhs->m[2][3] );
}

/// \relates float3x4
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float3x4_mulm_sse( const float3x4_sse_t* lhs, const float4x3_sse_t* rhs, float3x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float4_sse_t dot_lhs;
	float4_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];
	dot_rhs.w = rhs->m[3][2];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][2] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];
	dot_rhs.w = rhs->m[3][2];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][2] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];
	dot_lhs.w = lhs->m[2][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][0] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];
	dot_lhs.w = lhs->m[2][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][1] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];
	dot_lhs.w = lhs->m[2][3];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];
	dot_rhs.w = rhs->m[3][2];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][2] );
}


// float4x2
/// \relates float4x2_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float4x2_identity_sse( float4x2_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );

	// row 2
	mat->m[2][0] = _mm_set1_ps( 0.0f );
	mat->m[2][1] = _mm_set1_ps( 0.0f );

	// row 3
	mat->m[3][0] = _mm_set1_ps( 0.0f );
	mat->m[3][1] = _mm_set1_ps( 0.0f );
}

/// \relates float4x2_sse_t
/// \brief Stores a transposed matrix of 2 x 4 __m128 registers in the output given the input 4 x 2 register matrix.
inline static void float4x2_transpose_sse( const float4x2_sse_t* in, float2x4_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];

	out->m[0][2] = in->m[2][0];
	out->m[1][2] = in->m[2][1];

	out->m[0][3] = in->m[3][0];
	out->m[1][3] = in->m[3][1];
}

/// \relates float4x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float4x2_comp_addm_sse( const float4x2_sse_t* lhs, const float4x2_sse_t* rhs, float4x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_add_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_add_ps( lhs->m[2][1], rhs->m[2][1] );

	// row 3
	out->m[3][0] = _mm_add_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_add_ps( lhs->m[3][1], rhs->m[3][1] );
}

/// \relates float4x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float4x2_comp_subm_sse( const float4x2_sse_t* lhs, const float4x2_sse_t* rhs, float4x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_sub_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_sub_ps( lhs->m[2][1], rhs->m[2][1] );

	// row 3
	out->m[3][0] = _mm_sub_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_sub_ps( lhs->m[3][1], rhs->m[3][1] );
}

/// \relates float4x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float4x2_comp_mulm_sse( const float4x2_sse_t* lhs, const float4x2_sse_t* rhs, float4x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_mul_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_mul_ps( lhs->m[2][1], rhs->m[2][1] );

	// row 3
	out->m[3][0] = _mm_mul_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_mul_ps( lhs->m[3][1], rhs->m[3][1] );
}

/// \relates float4x2_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float4x2_comp_divm_sse( const float4x2_sse_t* lhs, const float4x2_sse_t* rhs, float4x2_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );

	// row 2
	out->m[2][0] = _mm_div_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_div_ps( lhs->m[2][1], rhs->m[2][1] );

	// row 3
	out->m[3][0] = _mm_div_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_div_ps( lhs->m[3][1], rhs->m[3][1] );
}

/// \relates float4x2
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float4x2_mulm_sse( const float4x2_sse_t* lhs, const float2x4_sse_t* rhs, float4x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float2_sse_t dot_lhs;
	float2_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][2] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][3] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][2] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][3] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][0] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][1] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][2] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][3] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][0] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][1] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][2] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];

	float2_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][3] );
}


// float4x3
/// \relates float4x3_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float4x3_identity_sse( float4x3_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );
	mat->m[0][2] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );
	mat->m[1][2] = _mm_set1_ps( 0.0f );

	// row 2
	mat->m[2][0] = _mm_set1_ps( 0.0f );
	mat->m[2][1] = _mm_set1_ps( 0.0f );
	mat->m[2][2] = _mm_set1_ps( 1.0f );

	// row 3
	mat->m[3][0] = _mm_set1_ps( 0.0f );
	mat->m[3][1] = _mm_set1_ps( 0.0f );
	mat->m[3][2] = _mm_set1_ps( 0.0f );
}

/// \relates float4x3_sse_t
/// \brief Stores a transposed matrix of 3 x 4 __m128 registers in the output given the input 4 x 3 register matrix.
inline static void float4x3_transpose_sse( const float4x3_sse_t* in, float3x4_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];
	out->m[2][0] = in->m[0][2];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];
	out->m[2][1] = in->m[1][2];

	out->m[0][2] = in->m[2][0];
	out->m[1][2] = in->m[2][1];
	out->m[2][2] = in->m[2][2];

	out->m[0][3] = in->m[3][0];
	out->m[1][3] = in->m[3][1];
	out->m[2][3] = in->m[3][2];
}

/// \relates float4x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float4x3_comp_addm_sse( const float4x3_sse_t* lhs, const float4x3_sse_t* rhs, float4x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_add_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_add_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_add_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_add_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_add_ps( lhs->m[2][2], rhs->m[2][2] );

	// row 3
	out->m[3][0] = _mm_add_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_add_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_add_ps( lhs->m[3][2], rhs->m[3][2] );
}

/// \relates float4x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float4x3_comp_subm_sse( const float4x3_sse_t* lhs, const float4x3_sse_t* rhs, float4x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_sub_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_sub_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_sub_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_sub_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_sub_ps( lhs->m[2][2], rhs->m[2][2] );

	// row 3
	out->m[3][0] = _mm_sub_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_sub_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_sub_ps( lhs->m[3][2], rhs->m[3][2] );
}

/// \relates float4x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float4x3_comp_mulm_sse( const float4x3_sse_t* lhs, const float4x3_sse_t* rhs, float4x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_mul_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_mul_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_mul_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_mul_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_mul_ps( lhs->m[2][2], rhs->m[2][2] );

	// row 3
	out->m[3][0] = _mm_mul_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_mul_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_mul_ps( lhs->m[3][2], rhs->m[3][2] );
}

/// \relates float4x3_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float4x3_comp_divm_sse( const float4x3_sse_t* lhs, const float4x3_sse_t* rhs, float4x3_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_div_ps( lhs->m[0][2], rhs->m[0][2] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_div_ps( lhs->m[1][2], rhs->m[1][2] );

	// row 2
	out->m[2][0] = _mm_div_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_div_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_div_ps( lhs->m[2][2], rhs->m[2][2] );

	// row 3
	out->m[3][0] = _mm_div_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_div_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_div_ps( lhs->m[3][2], rhs->m[3][2] );
}

/// \relates float4x3
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float4x3_mulm_sse( const float4x3_sse_t* lhs, const float3x4_sse_t* rhs, float4x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float3_sse_t dot_lhs;
	float3_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][2] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][3] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][2] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][3] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][0] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][1] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][2] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][3] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][0] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][1] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][2] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];

	float3_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][3] );
}


// float4x4
/// \relates float4x4_sse_t
/// \brief Sets a matrix of __m128 registers to identity.
inline static void float4x4_identity_sse( float4x4_sse_t* mat )
{
	// row 0
	mat->m[0][0] = _mm_set1_ps( 1.0f );
	mat->m[0][1] = _mm_set1_ps( 0.0f );
	mat->m[0][2] = _mm_set1_ps( 0.0f );
	mat->m[0][3] = _mm_set1_ps( 0.0f );

	// row 1
	mat->m[1][0] = _mm_set1_ps( 0.0f );
	mat->m[1][1] = _mm_set1_ps( 1.0f );
	mat->m[1][2] = _mm_set1_ps( 0.0f );
	mat->m[1][3] = _mm_set1_ps( 0.0f );

	// row 2
	mat->m[2][0] = _mm_set1_ps( 0.0f );
	mat->m[2][1] = _mm_set1_ps( 0.0f );
	mat->m[2][2] = _mm_set1_ps( 1.0f );
	mat->m[2][3] = _mm_set1_ps( 0.0f );

	// row 3
	mat->m[3][0] = _mm_set1_ps( 0.0f );
	mat->m[3][1] = _mm_set1_ps( 0.0f );
	mat->m[3][2] = _mm_set1_ps( 0.0f );
	mat->m[3][3] = _mm_set1_ps( 1.0f );
}

/// \relates float4x4_sse_t
/// \brief Stores a transposed matrix of 4 x 4 __m128 registers in the output given the input 4 x 4 register matrix.
inline static void float4x4_transpose_sse( const float4x4_sse_t* in, float4x4_sse_t* out )
{
	assert( in );
	assert( out );

	out->m[0][0] = in->m[0][0];
	out->m[1][0] = in->m[0][1];
	out->m[2][0] = in->m[0][2];
	out->m[3][0] = in->m[0][3];

	out->m[0][1] = in->m[1][0];
	out->m[1][1] = in->m[1][1];
	out->m[2][1] = in->m[1][2];
	out->m[3][1] = in->m[1][3];

	out->m[0][2] = in->m[2][0];
	out->m[1][2] = in->m[2][1];
	out->m[2][2] = in->m[2][2];
	out->m[3][2] = in->m[2][3];

	out->m[0][3] = in->m[3][0];
	out->m[1][3] = in->m[3][1];
	out->m[2][3] = in->m[3][2];
	out->m[3][3] = in->m[3][3];
}

/// \relates float4x4_sse_t
/// \brief Stores the determinants of a matrix of 4 x 4 __m128 registers.
inline static void float4x4_determinant_sse( const float4x4_sse_t* in, __m128* out_result )
{
	assert( in );
	assert( out_result );

	__m128 submul0a      = _mm_mul_ps( in->m[2][2], in->m[3][3] );
	__m128 submul0b      = _mm_mul_ps( in->m[3][2], in->m[2][3] );
	__m128 sub0          = _mm_sub_ps( submul0a, submul0b );

	__m128 submul1a      = _mm_mul_ps( in->m[2][1], in->m[3][3] );
	__m128 submul1b      = _mm_mul_ps( in->m[2][3], in->m[3][1] );
	__m128 sub1          = _mm_sub_ps( submul1a, submul1b );

	__m128 submul2a      = _mm_mul_ps( in->m[2][1], in->m[3][2] );
	__m128 submul2b      = _mm_mul_ps( in->m[3][1], in->m[2][2] );
	__m128 sub2          = _mm_sub_ps( submul2a, submul2b );

	__m128 submul3a      = _mm_mul_ps( in->m[2][0], in->m[3][3] );
	__m128 submul3b      = _mm_mul_ps( in->m[3][0], in->m[2][3] );
	__m128 sub3          = _mm_sub_ps( submul3a, submul3b );

	__m128 submul4a      = _mm_mul_ps( in->m[2][0], in->m[3][2] );
	__m128 submul4b      = _mm_mul_ps( in->m[3][0], in->m[2][2] );
	__m128 sub4          = _mm_sub_ps( submul4a, submul4b );

	__m128 submul5a      = _mm_mul_ps( in->m[2][0], in->m[3][1] );
	__m128 submul5b      = _mm_mul_ps( in->m[3][0], in->m[2][1] );
	__m128 sub5          = _mm_sub_ps( submul5a, submul5b );

	__m128 cofactor0mul0 = _mm_mul_ps( in->m[1][1], sub0 );
	__m128 cofactor0mul1 = _mm_mul_ps( in->m[1][2], sub1 );
	__m128 cofactor0mul2 = _mm_mul_ps( in->m[1][3], sub2 );
	__m128 cofactor0sub  = _mm_sub_ps( cofactor0mul0, cofactor0mul1 );
	__m128 cofactor0     = _mm_add_ps( cofactor0sub, cofactor0mul2 );

	__m128 cofactor1mul0 = _mm_mul_ps( in->m[1][0], sub0 );
	__m128 cofactor1mul1 = _mm_mul_ps( in->m[1][2], sub3 );
	__m128 cofactor1mul2 = _mm_mul_ps( in->m[1][3], sub4 );
	__m128 cofactor1sub  = _mm_sub_ps( cofactor1mul0, cofactor1mul1 );
	__m128 cofactor1     = _mm_add_ps( cofactor1sub, cofactor1mul2 );
	cofactor1 = NEGATE_PS( cofactor1 );

	__m128 cofactor2mul0 = _mm_mul_ps( in->m[1][0], sub1 );
	__m128 cofactor2mul1 = _mm_mul_ps( in->m[1][1], sub3 );
	__m128 cofactor2mul2 = _mm_mul_ps( in->m[1][3], sub5 );
	__m128 cofactor2sub  = _mm_sub_ps( cofactor2mul0, cofactor2mul1 );
	__m128 cofactor2     = _mm_add_ps( cofactor2sub, cofactor2mul2 );

	__m128 cofactor3mul0 = _mm_mul_ps( in->m[1][0], sub2 );
	__m128 cofactor3mul1 = _mm_mul_ps( in->m[1][1], sub4 );
	__m128 cofactor3mul2 = _mm_mul_ps( in->m[1][2], sub5 );
	__m128 cofactor3sub  = _mm_sub_ps( cofactor3mul0, cofactor3mul1 );
	__m128 cofactor3     = _mm_add_ps( cofactor3sub, cofactor3mul2 );
	cofactor3 = NEGATE_PS( cofactor3 );

	__m128 finalmul0     = _mm_mul_ps( in->m[0][0], cofactor0 );
	__m128 finalmul1     = _mm_mul_ps( in->m[0][1], cofactor1 );
	__m128 finalmul2     = _mm_mul_ps( in->m[0][2], cofactor2 );
	__m128 finalmul3     = _mm_mul_ps( in->m[0][3], cofactor3 );

	__m128 final0        = _mm_add_ps( finalmul0, finalmul1 );
	__m128 final1        = _mm_add_ps( finalmul2, finalmul3 );

	*out_result = _mm_add_ps( final0, final1 );
}

/// \relates float4x4_sse_t
/// \brief Stores an inverted matrix of 4 x 4 __m128 registers.
inline static void float4x4_inverse_sse( const float4x4_sse_t* in, float4x4_sse_t* out )
{
	assert( in );
	assert( out );

	// DM: doesn't need to be as complex as the scalar implementation
	// based off: https://github.com/datenwolf/linmath.h/blob/master/linmath.h

	__m128 sub00mula    = _mm_mul_ps( in->m[0][0], in->m[1][1] );
	__m128 sub00mulb    = _mm_mul_ps( in->m[1][0], in->m[0][1] );
	__m128 sub00        = _mm_sub_ps( sub00mula, sub00mulb );

	__m128 sub01mula    = _mm_mul_ps( in->m[0][0], in->m[1][2] );
	__m128 sub01mulb    = _mm_mul_ps( in->m[1][0], in->m[0][2] );
	__m128 sub01        = _mm_sub_ps( sub01mula, sub01mulb );

	__m128 sub02mula    = _mm_mul_ps( in->m[0][0], in->m[1][3] );
	__m128 sub02mulb    = _mm_mul_ps( in->m[1][0], in->m[0][3] );
	__m128 sub02        = _mm_sub_ps( sub02mula, sub02mulb );

	__m128 sub03mula    = _mm_mul_ps( in->m[0][1], in->m[1][2] );
	__m128 sub03mulb    = _mm_mul_ps( in->m[1][1], in->m[0][2] );
	__m128 sub03        = _mm_sub_ps( sub03mula, sub03mulb );

	__m128 sub04mula    = _mm_mul_ps( in->m[0][1], in->m[1][3] );
	__m128 sub04mulb    = _mm_mul_ps( in->m[1][1], in->m[0][3] );
	__m128 sub04        = _mm_sub_ps( sub04mula, sub04mulb );

	__m128 sub05mula    = _mm_mul_ps( in->m[0][2], in->m[1][3] );
	__m128 sub05mulb    = _mm_mul_ps( in->m[1][2], in->m[0][3] );
	__m128 sub05        = _mm_sub_ps( sub05mula, sub05mulb );

	__m128 cof00mula    = _mm_mul_ps( in->m[2][0], in->m[3][1] );
	__m128 cof00mulb    = _mm_mul_ps( in->m[3][0], in->m[2][1] );
	__m128 cof00        = _mm_sub_ps( cof00mula, cof00mulb );

	__m128 cof01mula    = _mm_mul_ps( in->m[2][0], in->m[3][2] );
	__m128 cof01mulb    = _mm_mul_ps( in->m[3][0], in->m[2][2] );
	__m128 cof01        = _mm_sub_ps( cof01mula, cof01mulb );

	__m128 cof02mula    = _mm_mul_ps( in->m[2][0], in->m[3][3] );
	__m128 cof02mulb    = _mm_mul_ps( in->m[3][0], in->m[2][3] );
	__m128 cof02        = _mm_sub_ps( cof02mula, cof02mulb );

	__m128 cof03mula    = _mm_mul_ps( in->m[2][1], in->m[3][2] );
	__m128 cof03mulb    = _mm_mul_ps( in->m[3][1], in->m[2][2] );
	__m128 cof03        = _mm_sub_ps( cof03mula, cof03mulb );

	__m128 cof04mula    = _mm_mul_ps( in->m[2][1], in->m[3][3] );
	__m128 cof04mulb    = _mm_mul_ps( in->m[3][1], in->m[2][3] );
	__m128 cof04        = _mm_sub_ps( cof04mula, cof04mulb );

	__m128 cof05mula    = _mm_mul_ps( in->m[2][2], in->m[3][3] );
	__m128 cof05mulb    = _mm_mul_ps( in->m[3][2], in->m[2][3] );
	__m128 cof05        = _mm_sub_ps( cof05mula, cof05mulb );

	__m128 detsubmul0   = _mm_mul_ps( sub00, cof05 );
	__m128 detsubmul1   = NEGATE_PS( _mm_mul_ps( sub01, cof04 ) );
	__m128 detsubmul2   = _mm_mul_ps( sub02, cof03 );
	__m128 detsubmul3   = _mm_mul_ps( sub03, cof02 );
	__m128 detsubmul4   = NEGATE_PS( _mm_mul_ps( sub04, cof01 ) );
	__m128 detsubmul5   = _mm_mul_ps( sub05, cof00 );

	__m128 detadd0      = _mm_add_ps( detsubmul0, detsubmul1 );
	__m128 detadd1      = _mm_add_ps( detsubmul2, detsubmul3 );
	__m128 detadd2      = _mm_add_ps( detsubmul4, detsubmul5 );

	__m128 detadd3      = _mm_add_ps( detadd0, detadd1 );
	__m128 det          = _mm_add_ps( detadd2, detadd3 );

	__m128 invdet       = _mm_rcp_ps( det );

	__m128 out00submula = _mm_mul_ps( in->m[1][1], cof05 );
	__m128 out00submulb = _mm_mul_ps( in->m[1][2], cof04 );
	__m128 out00submulc = _mm_mul_ps( in->m[1][3], cof03 );
	__m128 out00subsub  = _mm_sub_ps( out00submula, out00submulb );
	__m128 out00subadd  = _mm_add_ps( out00subsub, out00submulc );
	out->m[0][0] = _mm_mul_ps( out00subadd, invdet );

	__m128 out01submula = _mm_mul_ps( NEGATE_PS( in->m[0][1] ), cof05 );
	__m128 out01submulb = _mm_mul_ps( in->m[0][2], cof04 );
	__m128 out01submulc = _mm_mul_ps( in->m[0][3], cof03 );
	__m128 out01subadd  = _mm_add_ps( out01submula, out01submulb );
	__m128 out01subsub  = _mm_sub_ps( out01subadd, out01submulc );
	out->m[0][1] = _mm_mul_ps( out01subsub, invdet );

	__m128 out02submula = _mm_mul_ps( in->m[3][1], sub05 );
	__m128 out02submulb = _mm_mul_ps( in->m[3][2], sub04 );
	__m128 out02submulc = _mm_mul_ps( in->m[3][3], sub03 );
	__m128 out02subsub  = _mm_sub_ps( out02submula, out02submulb );
	__m128 out02subadd  = _mm_add_ps( out02subsub, out02submulc );
	out->m[0][2] = _mm_mul_ps( out02subadd, invdet );

	__m128 out03submula = _mm_mul_ps( NEGATE_PS( in->m[2][1] ), sub05 );
	__m128 out03submulb = _mm_mul_ps( in->m[2][2], sub04 );
	__m128 out03submulc = _mm_mul_ps( in->m[2][3], sub03 );
	__m128 out03subadd  = _mm_add_ps( out03submula, out03submulb );
	__m128 out03subsub  = _mm_sub_ps( out03subadd, out03submulc );
	out->m[0][3] = _mm_mul_ps( out03subsub, invdet );

	__m128 out10submula = _mm_mul_ps( NEGATE_PS( in->m[1][0] ), cof05 );
	__m128 out10submulb = _mm_mul_ps( in->m[1][2], cof02 );
	__m128 out10submulc = _mm_mul_ps( in->m[1][3], cof01 );
	__m128 out10subadd  = _mm_add_ps( out10submula, out10submulb );
	__m128 out10subsub  = _mm_sub_ps( out10subadd, out10submulc );
	out->m[1][0] = _mm_mul_ps( out10subsub, invdet );

	__m128 out11submula = _mm_mul_ps( in->m[0][0], cof05 );
	__m128 out11submulb = _mm_mul_ps( in->m[0][2], cof02 );
	__m128 out11submulc = _mm_mul_ps( in->m[0][3], cof01 );
	__m128 out11subsub  = _mm_sub_ps( out11submula, out11submulb );
	__m128 out11subadd  = _mm_add_ps( out11subsub, out11submulc );
	out->m[1][1] = _mm_mul_ps( out11subadd, invdet );

	__m128 out12submula = _mm_mul_ps( NEGATE_PS( in->m[3][0] ), sub05 );
	__m128 out12submulb = _mm_mul_ps( in->m[3][2], sub02 );
	__m128 out12submulc = _mm_mul_ps( in->m[3][3], sub01 );
	__m128 out12subadd  = _mm_add_ps( out12submula, out12submulb );
	__m128 out12subsub  = _mm_sub_ps( out12subadd, out12submulc );
	out->m[1][2] = _mm_mul_ps( out12subsub, invdet );

	__m128 out13submula = _mm_mul_ps( in->m[2][0], sub05 );
	__m128 out13submulb = _mm_mul_ps( in->m[2][2], sub02 );
	__m128 out13submulc = _mm_mul_ps( in->m[2][3], sub01 );
	__m128 out13subsub  = _mm_sub_ps( out13submula, out13submulb );
	__m128 out13subadd  = _mm_add_ps( out13subsub, out13submulc );
	out->m[1][3] = _mm_mul_ps( out13subadd, invdet );

	__m128 out20submula = _mm_mul_ps( in->m[1][0], cof04 );
	__m128 out20submulb = _mm_mul_ps( in->m[1][1], cof02 );
	__m128 out20submulc = _mm_mul_ps( in->m[1][3], cof00 );
	__m128 out20subsub  = _mm_sub_ps( out20submula, out20submulb );
	__m128 out20subadd  = _mm_add_ps( out20subsub, out20submulc );
	out->m[2][0] = _mm_mul_ps( out20subadd, invdet );

	__m128 out21submula = _mm_mul_ps( NEGATE_PS( in->m[0][0] ), cof04 );
	__m128 out21submulb = _mm_mul_ps( in->m[0][1], cof02 );
	__m128 out21submulc = _mm_mul_ps( in->m[0][3], cof00 );
	__m128 out21subadd  = _mm_add_ps( out21submula, out21submulb );
	__m128 out21subsub  = _mm_sub_ps( out21subadd, out21submulc );
	out->m[2][1] = _mm_mul_ps( out21subsub, invdet );

	__m128 out22submula = _mm_mul_ps( in->m[3][0], sub04 );
	__m128 out22submulb = _mm_mul_ps( in->m[3][1], sub02 );
	__m128 out22submulc = _mm_mul_ps( in->m[3][3], sub00 );
	__m128 out22subsub  = _mm_sub_ps( out22submula, out22submulb );
	__m128 out22subadd  = _mm_add_ps( out22subsub, out22submulc );
	out->m[2][2] = _mm_mul_ps( out22subadd, invdet );

	__m128 out23submula = _mm_mul_ps( NEGATE_PS( in->m[2][0] ), sub04 );
	__m128 out23submulb = _mm_mul_ps( in->m[2][1], sub02 );
	__m128 out23submulc = _mm_mul_ps( in->m[2][3], sub00 );
	__m128 out23subadd  = _mm_add_ps( out23submula, out23submulb );
	__m128 out23subsub  = _mm_sub_ps( out23subadd, out23submulc );
	out->m[2][3] = _mm_mul_ps( out23subsub, invdet );

	__m128 out30submula = _mm_mul_ps( NEGATE_PS( in->m[1][0] ), cof03 );
	__m128 out30submulb = _mm_mul_ps( in->m[1][1], cof01 );
	__m128 out30submulc = _mm_mul_ps( in->m[1][2], cof00 );
	__m128 out30subadd  = _mm_add_ps( out30submula, out30submulb );
	__m128 out30subsub  = _mm_sub_ps( out30subadd, out30submulc );
	out->m[3][0] = _mm_mul_ps( out30subsub, invdet );

	__m128 out31submula = _mm_mul_ps( in->m[0][0], cof03 );
	__m128 out31submulb = _mm_mul_ps( in->m[0][1], cof01 );
	__m128 out31submulc = _mm_mul_ps( in->m[0][2], cof00 );
	__m128 out31subsub  = _mm_sub_ps( out31submula, out31submulb );
	__m128 out31subadd  = _mm_add_ps( out31subsub, out31submulc );
	out->m[3][1] = _mm_mul_ps( out31subadd, invdet );

	__m128 out32submula = _mm_mul_ps( NEGATE_PS( in->m[3][0] ), sub03 );
	__m128 out32submulb = _mm_mul_ps( in->m[3][1], sub01 );
	__m128 out32submulc = _mm_mul_ps( in->m[3][2], sub00 );
	__m128 out32subadd  = _mm_add_ps( out32submula, out32submulb );
	__m128 out32subsub  = _mm_sub_ps( out32subadd, out32submulc );
	out->m[3][2] = _mm_mul_ps( out32subsub, invdet );

	__m128 out33submula = _mm_mul_ps( in->m[2][0], sub03 );
	__m128 out33submulb = _mm_mul_ps( in->m[2][1], sub01 );
	__m128 out33submulc = _mm_mul_ps( in->m[2][2], sub00 );
	__m128 out33subsub  = _mm_sub_ps( out33submula, out33submulb );
	__m128 out33subadd  = _mm_add_ps( out33subsub, out33submulc );
	out->m[3][3] = _mm_mul_ps( out33subadd, invdet );
}

/// \relates float4x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise addition between the lhs and rhs __m128 registers of the input.
inline static void float4x4_comp_addm_sse( const float4x4_sse_t* lhs, const float4x4_sse_t* rhs, float4x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_add_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_add_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_add_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_add_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_add_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_add_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_add_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_add_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_add_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_add_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_add_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_add_ps( lhs->m[2][3], rhs->m[2][3] );

	// row 3
	out->m[3][0] = _mm_add_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_add_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_add_ps( lhs->m[3][2], rhs->m[3][2] );
	out->m[3][3] = _mm_add_ps( lhs->m[3][3], rhs->m[3][3] );
}

/// \relates float4x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise subtraction between the lhs and rhs __m128 registers of the input.
inline static void float4x4_comp_subm_sse( const float4x4_sse_t* lhs, const float4x4_sse_t* rhs, float4x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_sub_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_sub_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_sub_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_sub_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_sub_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_sub_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_sub_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_sub_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_sub_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_sub_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_sub_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_sub_ps( lhs->m[2][3], rhs->m[2][3] );

	// row 3
	out->m[3][0] = _mm_sub_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_sub_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_sub_ps( lhs->m[3][2], rhs->m[3][2] );
	out->m[3][3] = _mm_sub_ps( lhs->m[3][3], rhs->m[3][3] );
}

/// \relates float4x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise multiplication between the lhs and rhs __m128 registers of the input.
inline static void float4x4_comp_mulm_sse( const float4x4_sse_t* lhs, const float4x4_sse_t* rhs, float4x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_mul_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_mul_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_mul_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_mul_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_mul_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_mul_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_mul_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_mul_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_mul_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_mul_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_mul_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_mul_ps( lhs->m[2][3], rhs->m[2][3] );

	// row 3
	out->m[3][0] = _mm_mul_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_mul_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_mul_ps( lhs->m[3][2], rhs->m[3][2] );
	out->m[3][3] = _mm_mul_ps( lhs->m[3][3], rhs->m[3][3] );
}

/// \relates float4x4_sse_t
/// \brief Stores a matrix that is the result of the component-wise division between the lhs and rhs __m128 registers of the input.
inline static void float4x4_comp_divm_sse( const float4x4_sse_t* lhs, const float4x4_sse_t* rhs, float4x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	// row 0
	out->m[0][0] = _mm_div_ps( lhs->m[0][0], rhs->m[0][0] );
	out->m[0][1] = _mm_div_ps( lhs->m[0][1], rhs->m[0][1] );
	out->m[0][2] = _mm_div_ps( lhs->m[0][2], rhs->m[0][2] );
	out->m[0][3] = _mm_div_ps( lhs->m[0][3], rhs->m[0][3] );

	// row 1
	out->m[1][0] = _mm_div_ps( lhs->m[1][0], rhs->m[1][0] );
	out->m[1][1] = _mm_div_ps( lhs->m[1][1], rhs->m[1][1] );
	out->m[1][2] = _mm_div_ps( lhs->m[1][2], rhs->m[1][2] );
	out->m[1][3] = _mm_div_ps( lhs->m[1][3], rhs->m[1][3] );

	// row 2
	out->m[2][0] = _mm_div_ps( lhs->m[2][0], rhs->m[2][0] );
	out->m[2][1] = _mm_div_ps( lhs->m[2][1], rhs->m[2][1] );
	out->m[2][2] = _mm_div_ps( lhs->m[2][2], rhs->m[2][2] );
	out->m[2][3] = _mm_div_ps( lhs->m[2][3], rhs->m[2][3] );

	// row 3
	out->m[3][0] = _mm_div_ps( lhs->m[3][0], rhs->m[3][0] );
	out->m[3][1] = _mm_div_ps( lhs->m[3][1], rhs->m[3][1] );
	out->m[3][2] = _mm_div_ps( lhs->m[3][2], rhs->m[3][2] );
	out->m[3][3] = _mm_div_ps( lhs->m[3][3], rhs->m[3][3] );
}

/// \relates float4x4
/// \brief Performs a matrix-multiplication of 2 matrices of __m128 registers.
inline static void float4x4_mulm_sse( const float4x4_sse_t* lhs, const float4x4_sse_t* rhs, float4x4_sse_t* out )
{
	assert( lhs );
	assert( rhs );
	assert( out );

	float4_sse_t dot_lhs;
	float4_sse_t dot_rhs;

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][0] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][1] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];
	dot_rhs.w = rhs->m[3][2];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][2] );

	dot_lhs.x = lhs->m[0][0];
	dot_lhs.y = lhs->m[0][1];
	dot_lhs.z = lhs->m[0][2];
	dot_lhs.w = lhs->m[0][3];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];
	dot_rhs.w = rhs->m[3][3];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[0][3] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][0] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][1] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];
	dot_rhs.w = rhs->m[3][2];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][2] );

	dot_lhs.x = lhs->m[1][0];
	dot_lhs.y = lhs->m[1][1];
	dot_lhs.z = lhs->m[1][2];
	dot_lhs.w = lhs->m[1][3];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];
	dot_rhs.w = rhs->m[3][3];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[1][3] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];
	dot_lhs.w = lhs->m[2][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][0] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];
	dot_lhs.w = lhs->m[2][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][1] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];
	dot_lhs.w = lhs->m[2][3];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];
	dot_rhs.w = rhs->m[3][2];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][2] );

	dot_lhs.x = lhs->m[2][0];
	dot_lhs.y = lhs->m[2][1];
	dot_lhs.z = lhs->m[2][2];
	dot_lhs.w = lhs->m[2][3];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];
	dot_rhs.w = rhs->m[3][3];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[2][3] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];
	dot_lhs.w = lhs->m[3][3];

	dot_rhs.x = rhs->m[0][0];
	dot_rhs.y = rhs->m[1][0];
	dot_rhs.z = rhs->m[2][0];
	dot_rhs.w = rhs->m[3][0];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][0] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];
	dot_lhs.w = lhs->m[3][3];

	dot_rhs.x = rhs->m[0][1];
	dot_rhs.y = rhs->m[1][1];
	dot_rhs.z = rhs->m[2][1];
	dot_rhs.w = rhs->m[3][1];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][1] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];
	dot_lhs.w = lhs->m[3][3];

	dot_rhs.x = rhs->m[0][2];
	dot_rhs.y = rhs->m[1][2];
	dot_rhs.z = rhs->m[2][2];
	dot_rhs.w = rhs->m[3][2];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][2] );

	dot_lhs.x = lhs->m[3][0];
	dot_lhs.y = lhs->m[3][1];
	dot_lhs.z = lhs->m[3][2];
	dot_lhs.w = lhs->m[3][3];

	dot_rhs.x = rhs->m[0][3];
	dot_rhs.y = rhs->m[1][3];
	dot_rhs.z = rhs->m[2][3];
	dot_rhs.w = rhs->m[3][3];

	float4_dot_sse( &dot_lhs, &dot_rhs, &out->m[3][3] );
}

/// \relates float4x4_sse_t
/// \brief Stores a last matrix column that has been translated by the given __m128 register vector in the input.
inline static void float4x4_translate_sse( const float3_sse_t* column, const float3_sse_t* vec, float3_sse_t* out_column )
{
	assert( column );
	assert( vec );
	assert( out_column );

	out_column->x = _mm_add_ps( column->x, vec->x );
	out_column->y = _mm_add_ps( column->y, vec->y );
	out_column->z = _mm_add_ps( column->z, vec->z );
}

/// \relates float4x4_sse_t
/// \brief Stores an array of float4x4_sse_t diagonals that have been scaled by the given vector in the input.
inline static void float4x4_scale_sse( const float3_sse_t* diagonal, const float3_sse_t* scale, float3_sse_t* out_diagonal )
{
	assert( diagonal );
	assert( scale );
	assert( out_diagonal );

	out_diagonal->x = _mm_mul_ps( diagonal->x, scale->x );
	out_diagonal->y = _mm_mul_ps( diagonal->y, scale->y );
	out_diagonal->z = _mm_mul_ps( diagonal->z, scale->z );
}



/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#include "bool2x2.h"
#include "bool2x3.h"
#include "bool2x4.h"
#include "bool3x2.h"
#include "bool3x3.h"
#include "bool3x4.h"
#include "bool4x2.h"
#include "bool4x3.h"
#include "bool4x4.h"

#include "int2x2.h"
#include "int2x3.h"
#include "int2x4.h"
#include "int3x2.h"
#include "int3x3.h"
#include "int3x4.h"
#include "int4x2.h"
#include "int4x3.h"
#include "int4x4.h"

#include "uint2x2.h"
#include "uint2x3.h"
#include "uint2x4.h"
#include "uint3x2.h"
#include "uint3x3.h"
#include "uint3x4.h"
#include "uint4x2.h"
#include "uint4x3.h"
#include "uint4x4.h"

#include "float2x2.h"
#include "float2x3.h"
#include "float2x4.h"
#include "float3x2.h"
#include "float3x3.h"
#include "float3x4.h"
#include "float4x2.h"
#include "float4x3.h"
#include "float4x4.h"

#include "double2x2.h"
#include "double2x3.h"
#include "double2x4.h"
#include "double3x2.h"
#include "double3x3.h"
#include "double3x4.h"
#include "double4x2.h"
#include "double4x3.h"
#include "double4x4.h"

#include "hlml_functions_vector.h"

// bool2x2
/// \relates bool2x2
/// \brief Returns true if the all the components of the left-hand-side bool2x2 match the other one, otherwise returns false.
inline bool cmpe( const bool2x2& lhs, const bool2x2& rhs );

/// \relates bool2x2
/// \brief Returns true if not all of the components of the left-hand-side bool2x2 match the other one, otherwise returns false.
inline bool cmpne( const bool2x2& lhs, const bool2x2& rhs );

/// \relates bool2x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool2x2& mat );

/// \relates bool2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x2 transpose( const bool2x2& mat );


// bool2x3
/// \relates bool2x3
/// \brief Returns true if the all the components of the left-hand-side bool2x3 match the other one, otherwise returns false.
inline bool cmpe( const bool2x3& lhs, const bool2x3& rhs );

/// \relates bool2x3
/// \brief Returns true if not all of the components of the left-hand-side bool2x3 match the other one, otherwise returns false.
inline bool cmpne( const bool2x3& lhs, const bool2x3& rhs );

/// \relates bool2x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool2x3& mat );

/// \relates bool2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x2 transpose( const bool2x3& mat );


// bool2x4
/// \relates bool2x4
/// \brief Returns true if the all the components of the left-hand-side bool2x4 match the other one, otherwise returns false.
inline bool cmpe( const bool2x4& lhs, const bool2x4& rhs );

/// \relates bool2x4
/// \brief Returns true if not all of the components of the left-hand-side bool2x4 match the other one, otherwise returns false.
inline bool cmpne( const bool2x4& lhs, const bool2x4& rhs );

/// \relates bool2x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool2x4& mat );

/// \relates bool2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x2 transpose( const bool2x4& mat );


// bool3x2
/// \relates bool3x2
/// \brief Returns true if the all the components of the left-hand-side bool3x2 match the other one, otherwise returns false.
inline bool cmpe( const bool3x2& lhs, const bool3x2& rhs );

/// \relates bool3x2
/// \brief Returns true if not all of the components of the left-hand-side bool3x2 match the other one, otherwise returns false.
inline bool cmpne( const bool3x2& lhs, const bool3x2& rhs );

/// \relates bool3x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool3x2& mat );

/// \relates bool3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x3 transpose( const bool3x2& mat );


// bool3x3
/// \relates bool3x3
/// \brief Returns true if the all the components of the left-hand-side bool3x3 match the other one, otherwise returns false.
inline bool cmpe( const bool3x3& lhs, const bool3x3& rhs );

/// \relates bool3x3
/// \brief Returns true if not all of the components of the left-hand-side bool3x3 match the other one, otherwise returns false.
inline bool cmpne( const bool3x3& lhs, const bool3x3& rhs );

/// \relates bool3x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool3x3& mat );

/// \relates bool3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x3 transpose( const bool3x3& mat );


// bool3x4
/// \relates bool3x4
/// \brief Returns true if the all the components of the left-hand-side bool3x4 match the other one, otherwise returns false.
inline bool cmpe( const bool3x4& lhs, const bool3x4& rhs );

/// \relates bool3x4
/// \brief Returns true if not all of the components of the left-hand-side bool3x4 match the other one, otherwise returns false.
inline bool cmpne( const bool3x4& lhs, const bool3x4& rhs );

/// \relates bool3x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool3x4& mat );

/// \relates bool3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x3 transpose( const bool3x4& mat );


// bool4x2
/// \relates bool4x2
/// \brief Returns true if the all the components of the left-hand-side bool4x2 match the other one, otherwise returns false.
inline bool cmpe( const bool4x2& lhs, const bool4x2& rhs );

/// \relates bool4x2
/// \brief Returns true if not all of the components of the left-hand-side bool4x2 match the other one, otherwise returns false.
inline bool cmpne( const bool4x2& lhs, const bool4x2& rhs );

/// \relates bool4x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool4x2& mat );

/// \relates bool4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool2x4 transpose( const bool4x2& mat );


// bool4x3
/// \relates bool4x3
/// \brief Returns true if the all the components of the left-hand-side bool4x3 match the other one, otherwise returns false.
inline bool cmpe( const bool4x3& lhs, const bool4x3& rhs );

/// \relates bool4x3
/// \brief Returns true if not all of the components of the left-hand-side bool4x3 match the other one, otherwise returns false.
inline bool cmpne( const bool4x3& lhs, const bool4x3& rhs );

/// \relates bool4x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool4x3& mat );

/// \relates bool4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool3x4 transpose( const bool4x3& mat );


// bool4x4
/// \relates bool4x4
/// \brief Returns true if the all the components of the left-hand-side bool4x4 match the other one, otherwise returns false.
inline bool cmpe( const bool4x4& lhs, const bool4x4& rhs );

/// \relates bool4x4
/// \brief Returns true if not all of the components of the left-hand-side bool4x4 match the other one, otherwise returns false.
inline bool cmpne( const bool4x4& lhs, const bool4x4& rhs );

/// \relates bool4x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( bool4x4& mat );

/// \relates bool4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline bool4x4 transpose( const bool4x4& mat );


// int2x2
/// \relates int2x2
/// \brief Returns true if the all the components of the left-hand-side int2x2 match the other one, otherwise returns false.
inline bool cmpe( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns true if not all of the components of the left-hand-side int2x2 match the other one, otherwise returns false.
inline bool cmpne( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise added by the given scalar value.
inline int2x2 comp_adds( const int2x2& lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise added by the corresponding component of the right-hand int2x2.
inline int2x2 comp_addm( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise subtracted by the given scalar value.
inline int2x2 comp_subs( const int2x2& lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise subtracted by the corresponding component of the right-hand int2x2.
inline int2x2 comp_subm( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise multiplied by the given scalar value.
inline int2x2 comp_muls( const int2x2& lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise multiplied by the corresponding component of the right-hand int2x2.
inline int2x2 comp_mulm( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise divided by the given scalar value.
inline int2x2 comp_divs( const int2x2& lhs, const int32_t scalar );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 that has been component-wise divided by the corresponding component of the right-hand int2x2.
inline int2x2 comp_divm( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise AND'd against the corresponding component of the right-hand side int2x2.
inline int2x2 comp_and( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise OR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 comp_or( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise XOR'd against the corresponding component of the right-hand side int2x2.
inline int2x2 comp_xor( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Performs a unary bitwise operation on all components of the given int2x2.
inline int2x2 comp_unary( const int2x2& lhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise left-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 comp_shift_left( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a copy of the int2x2 where each component of the left-hand int2x2 has been bitwise right-shifted by the corresponding component of the right-hand side int2x2.
inline int2x2 comp_shift_right( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 cmpl( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 cmple( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 cmpg( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 cmpge( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( int2x2& mat );

/// \relates int2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x2 transpose( const int2x2& mat );

/// \relates int2x2
/// \brief Returns the determinant of the matrix.
inline int32_t determinant( const int2x2& mat );

/// \relates int2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 mul( const int2x2& lhs, const int2x2& rhs );

/// \relates int2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline int2 mul( const int2x2& lhs, const int2& rhs );


// int2x3
/// \relates int2x3
/// \brief Returns true if the all the components of the left-hand-side int2x3 match the other one, otherwise returns false.
inline bool cmpe( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns true if not all of the components of the left-hand-side int2x3 match the other one, otherwise returns false.
inline bool cmpne( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise added by the given scalar value.
inline int2x3 comp_adds( const int2x3& lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise added by the corresponding component of the right-hand int2x3.
inline int2x3 comp_addm( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise subtracted by the given scalar value.
inline int2x3 comp_subs( const int2x3& lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise subtracted by the corresponding component of the right-hand int2x3.
inline int2x3 comp_subm( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise multiplied by the given scalar value.
inline int2x3 comp_muls( const int2x3& lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise multiplied by the corresponding component of the right-hand int2x3.
inline int2x3 comp_mulm( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise divided by the given scalar value.
inline int2x3 comp_divs( const int2x3& lhs, const int32_t scalar );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 that has been component-wise divided by the corresponding component of the right-hand int2x3.
inline int2x3 comp_divm( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise AND'd against the corresponding component of the right-hand side int2x3.
inline int2x3 comp_and( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise OR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 comp_or( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise XOR'd against the corresponding component of the right-hand side int2x3.
inline int2x3 comp_xor( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Performs a unary bitwise operation on all components of the given int2x3.
inline int2x3 comp_unary( const int2x3& lhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise left-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 comp_shift_left( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a copy of the int2x3 where each component of the left-hand int2x3 has been bitwise right-shifted by the corresponding component of the right-hand side int2x3.
inline int2x3 comp_shift_right( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 cmpl( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 cmple( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 cmpg( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 cmpge( const int2x3& lhs, const int2x3& rhs );

/// \relates int2x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( int2x3& mat );

/// \relates int2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x2 transpose( const int2x3& mat );

/// \relates int2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 mul( const int2x3& lhs, const int3x2& rhs );

/// \relates int2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int2x3 scale( const int2x3& mat, const int2& vec );


// int2x4
/// \relates int2x4
/// \brief Returns true if the all the components of the left-hand-side int2x4 match the other one, otherwise returns false.
inline bool cmpe( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns true if not all of the components of the left-hand-side int2x4 match the other one, otherwise returns false.
inline bool cmpne( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise added by the given scalar value.
inline int2x4 comp_adds( const int2x4& lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise added by the corresponding component of the right-hand int2x4.
inline int2x4 comp_addm( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise subtracted by the given scalar value.
inline int2x4 comp_subs( const int2x4& lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise subtracted by the corresponding component of the right-hand int2x4.
inline int2x4 comp_subm( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise multiplied by the given scalar value.
inline int2x4 comp_muls( const int2x4& lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise multiplied by the corresponding component of the right-hand int2x4.
inline int2x4 comp_mulm( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise divided by the given scalar value.
inline int2x4 comp_divs( const int2x4& lhs, const int32_t scalar );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 that has been component-wise divided by the corresponding component of the right-hand int2x4.
inline int2x4 comp_divm( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise AND'd against the corresponding component of the right-hand side int2x4.
inline int2x4 comp_and( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise OR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 comp_or( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise XOR'd against the corresponding component of the right-hand side int2x4.
inline int2x4 comp_xor( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Performs a unary bitwise operation on all components of the given int2x4.
inline int2x4 comp_unary( const int2x4& lhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise left-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 comp_shift_left( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a copy of the int2x4 where each component of the left-hand int2x4 has been bitwise right-shifted by the corresponding component of the right-hand side int2x4.
inline int2x4 comp_shift_right( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 cmpl( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 cmple( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 cmpg( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 cmpge( const int2x4& lhs, const int2x4& rhs );

/// \relates int2x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( int2x4& mat );

/// \relates int2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x2 transpose( const int2x4& mat );

/// \relates int2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int2x2 mul( const int2x4& lhs, const int4x2& rhs );

/// \relates int2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int2x4 scale( const int2x4& mat, const int2& vec );


// int3x2
/// \relates int3x2
/// \brief Returns true if the all the components of the left-hand-side int3x2 match the other one, otherwise returns false.
inline bool cmpe( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns true if not all of the components of the left-hand-side int3x2 match the other one, otherwise returns false.
inline bool cmpne( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise added by the given scalar value.
inline int3x2 comp_adds( const int3x2& lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise added by the corresponding component of the right-hand int3x2.
inline int3x2 comp_addm( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise subtracted by the given scalar value.
inline int3x2 comp_subs( const int3x2& lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise subtracted by the corresponding component of the right-hand int3x2.
inline int3x2 comp_subm( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise multiplied by the given scalar value.
inline int3x2 comp_muls( const int3x2& lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise multiplied by the corresponding component of the right-hand int3x2.
inline int3x2 comp_mulm( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise divided by the given scalar value.
inline int3x2 comp_divs( const int3x2& lhs, const int32_t scalar );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 that has been component-wise divided by the corresponding component of the right-hand int3x2.
inline int3x2 comp_divm( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise AND'd against the corresponding component of the right-hand side int3x2.
inline int3x2 comp_and( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise OR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 comp_or( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise XOR'd against the corresponding component of the right-hand side int3x2.
inline int3x2 comp_xor( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Performs a unary bitwise operation on all components of the given int3x2.
inline int3x2 comp_unary( const int3x2& lhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise left-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 comp_shift_left( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a copy of the int3x2 where each component of the left-hand int3x2 has been bitwise right-shifted by the corresponding component of the right-hand side int3x2.
inline int3x2 comp_shift_right( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 cmpl( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 cmple( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 cmpg( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 cmpge( const int3x2& lhs, const int3x2& rhs );

/// \relates int3x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( int3x2& mat );

/// \relates int3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x3 transpose( const int3x2& mat );

/// \relates int3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 mul( const int3x2& lhs, const int2x3& rhs );


// int3x3
/// \relates int3x3
/// \brief Returns true if the all the components of the left-hand-side int3x3 match the other one, otherwise returns false.
inline bool cmpe( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns true if not all of the components of the left-hand-side int3x3 match the other one, otherwise returns false.
inline bool cmpne( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise added by the given scalar value.
inline int3x3 comp_adds( const int3x3& lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise added by the corresponding component of the right-hand int3x3.
inline int3x3 comp_addm( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise subtracted by the given scalar value.
inline int3x3 comp_subs( const int3x3& lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise subtracted by the corresponding component of the right-hand int3x3.
inline int3x3 comp_subm( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise multiplied by the given scalar value.
inline int3x3 comp_muls( const int3x3& lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise multiplied by the corresponding component of the right-hand int3x3.
inline int3x3 comp_mulm( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise divided by the given scalar value.
inline int3x3 comp_divs( const int3x3& lhs, const int32_t scalar );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 that has been component-wise divided by the corresponding component of the right-hand int3x3.
inline int3x3 comp_divm( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise AND'd against the corresponding component of the right-hand side int3x3.
inline int3x3 comp_and( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise OR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 comp_or( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise XOR'd against the corresponding component of the right-hand side int3x3.
inline int3x3 comp_xor( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Performs a unary bitwise operation on all components of the given int3x3.
inline int3x3 comp_unary( const int3x3& lhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise left-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 comp_shift_left( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the int3x3 where each component of the left-hand int3x3 has been bitwise right-shifted by the corresponding component of the right-hand side int3x3.
inline int3x3 comp_shift_right( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 cmpl( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 cmple( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 cmpg( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 cmpge( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( int3x3& mat );

/// \relates int3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x3 transpose( const int3x3& mat );

/// \relates int3x3
/// \brief Returns the determinant of the matrix.
inline int32_t determinant( const int3x3& mat );

/// \relates int3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 mul( const int3x3& lhs, const int3x3& rhs );

/// \relates int3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline int3 mul( const int3x3& lhs, const int3& rhs );

/// \relates int3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int3x3 translate( const int3x3& mat, const int2& vec );

/// \relates int3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int3x3 scale( const int3x3& mat, const int2& vec );


// int3x4
/// \relates int3x4
/// \brief Returns true if the all the components of the left-hand-side int3x4 match the other one, otherwise returns false.
inline bool cmpe( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns true if not all of the components of the left-hand-side int3x4 match the other one, otherwise returns false.
inline bool cmpne( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise added by the given scalar value.
inline int3x4 comp_adds( const int3x4& lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise added by the corresponding component of the right-hand int3x4.
inline int3x4 comp_addm( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise subtracted by the given scalar value.
inline int3x4 comp_subs( const int3x4& lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise subtracted by the corresponding component of the right-hand int3x4.
inline int3x4 comp_subm( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise multiplied by the given scalar value.
inline int3x4 comp_muls( const int3x4& lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise multiplied by the corresponding component of the right-hand int3x4.
inline int3x4 comp_mulm( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise divided by the given scalar value.
inline int3x4 comp_divs( const int3x4& lhs, const int32_t scalar );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 that has been component-wise divided by the corresponding component of the right-hand int3x4.
inline int3x4 comp_divm( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise AND'd against the corresponding component of the right-hand side int3x4.
inline int3x4 comp_and( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise OR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 comp_or( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise XOR'd against the corresponding component of the right-hand side int3x4.
inline int3x4 comp_xor( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Performs a unary bitwise operation on all components of the given int3x4.
inline int3x4 comp_unary( const int3x4& lhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise left-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 comp_shift_left( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a copy of the int3x4 where each component of the left-hand int3x4 has been bitwise right-shifted by the corresponding component of the right-hand side int3x4.
inline int3x4 comp_shift_right( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 cmpl( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 cmple( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 cmpg( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 cmpge( const int3x4& lhs, const int3x4& rhs );

/// \relates int3x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( int3x4& mat );

/// \relates int3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x3 transpose( const int3x4& mat );

/// \relates int3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int3x3 mul( const int3x4& lhs, const int4x3& rhs );

/// \relates int3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int3x4 translate( const int3x4& mat, const int3& vec );

/// \relates int3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int3x4 scale( const int3x4& mat, const int2& vec );


// int4x2
/// \relates int4x2
/// \brief Returns true if the all the components of the left-hand-side int4x2 match the other one, otherwise returns false.
inline bool cmpe( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns true if not all of the components of the left-hand-side int4x2 match the other one, otherwise returns false.
inline bool cmpne( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise added by the given scalar value.
inline int4x2 comp_adds( const int4x2& lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise added by the corresponding component of the right-hand int4x2.
inline int4x2 comp_addm( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise subtracted by the given scalar value.
inline int4x2 comp_subs( const int4x2& lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise subtracted by the corresponding component of the right-hand int4x2.
inline int4x2 comp_subm( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise multiplied by the given scalar value.
inline int4x2 comp_muls( const int4x2& lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise multiplied by the corresponding component of the right-hand int4x2.
inline int4x2 comp_mulm( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise divided by the given scalar value.
inline int4x2 comp_divs( const int4x2& lhs, const int32_t scalar );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 that has been component-wise divided by the corresponding component of the right-hand int4x2.
inline int4x2 comp_divm( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise AND'd against the corresponding component of the right-hand side int4x2.
inline int4x2 comp_and( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise OR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 comp_or( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise XOR'd against the corresponding component of the right-hand side int4x2.
inline int4x2 comp_xor( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Performs a unary bitwise operation on all components of the given int4x2.
inline int4x2 comp_unary( const int4x2& lhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise left-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 comp_shift_left( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a copy of the int4x2 where each component of the left-hand int4x2 has been bitwise right-shifted by the corresponding component of the right-hand side int4x2.
inline int4x2 comp_shift_right( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 cmpl( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 cmple( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 cmpg( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 cmpge( const int4x2& lhs, const int4x2& rhs );

/// \relates int4x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( int4x2& mat );

/// \relates int4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int2x4 transpose( const int4x2& mat );

/// \relates int4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 mul( const int4x2& lhs, const int2x4& rhs );


// int4x3
/// \relates int4x3
/// \brief Returns true if the all the components of the left-hand-side int4x3 match the other one, otherwise returns false.
inline bool cmpe( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns true if not all of the components of the left-hand-side int4x3 match the other one, otherwise returns false.
inline bool cmpne( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise added by the given scalar value.
inline int4x3 comp_adds( const int4x3& lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise added by the corresponding component of the right-hand int4x3.
inline int4x3 comp_addm( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise subtracted by the given scalar value.
inline int4x3 comp_subs( const int4x3& lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise subtracted by the corresponding component of the right-hand int4x3.
inline int4x3 comp_subm( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise multiplied by the given scalar value.
inline int4x3 comp_muls( const int4x3& lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise multiplied by the corresponding component of the right-hand int4x3.
inline int4x3 comp_mulm( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise divided by the given scalar value.
inline int4x3 comp_divs( const int4x3& lhs, const int32_t scalar );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 that has been component-wise divided by the corresponding component of the right-hand int4x3.
inline int4x3 comp_divm( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise AND'd against the corresponding component of the right-hand side int4x3.
inline int4x3 comp_and( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise OR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 comp_or( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise XOR'd against the corresponding component of the right-hand side int4x3.
inline int4x3 comp_xor( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Performs a unary bitwise operation on all components of the given int4x3.
inline int4x3 comp_unary( const int4x3& lhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise left-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 comp_shift_left( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a copy of the int4x3 where each component of the left-hand int4x3 has been bitwise right-shifted by the corresponding component of the right-hand side int4x3.
inline int4x3 comp_shift_right( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 cmpl( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 cmple( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 cmpg( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 cmpge( const int4x3& lhs, const int4x3& rhs );

/// \relates int4x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( int4x3& mat );

/// \relates int4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int3x4 transpose( const int4x3& mat );

/// \relates int4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 mul( const int4x3& lhs, const int3x4& rhs );

/// \relates int4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int4x3 scale( const int4x3& mat, const int2& vec );


// int4x4
/// \relates int4x4
/// \brief Returns true if the all the components of the left-hand-side int4x4 match the other one, otherwise returns false.
inline bool cmpe( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns true if not all of the components of the left-hand-side int4x4 match the other one, otherwise returns false.
inline bool cmpne( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise added by the given scalar value.
inline int4x4 comp_adds( const int4x4& lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise added by the corresponding component of the right-hand int4x4.
inline int4x4 comp_addm( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise subtracted by the given scalar value.
inline int4x4 comp_subs( const int4x4& lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise subtracted by the corresponding component of the right-hand int4x4.
inline int4x4 comp_subm( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise multiplied by the given scalar value.
inline int4x4 comp_muls( const int4x4& lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise multiplied by the corresponding component of the right-hand int4x4.
inline int4x4 comp_mulm( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise divided by the given scalar value.
inline int4x4 comp_divs( const int4x4& lhs, const int32_t scalar );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 that has been component-wise divided by the corresponding component of the right-hand int4x4.
inline int4x4 comp_divm( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise AND'd against the corresponding component of the right-hand side int4x4.
inline int4x4 comp_and( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise OR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 comp_or( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise XOR'd against the corresponding component of the right-hand side int4x4.
inline int4x4 comp_xor( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Performs a unary bitwise operation on all components of the given int4x4.
inline int4x4 comp_unary( const int4x4& lhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise left-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 comp_shift_left( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the int4x4 where each component of the left-hand int4x4 has been bitwise right-shifted by the corresponding component of the right-hand side int4x4.
inline int4x4 comp_shift_right( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 cmpl( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 cmple( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 cmpg( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 cmpge( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( int4x4& mat );

/// \relates int4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline int4x4 transpose( const int4x4& mat );

/// \relates int4x4
/// \brief Returns the determinant of the matrix.
inline int32_t determinant( const int4x4& mat );

/// \relates int4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline int4x4 mul( const int4x4& lhs, const int4x4& rhs );

/// \relates int4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline int4 mul( const int4x4& lhs, const int4& rhs );

/// \relates int4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline int4x4 translate( const int4x4& mat, const int3& vec );

/// \relates int4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline int4x4 scale( const int4x4& mat, const int3& vec );


// uint2x2
/// \relates uint2x2
/// \brief Returns true if the all the components of the left-hand-side uint2x2 match the other one, otherwise returns false.
inline bool cmpe( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns true if not all of the components of the left-hand-side uint2x2 match the other one, otherwise returns false.
inline bool cmpne( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise added by the given scalar value.
inline uint2x2 comp_adds( const uint2x2& lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise added by the corresponding component of the right-hand uint2x2.
inline uint2x2 comp_addm( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise subtracted by the given scalar value.
inline uint2x2 comp_subs( const uint2x2& lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise subtracted by the corresponding component of the right-hand uint2x2.
inline uint2x2 comp_subm( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise multiplied by the given scalar value.
inline uint2x2 comp_muls( const uint2x2& lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise multiplied by the corresponding component of the right-hand uint2x2.
inline uint2x2 comp_mulm( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise divided by the given scalar value.
inline uint2x2 comp_divs( const uint2x2& lhs, const uint32_t scalar );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 that has been component-wise divided by the corresponding component of the right-hand uint2x2.
inline uint2x2 comp_divm( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise AND'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 comp_and( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise OR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 comp_or( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x2.
inline uint2x2 comp_xor( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Performs a unary bitwise operation on all components of the given uint2x2.
inline uint2x2 comp_unary( const uint2x2& lhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 comp_shift_left( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a copy of the uint2x2 where each component of the left-hand uint2x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x2.
inline uint2x2 comp_shift_right( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 cmpl( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 cmple( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 cmpg( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 cmpge( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint2x2& mat );

/// \relates uint2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x2 transpose( const uint2x2& mat );

/// \relates uint2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 mul( const uint2x2& lhs, const uint2x2& rhs );

/// \relates uint2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline uint2 mul( const uint2x2& lhs, const uint2& rhs );


// uint2x3
/// \relates uint2x3
/// \brief Returns true if the all the components of the left-hand-side uint2x3 match the other one, otherwise returns false.
inline bool cmpe( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns true if not all of the components of the left-hand-side uint2x3 match the other one, otherwise returns false.
inline bool cmpne( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise added by the given scalar value.
inline uint2x3 comp_adds( const uint2x3& lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise added by the corresponding component of the right-hand uint2x3.
inline uint2x3 comp_addm( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise subtracted by the given scalar value.
inline uint2x3 comp_subs( const uint2x3& lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise subtracted by the corresponding component of the right-hand uint2x3.
inline uint2x3 comp_subm( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise multiplied by the given scalar value.
inline uint2x3 comp_muls( const uint2x3& lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise multiplied by the corresponding component of the right-hand uint2x3.
inline uint2x3 comp_mulm( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise divided by the given scalar value.
inline uint2x3 comp_divs( const uint2x3& lhs, const uint32_t scalar );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 that has been component-wise divided by the corresponding component of the right-hand uint2x3.
inline uint2x3 comp_divm( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise AND'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 comp_and( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise OR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 comp_or( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x3.
inline uint2x3 comp_xor( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Performs a unary bitwise operation on all components of the given uint2x3.
inline uint2x3 comp_unary( const uint2x3& lhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 comp_shift_left( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the uint2x3 where each component of the left-hand uint2x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x3.
inline uint2x3 comp_shift_right( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 cmpl( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 cmple( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 cmpg( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 cmpge( const uint2x3& lhs, const uint2x3& rhs );

/// \relates uint2x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint2x3& mat );

/// \relates uint2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x2 transpose( const uint2x3& mat );

/// \relates uint2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 mul( const uint2x3& lhs, const uint3x2& rhs );

/// \relates uint2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint2x3 scale( const uint2x3& mat, const uint2& vec );


// uint2x4
/// \relates uint2x4
/// \brief Returns true if the all the components of the left-hand-side uint2x4 match the other one, otherwise returns false.
inline bool cmpe( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns true if not all of the components of the left-hand-side uint2x4 match the other one, otherwise returns false.
inline bool cmpne( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise added by the given scalar value.
inline uint2x4 comp_adds( const uint2x4& lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise added by the corresponding component of the right-hand uint2x4.
inline uint2x4 comp_addm( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise subtracted by the given scalar value.
inline uint2x4 comp_subs( const uint2x4& lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise subtracted by the corresponding component of the right-hand uint2x4.
inline uint2x4 comp_subm( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise multiplied by the given scalar value.
inline uint2x4 comp_muls( const uint2x4& lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise multiplied by the corresponding component of the right-hand uint2x4.
inline uint2x4 comp_mulm( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise divided by the given scalar value.
inline uint2x4 comp_divs( const uint2x4& lhs, const uint32_t scalar );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 that has been component-wise divided by the corresponding component of the right-hand uint2x4.
inline uint2x4 comp_divm( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise AND'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 comp_and( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise OR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 comp_or( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint2x4.
inline uint2x4 comp_xor( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Performs a unary bitwise operation on all components of the given uint2x4.
inline uint2x4 comp_unary( const uint2x4& lhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 comp_shift_left( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the uint2x4 where each component of the left-hand uint2x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint2x4.
inline uint2x4 comp_shift_right( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 cmpl( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 cmple( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 cmpg( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 cmpge( const uint2x4& lhs, const uint2x4& rhs );

/// \relates uint2x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint2x4& mat );

/// \relates uint2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x2 transpose( const uint2x4& mat );

/// \relates uint2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint2x2 mul( const uint2x4& lhs, const uint4x2& rhs );

/// \relates uint2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint2x4 scale( const uint2x4& mat, const uint2& vec );


// uint3x2
/// \relates uint3x2
/// \brief Returns true if the all the components of the left-hand-side uint3x2 match the other one, otherwise returns false.
inline bool cmpe( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns true if not all of the components of the left-hand-side uint3x2 match the other one, otherwise returns false.
inline bool cmpne( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise added by the given scalar value.
inline uint3x2 comp_adds( const uint3x2& lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise added by the corresponding component of the right-hand uint3x2.
inline uint3x2 comp_addm( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise subtracted by the given scalar value.
inline uint3x2 comp_subs( const uint3x2& lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise subtracted by the corresponding component of the right-hand uint3x2.
inline uint3x2 comp_subm( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise multiplied by the given scalar value.
inline uint3x2 comp_muls( const uint3x2& lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise multiplied by the corresponding component of the right-hand uint3x2.
inline uint3x2 comp_mulm( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise divided by the given scalar value.
inline uint3x2 comp_divs( const uint3x2& lhs, const uint32_t scalar );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 that has been component-wise divided by the corresponding component of the right-hand uint3x2.
inline uint3x2 comp_divm( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise AND'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 comp_and( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise OR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 comp_or( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x2.
inline uint3x2 comp_xor( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Performs a unary bitwise operation on all components of the given uint3x2.
inline uint3x2 comp_unary( const uint3x2& lhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 comp_shift_left( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a copy of the uint3x2 where each component of the left-hand uint3x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x2.
inline uint3x2 comp_shift_right( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 cmpl( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 cmple( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 cmpg( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 cmpge( const uint3x2& lhs, const uint3x2& rhs );

/// \relates uint3x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint3x2& mat );

/// \relates uint3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x3 transpose( const uint3x2& mat );

/// \relates uint3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 mul( const uint3x2& lhs, const uint2x3& rhs );


// uint3x3
/// \relates uint3x3
/// \brief Returns true if the all the components of the left-hand-side uint3x3 match the other one, otherwise returns false.
inline bool cmpe( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns true if not all of the components of the left-hand-side uint3x3 match the other one, otherwise returns false.
inline bool cmpne( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise added by the given scalar value.
inline uint3x3 comp_adds( const uint3x3& lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise added by the corresponding component of the right-hand uint3x3.
inline uint3x3 comp_addm( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise subtracted by the given scalar value.
inline uint3x3 comp_subs( const uint3x3& lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise subtracted by the corresponding component of the right-hand uint3x3.
inline uint3x3 comp_subm( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise multiplied by the given scalar value.
inline uint3x3 comp_muls( const uint3x3& lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise multiplied by the corresponding component of the right-hand uint3x3.
inline uint3x3 comp_mulm( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise divided by the given scalar value.
inline uint3x3 comp_divs( const uint3x3& lhs, const uint32_t scalar );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 that has been component-wise divided by the corresponding component of the right-hand uint3x3.
inline uint3x3 comp_divm( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise AND'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 comp_and( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise OR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 comp_or( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x3.
inline uint3x3 comp_xor( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Performs a unary bitwise operation on all components of the given uint3x3.
inline uint3x3 comp_unary( const uint3x3& lhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 comp_shift_left( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the uint3x3 where each component of the left-hand uint3x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x3.
inline uint3x3 comp_shift_right( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 cmpl( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 cmple( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 cmpg( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 cmpge( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint3x3& mat );

/// \relates uint3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x3 transpose( const uint3x3& mat );

/// \relates uint3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 mul( const uint3x3& lhs, const uint3x3& rhs );

/// \relates uint3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline uint3 mul( const uint3x3& lhs, const uint3& rhs );

/// \relates uint3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint3x3 translate( const uint3x3& mat, const uint2& vec );

/// \relates uint3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint3x3 scale( const uint3x3& mat, const uint2& vec );


// uint3x4
/// \relates uint3x4
/// \brief Returns true if the all the components of the left-hand-side uint3x4 match the other one, otherwise returns false.
inline bool cmpe( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns true if not all of the components of the left-hand-side uint3x4 match the other one, otherwise returns false.
inline bool cmpne( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise added by the given scalar value.
inline uint3x4 comp_adds( const uint3x4& lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise added by the corresponding component of the right-hand uint3x4.
inline uint3x4 comp_addm( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise subtracted by the given scalar value.
inline uint3x4 comp_subs( const uint3x4& lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise subtracted by the corresponding component of the right-hand uint3x4.
inline uint3x4 comp_subm( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise multiplied by the given scalar value.
inline uint3x4 comp_muls( const uint3x4& lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise multiplied by the corresponding component of the right-hand uint3x4.
inline uint3x4 comp_mulm( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise divided by the given scalar value.
inline uint3x4 comp_divs( const uint3x4& lhs, const uint32_t scalar );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 that has been component-wise divided by the corresponding component of the right-hand uint3x4.
inline uint3x4 comp_divm( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise AND'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 comp_and( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise OR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 comp_or( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint3x4.
inline uint3x4 comp_xor( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Performs a unary bitwise operation on all components of the given uint3x4.
inline uint3x4 comp_unary( const uint3x4& lhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 comp_shift_left( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the uint3x4 where each component of the left-hand uint3x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint3x4.
inline uint3x4 comp_shift_right( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 cmpl( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 cmple( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 cmpg( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 cmpge( const uint3x4& lhs, const uint3x4& rhs );

/// \relates uint3x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint3x4& mat );

/// \relates uint3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x3 transpose( const uint3x4& mat );

/// \relates uint3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint3x3 mul( const uint3x4& lhs, const uint4x3& rhs );

/// \relates uint3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint3x4 translate( const uint3x4& mat, const uint3& vec );

/// \relates uint3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint3x4 scale( const uint3x4& mat, const uint2& vec );


// uint4x2
/// \relates uint4x2
/// \brief Returns true if the all the components of the left-hand-side uint4x2 match the other one, otherwise returns false.
inline bool cmpe( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns true if not all of the components of the left-hand-side uint4x2 match the other one, otherwise returns false.
inline bool cmpne( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise added by the given scalar value.
inline uint4x2 comp_adds( const uint4x2& lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise added by the corresponding component of the right-hand uint4x2.
inline uint4x2 comp_addm( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise subtracted by the given scalar value.
inline uint4x2 comp_subs( const uint4x2& lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise subtracted by the corresponding component of the right-hand uint4x2.
inline uint4x2 comp_subm( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise multiplied by the given scalar value.
inline uint4x2 comp_muls( const uint4x2& lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise multiplied by the corresponding component of the right-hand uint4x2.
inline uint4x2 comp_mulm( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise divided by the given scalar value.
inline uint4x2 comp_divs( const uint4x2& lhs, const uint32_t scalar );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 that has been component-wise divided by the corresponding component of the right-hand uint4x2.
inline uint4x2 comp_divm( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise AND'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 comp_and( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise OR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 comp_or( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x2.
inline uint4x2 comp_xor( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Performs a unary bitwise operation on all components of the given uint4x2.
inline uint4x2 comp_unary( const uint4x2& lhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 comp_shift_left( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a copy of the uint4x2 where each component of the left-hand uint4x2 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x2.
inline uint4x2 comp_shift_right( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 cmpl( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 cmple( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 cmpg( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 cmpge( const uint4x2& lhs, const uint4x2& rhs );

/// \relates uint4x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint4x2& mat );

/// \relates uint4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint2x4 transpose( const uint4x2& mat );

/// \relates uint4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 mul( const uint4x2& lhs, const uint2x4& rhs );


// uint4x3
/// \relates uint4x3
/// \brief Returns true if the all the components of the left-hand-side uint4x3 match the other one, otherwise returns false.
inline bool cmpe( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns true if not all of the components of the left-hand-side uint4x3 match the other one, otherwise returns false.
inline bool cmpne( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise added by the given scalar value.
inline uint4x3 comp_adds( const uint4x3& lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise added by the corresponding component of the right-hand uint4x3.
inline uint4x3 comp_addm( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise subtracted by the given scalar value.
inline uint4x3 comp_subs( const uint4x3& lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise subtracted by the corresponding component of the right-hand uint4x3.
inline uint4x3 comp_subm( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise multiplied by the given scalar value.
inline uint4x3 comp_muls( const uint4x3& lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise multiplied by the corresponding component of the right-hand uint4x3.
inline uint4x3 comp_mulm( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise divided by the given scalar value.
inline uint4x3 comp_divs( const uint4x3& lhs, const uint32_t scalar );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 that has been component-wise divided by the corresponding component of the right-hand uint4x3.
inline uint4x3 comp_divm( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise AND'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 comp_and( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise OR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 comp_or( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x3.
inline uint4x3 comp_xor( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Performs a unary bitwise operation on all components of the given uint4x3.
inline uint4x3 comp_unary( const uint4x3& lhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 comp_shift_left( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the uint4x3 where each component of the left-hand uint4x3 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x3.
inline uint4x3 comp_shift_right( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 cmpl( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 cmple( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 cmpg( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 cmpge( const uint4x3& lhs, const uint4x3& rhs );

/// \relates uint4x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint4x3& mat );

/// \relates uint4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint3x4 transpose( const uint4x3& mat );

/// \relates uint4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 mul( const uint4x3& lhs, const uint3x4& rhs );

/// \relates uint4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint4x3 scale( const uint4x3& mat, const uint2& vec );


// uint4x4
/// \relates uint4x4
/// \brief Returns true if the all the components of the left-hand-side uint4x4 match the other one, otherwise returns false.
inline bool cmpe( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns true if not all of the components of the left-hand-side uint4x4 match the other one, otherwise returns false.
inline bool cmpne( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise added by the given scalar value.
inline uint4x4 comp_adds( const uint4x4& lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise added by the corresponding component of the right-hand uint4x4.
inline uint4x4 comp_addm( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise subtracted by the given scalar value.
inline uint4x4 comp_subs( const uint4x4& lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise subtracted by the corresponding component of the right-hand uint4x4.
inline uint4x4 comp_subm( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise multiplied by the given scalar value.
inline uint4x4 comp_muls( const uint4x4& lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise multiplied by the corresponding component of the right-hand uint4x4.
inline uint4x4 comp_mulm( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise divided by the given scalar value.
inline uint4x4 comp_divs( const uint4x4& lhs, const uint32_t scalar );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 that has been component-wise divided by the corresponding component of the right-hand uint4x4.
inline uint4x4 comp_divm( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise AND'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 comp_and( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise OR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 comp_or( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise XOR'd against the corresponding component of the right-hand side uint4x4.
inline uint4x4 comp_xor( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Performs a unary bitwise operation on all components of the given uint4x4.
inline uint4x4 comp_unary( const uint4x4& lhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise left-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 comp_shift_left( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the uint4x4 where each component of the left-hand uint4x4 has been bitwise right-shifted by the corresponding component of the right-hand side uint4x4.
inline uint4x4 comp_shift_right( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 cmpl( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 cmple( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 cmpg( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 cmpge( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( uint4x4& mat );

/// \relates uint4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline uint4x4 transpose( const uint4x4& mat );

/// \relates uint4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline uint4x4 mul( const uint4x4& lhs, const uint4x4& rhs );

/// \relates uint4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline uint4 mul( const uint4x4& lhs, const uint4& rhs );

/// \relates uint4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline uint4x4 translate( const uint4x4& mat, const uint3& vec );

/// \relates uint4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline uint4x4 scale( const uint4x4& mat, const uint3& vec );


// float2x2
/// \relates float2x2
/// \brief Returns true if the all the components of the left-hand-side float2x2 match the other one, otherwise returns false.
inline bool cmpe( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns true if not all of the components of the left-hand-side float2x2 match the other one, otherwise returns false.
inline bool cmpne( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise added by the given scalar value.
inline float2x2 comp_adds( const float2x2& lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise added by the corresponding component of the right-hand float2x2.
inline float2x2 comp_addm( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise subtracted by the given scalar value.
inline float2x2 comp_subs( const float2x2& lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise subtracted by the corresponding component of the right-hand float2x2.
inline float2x2 comp_subm( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise multiplied by the given scalar value.
inline float2x2 comp_muls( const float2x2& lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise multiplied by the corresponding component of the right-hand float2x2.
inline float2x2 comp_mulm( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise divided by the given scalar value.
inline float2x2 comp_divs( const float2x2& lhs, const float scalar );

/// \relates float2x2
/// \brief Returns a copy of the float2x2 that has been component-wise divided by the corresponding component of the right-hand float2x2.
inline float2x2 comp_divm( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 cmpl( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 cmple( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 cmpg( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 cmpge( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( float2x2& mat );

/// \relates float2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x2 transpose( const float2x2& mat );

/// \relates float2x2
/// \brief Returns the determinant of the matrix.
inline float determinant( const float2x2& mat );

/// \relates float2x2
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float2x2 inverse( const float2x2& mat );

/// \relates float2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 mul( const float2x2& lhs, const float2x2& rhs );

/// \relates float2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline float2 mul( const float2x2& lhs, const float2& rhs );


// float2x3
/// \relates float2x3
/// \brief Returns true if the all the components of the left-hand-side float2x3 match the other one, otherwise returns false.
inline bool cmpe( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns true if not all of the components of the left-hand-side float2x3 match the other one, otherwise returns false.
inline bool cmpne( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise added by the given scalar value.
inline float2x3 comp_adds( const float2x3& lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise added by the corresponding component of the right-hand float2x3.
inline float2x3 comp_addm( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise subtracted by the given scalar value.
inline float2x3 comp_subs( const float2x3& lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise subtracted by the corresponding component of the right-hand float2x3.
inline float2x3 comp_subm( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise multiplied by the given scalar value.
inline float2x3 comp_muls( const float2x3& lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise multiplied by the corresponding component of the right-hand float2x3.
inline float2x3 comp_mulm( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise divided by the given scalar value.
inline float2x3 comp_divs( const float2x3& lhs, const float scalar );

/// \relates float2x3
/// \brief Returns a copy of the float2x3 that has been component-wise divided by the corresponding component of the right-hand float2x3.
inline float2x3 comp_divm( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 cmpl( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 cmple( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 cmpg( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 cmpge( const float2x3& lhs, const float2x3& rhs );

/// \relates float2x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( float2x3& mat );

/// \relates float2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x2 transpose( const float2x3& mat );

/// \relates float2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 mul( const float2x3& lhs, const float3x2& rhs );

/// \relates float2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float2x3 scale( const float2x3& mat, const float2& vec );


// float2x4
/// \relates float2x4
/// \brief Returns true if the all the components of the left-hand-side float2x4 match the other one, otherwise returns false.
inline bool cmpe( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns true if not all of the components of the left-hand-side float2x4 match the other one, otherwise returns false.
inline bool cmpne( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise added by the given scalar value.
inline float2x4 comp_adds( const float2x4& lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise added by the corresponding component of the right-hand float2x4.
inline float2x4 comp_addm( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise subtracted by the given scalar value.
inline float2x4 comp_subs( const float2x4& lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise subtracted by the corresponding component of the right-hand float2x4.
inline float2x4 comp_subm( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise multiplied by the given scalar value.
inline float2x4 comp_muls( const float2x4& lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise multiplied by the corresponding component of the right-hand float2x4.
inline float2x4 comp_mulm( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise divided by the given scalar value.
inline float2x4 comp_divs( const float2x4& lhs, const float scalar );

/// \relates float2x4
/// \brief Returns a copy of the float2x4 that has been component-wise divided by the corresponding component of the right-hand float2x4.
inline float2x4 comp_divm( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 cmpl( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 cmple( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 cmpg( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 cmpge( const float2x4& lhs, const float2x4& rhs );

/// \relates float2x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( float2x4& mat );

/// \relates float2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x2 transpose( const float2x4& mat );

/// \relates float2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float2x2 mul( const float2x4& lhs, const float4x2& rhs );

/// \relates float2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float2x4 scale( const float2x4& mat, const float2& vec );


// float3x2
/// \relates float3x2
/// \brief Returns true if the all the components of the left-hand-side float3x2 match the other one, otherwise returns false.
inline bool cmpe( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns true if not all of the components of the left-hand-side float3x2 match the other one, otherwise returns false.
inline bool cmpne( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise added by the given scalar value.
inline float3x2 comp_adds( const float3x2& lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise added by the corresponding component of the right-hand float3x2.
inline float3x2 comp_addm( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise subtracted by the given scalar value.
inline float3x2 comp_subs( const float3x2& lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise subtracted by the corresponding component of the right-hand float3x2.
inline float3x2 comp_subm( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise multiplied by the given scalar value.
inline float3x2 comp_muls( const float3x2& lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise multiplied by the corresponding component of the right-hand float3x2.
inline float3x2 comp_mulm( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise divided by the given scalar value.
inline float3x2 comp_divs( const float3x2& lhs, const float scalar );

/// \relates float3x2
/// \brief Returns a copy of the float3x2 that has been component-wise divided by the corresponding component of the right-hand float3x2.
inline float3x2 comp_divm( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 cmpl( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 cmple( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 cmpg( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 cmpge( const float3x2& lhs, const float3x2& rhs );

/// \relates float3x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( float3x2& mat );

/// \relates float3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x3 transpose( const float3x2& mat );

/// \relates float3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 mul( const float3x2& lhs, const float2x3& rhs );


// float3x3
/// \relates float3x3
/// \brief Returns true if the all the components of the left-hand-side float3x3 match the other one, otherwise returns false.
inline bool cmpe( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns true if not all of the components of the left-hand-side float3x3 match the other one, otherwise returns false.
inline bool cmpne( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise added by the given scalar value.
inline float3x3 comp_adds( const float3x3& lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise added by the corresponding component of the right-hand float3x3.
inline float3x3 comp_addm( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise subtracted by the given scalar value.
inline float3x3 comp_subs( const float3x3& lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise subtracted by the corresponding component of the right-hand float3x3.
inline float3x3 comp_subm( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise multiplied by the given scalar value.
inline float3x3 comp_muls( const float3x3& lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise multiplied by the corresponding component of the right-hand float3x3.
inline float3x3 comp_mulm( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise divided by the given scalar value.
inline float3x3 comp_divs( const float3x3& lhs, const float scalar );

/// \relates float3x3
/// \brief Returns a copy of the float3x3 that has been component-wise divided by the corresponding component of the right-hand float3x3.
inline float3x3 comp_divm( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 cmpl( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 cmple( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 cmpg( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 cmpge( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( float3x3& mat );

/// \relates float3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x3 transpose( const float3x3& mat );

/// \relates float3x3
/// \brief Returns the determinant of the matrix.
inline float determinant( const float3x3& mat );

/// \relates float3x3
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float3x3 inverse( const float3x3& mat );

/// \relates float3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 mul( const float3x3& lhs, const float3x3& rhs );

/// \relates float3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline float3 mul( const float3x3& lhs, const float3& rhs );

/// \relates float3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float3x3 translate( const float3x3& mat, const float2& vec );

/// \relates float3x3
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline float3x3 rotate( const float3x3& mat, const float rad );

/// \relates float3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float3x3 scale( const float3x3& mat, const float2& vec );


// float3x4
/// \relates float3x4
/// \brief Returns true if the all the components of the left-hand-side float3x4 match the other one, otherwise returns false.
inline bool cmpe( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns true if not all of the components of the left-hand-side float3x4 match the other one, otherwise returns false.
inline bool cmpne( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise added by the given scalar value.
inline float3x4 comp_adds( const float3x4& lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise added by the corresponding component of the right-hand float3x4.
inline float3x4 comp_addm( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise subtracted by the given scalar value.
inline float3x4 comp_subs( const float3x4& lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise subtracted by the corresponding component of the right-hand float3x4.
inline float3x4 comp_subm( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise multiplied by the given scalar value.
inline float3x4 comp_muls( const float3x4& lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise multiplied by the corresponding component of the right-hand float3x4.
inline float3x4 comp_mulm( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise divided by the given scalar value.
inline float3x4 comp_divs( const float3x4& lhs, const float scalar );

/// \relates float3x4
/// \brief Returns a copy of the float3x4 that has been component-wise divided by the corresponding component of the right-hand float3x4.
inline float3x4 comp_divm( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 cmpl( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 cmple( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 cmpg( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 cmpge( const float3x4& lhs, const float3x4& rhs );

/// \relates float3x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( float3x4& mat );

/// \relates float3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x3 transpose( const float3x4& mat );

/// \relates float3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float3x3 mul( const float3x4& lhs, const float4x3& rhs );

/// \relates float3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float3x4 translate( const float3x4& mat, const float3& vec );

/// \relates float3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float3x4 scale( const float3x4& mat, const float2& vec );


// float4x2
/// \relates float4x2
/// \brief Returns true if the all the components of the left-hand-side float4x2 match the other one, otherwise returns false.
inline bool cmpe( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns true if not all of the components of the left-hand-side float4x2 match the other one, otherwise returns false.
inline bool cmpne( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise added by the given scalar value.
inline float4x2 comp_adds( const float4x2& lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise added by the corresponding component of the right-hand float4x2.
inline float4x2 comp_addm( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise subtracted by the given scalar value.
inline float4x2 comp_subs( const float4x2& lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise subtracted by the corresponding component of the right-hand float4x2.
inline float4x2 comp_subm( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise multiplied by the given scalar value.
inline float4x2 comp_muls( const float4x2& lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise multiplied by the corresponding component of the right-hand float4x2.
inline float4x2 comp_mulm( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise divided by the given scalar value.
inline float4x2 comp_divs( const float4x2& lhs, const float scalar );

/// \relates float4x2
/// \brief Returns a copy of the float4x2 that has been component-wise divided by the corresponding component of the right-hand float4x2.
inline float4x2 comp_divm( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 cmpl( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 cmple( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 cmpg( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 cmpge( const float4x2& lhs, const float4x2& rhs );

/// \relates float4x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( float4x2& mat );

/// \relates float4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float2x4 transpose( const float4x2& mat );

/// \relates float4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 mul( const float4x2& lhs, const float2x4& rhs );


// float4x3
/// \relates float4x3
/// \brief Returns true if the all the components of the left-hand-side float4x3 match the other one, otherwise returns false.
inline bool cmpe( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns true if not all of the components of the left-hand-side float4x3 match the other one, otherwise returns false.
inline bool cmpne( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise added by the given scalar value.
inline float4x3 comp_adds( const float4x3& lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise added by the corresponding component of the right-hand float4x3.
inline float4x3 comp_addm( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise subtracted by the given scalar value.
inline float4x3 comp_subs( const float4x3& lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise subtracted by the corresponding component of the right-hand float4x3.
inline float4x3 comp_subm( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise multiplied by the given scalar value.
inline float4x3 comp_muls( const float4x3& lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise multiplied by the corresponding component of the right-hand float4x3.
inline float4x3 comp_mulm( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise divided by the given scalar value.
inline float4x3 comp_divs( const float4x3& lhs, const float scalar );

/// \relates float4x3
/// \brief Returns a copy of the float4x3 that has been component-wise divided by the corresponding component of the right-hand float4x3.
inline float4x3 comp_divm( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 cmpl( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 cmple( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 cmpg( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 cmpge( const float4x3& lhs, const float4x3& rhs );

/// \relates float4x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( float4x3& mat );

/// \relates float4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float3x4 transpose( const float4x3& mat );

/// \relates float4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 mul( const float4x3& lhs, const float3x4& rhs );

/// \relates float4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float4x3 scale( const float4x3& mat, const float2& vec );


// float4x4
/// \relates float4x4
/// \brief Returns true if the all the components of the left-hand-side float4x4 match the other one, otherwise returns false.
inline bool cmpe( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns true if not all of the components of the left-hand-side float4x4 match the other one, otherwise returns false.
inline bool cmpne( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise added by the given scalar value.
inline float4x4 comp_adds( const float4x4& lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise added by the corresponding component of the right-hand float4x4.
inline float4x4 comp_addm( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise subtracted by the given scalar value.
inline float4x4 comp_subs( const float4x4& lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise subtracted by the corresponding component of the right-hand float4x4.
inline float4x4 comp_subm( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise multiplied by the given scalar value.
inline float4x4 comp_muls( const float4x4& lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise multiplied by the corresponding component of the right-hand float4x4.
inline float4x4 comp_mulm( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise divided by the given scalar value.
inline float4x4 comp_divs( const float4x4& lhs, const float scalar );

/// \relates float4x4
/// \brief Returns a copy of the float4x4 that has been component-wise divided by the corresponding component of the right-hand float4x4.
inline float4x4 comp_divm( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 cmpl( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 cmple( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 cmpg( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 cmpge( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( float4x4& mat );

/// \relates float4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline float4x4 transpose( const float4x4& mat );

/// \relates float4x4
/// \brief Returns the determinant of the matrix.
inline float determinant( const float4x4& mat );

/// \relates float4x4
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline float4x4 inverse( const float4x4& mat );

/// \relates float4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline float4x4 mul( const float4x4& lhs, const float4x4& rhs );

/// \relates float4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline float4 mul( const float4x4& lhs, const float4& rhs );

/// \relates float4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline float4x4 translate( const float4x4& mat, const float3& vec );

/// \relates float4x4
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline float4x4 rotate( const float4x4& mat, const float rad, const float3& axis );

/// \relates float4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline float4x4 scale( const float4x4& mat, const float3& vec );

/// \relates float4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range zero to one.
inline float4x4 ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range minus-one to one.
inline float4x4 ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range zero to one.
inline float4x4 ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range minus-one to one.
inline float4x4 ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline float4x4 perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline float4x4 perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline float4x4 perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline float4x4 perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar );

/// \relates float4x4
/// \brief Returns a left-handed orthonormal matrix that is oriented at position eye to look at position target.
inline float4x4 lookat_lh( const float3& eye, const float3& target, const float3& up );

/// \relates float4x4
/// \brief Returns a right-handed orthonormal matrix that is oriented at position eye to look at position target.
inline float4x4 lookat_rh( const float3& eye, const float3& target, const float3& up );


// double2x2
/// \relates double2x2
/// \brief Returns true if the all the components of the left-hand-side double2x2 match the other one, otherwise returns false.
inline bool cmpe( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns true if not all of the components of the left-hand-side double2x2 match the other one, otherwise returns false.
inline bool cmpne( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise added by the given scalar value.
inline double2x2 comp_adds( const double2x2& lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise added by the corresponding component of the right-hand double2x2.
inline double2x2 comp_addm( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise subtracted by the given scalar value.
inline double2x2 comp_subs( const double2x2& lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise subtracted by the corresponding component of the right-hand double2x2.
inline double2x2 comp_subm( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise multiplied by the given scalar value.
inline double2x2 comp_muls( const double2x2& lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise multiplied by the corresponding component of the right-hand double2x2.
inline double2x2 comp_mulm( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise divided by the given scalar value.
inline double2x2 comp_divs( const double2x2& lhs, const double scalar );

/// \relates double2x2
/// \brief Returns a copy of the double2x2 that has been component-wise divided by the corresponding component of the right-hand double2x2.
inline double2x2 comp_divm( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x2 cmpl( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x2 cmple( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x2 cmpg( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns a bool2x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x2 cmpge( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( double2x2& mat );

/// \relates double2x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x2 transpose( const double2x2& mat );

/// \relates double2x2
/// \brief Returns the determinant of the matrix.
inline double determinant( const double2x2& mat );

/// \relates double2x2
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double2x2 inverse( const double2x2& mat );

/// \relates double2x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 mul( const double2x2& lhs, const double2x2& rhs );

/// \relates double2x2
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline double2 mul( const double2x2& lhs, const double2& rhs );


// double2x3
/// \relates double2x3
/// \brief Returns true if the all the components of the left-hand-side double2x3 match the other one, otherwise returns false.
inline bool cmpe( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns true if not all of the components of the left-hand-side double2x3 match the other one, otherwise returns false.
inline bool cmpne( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise added by the given scalar value.
inline double2x3 comp_adds( const double2x3& lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise added by the corresponding component of the right-hand double2x3.
inline double2x3 comp_addm( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise subtracted by the given scalar value.
inline double2x3 comp_subs( const double2x3& lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise subtracted by the corresponding component of the right-hand double2x3.
inline double2x3 comp_subm( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise multiplied by the given scalar value.
inline double2x3 comp_muls( const double2x3& lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise multiplied by the corresponding component of the right-hand double2x3.
inline double2x3 comp_mulm( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise divided by the given scalar value.
inline double2x3 comp_divs( const double2x3& lhs, const double scalar );

/// \relates double2x3
/// \brief Returns a copy of the double2x3 that has been component-wise divided by the corresponding component of the right-hand double2x3.
inline double2x3 comp_divm( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x3 cmpl( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x3 cmple( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x3 cmpg( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Returns a bool2x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x3 cmpge( const double2x3& lhs, const double2x3& rhs );

/// \relates double2x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( double2x3& mat );

/// \relates double2x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x2 transpose( const double2x3& mat );

/// \relates double2x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 mul( const double2x3& lhs, const double3x2& rhs );

/// \relates double2x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double2x3 scale( const double2x3& mat, const double2& vec );


// double2x4
/// \relates double2x4
/// \brief Returns true if the all the components of the left-hand-side double2x4 match the other one, otherwise returns false.
inline bool cmpe( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns true if not all of the components of the left-hand-side double2x4 match the other one, otherwise returns false.
inline bool cmpne( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise added by the given scalar value.
inline double2x4 comp_adds( const double2x4& lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise added by the corresponding component of the right-hand double2x4.
inline double2x4 comp_addm( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise subtracted by the given scalar value.
inline double2x4 comp_subs( const double2x4& lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise subtracted by the corresponding component of the right-hand double2x4.
inline double2x4 comp_subm( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise multiplied by the given scalar value.
inline double2x4 comp_muls( const double2x4& lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise multiplied by the corresponding component of the right-hand double2x4.
inline double2x4 comp_mulm( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise divided by the given scalar value.
inline double2x4 comp_divs( const double2x4& lhs, const double scalar );

/// \relates double2x4
/// \brief Returns a copy of the double2x4 that has been component-wise divided by the corresponding component of the right-hand double2x4.
inline double2x4 comp_divm( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool2x4 cmpl( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool2x4 cmple( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool2x4 cmpg( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Returns a bool2x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool2x4 cmpge( const double2x4& lhs, const double2x4& rhs );

/// \relates double2x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( double2x4& mat );

/// \relates double2x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x2 transpose( const double2x4& mat );

/// \relates double2x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double2x2 mul( const double2x4& lhs, const double4x2& rhs );

/// \relates double2x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double2x4 scale( const double2x4& mat, const double2& vec );


// double3x2
/// \relates double3x2
/// \brief Returns true if the all the components of the left-hand-side double3x2 match the other one, otherwise returns false.
inline bool cmpe( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns true if not all of the components of the left-hand-side double3x2 match the other one, otherwise returns false.
inline bool cmpne( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise added by the given scalar value.
inline double3x2 comp_adds( const double3x2& lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise added by the corresponding component of the right-hand double3x2.
inline double3x2 comp_addm( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise subtracted by the given scalar value.
inline double3x2 comp_subs( const double3x2& lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise subtracted by the corresponding component of the right-hand double3x2.
inline double3x2 comp_subm( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise multiplied by the given scalar value.
inline double3x2 comp_muls( const double3x2& lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise multiplied by the corresponding component of the right-hand double3x2.
inline double3x2 comp_mulm( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise divided by the given scalar value.
inline double3x2 comp_divs( const double3x2& lhs, const double scalar );

/// \relates double3x2
/// \brief Returns a copy of the double3x2 that has been component-wise divided by the corresponding component of the right-hand double3x2.
inline double3x2 comp_divm( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x2 cmpl( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x2 cmple( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x2 cmpg( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Returns a bool3x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x2 cmpge( const double3x2& lhs, const double3x2& rhs );

/// \relates double3x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( double3x2& mat );

/// \relates double3x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x3 transpose( const double3x2& mat );

/// \relates double3x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 mul( const double3x2& lhs, const double2x3& rhs );


// double3x3
/// \relates double3x3
/// \brief Returns true if the all the components of the left-hand-side double3x3 match the other one, otherwise returns false.
inline bool cmpe( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns true if not all of the components of the left-hand-side double3x3 match the other one, otherwise returns false.
inline bool cmpne( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise added by the given scalar value.
inline double3x3 comp_adds( const double3x3& lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise added by the corresponding component of the right-hand double3x3.
inline double3x3 comp_addm( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise subtracted by the given scalar value.
inline double3x3 comp_subs( const double3x3& lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise subtracted by the corresponding component of the right-hand double3x3.
inline double3x3 comp_subm( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise multiplied by the given scalar value.
inline double3x3 comp_muls( const double3x3& lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise multiplied by the corresponding component of the right-hand double3x3.
inline double3x3 comp_mulm( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise divided by the given scalar value.
inline double3x3 comp_divs( const double3x3& lhs, const double scalar );

/// \relates double3x3
/// \brief Returns a copy of the double3x3 that has been component-wise divided by the corresponding component of the right-hand double3x3.
inline double3x3 comp_divm( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x3 cmpl( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x3 cmple( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x3 cmpg( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns a bool3x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x3 cmpge( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( double3x3& mat );

/// \relates double3x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x3 transpose( const double3x3& mat );

/// \relates double3x3
/// \brief Returns the determinant of the matrix.
inline double determinant( const double3x3& mat );

/// \relates double3x3
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double3x3 inverse( const double3x3& mat );

/// \relates double3x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 mul( const double3x3& lhs, const double3x3& rhs );

/// \relates double3x3
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline double3 mul( const double3x3& lhs, const double3& rhs );

/// \relates double3x3
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double3x3 translate( const double3x3& mat, const double2& vec );

/// \relates double3x3
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline double3x3 rotate( const double3x3& mat, const double rad );

/// \relates double3x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double3x3 scale( const double3x3& mat, const double2& vec );


// double3x4
/// \relates double3x4
/// \brief Returns true if the all the components of the left-hand-side double3x4 match the other one, otherwise returns false.
inline bool cmpe( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns true if not all of the components of the left-hand-side double3x4 match the other one, otherwise returns false.
inline bool cmpne( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise added by the given scalar value.
inline double3x4 comp_adds( const double3x4& lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise added by the corresponding component of the right-hand double3x4.
inline double3x4 comp_addm( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise subtracted by the given scalar value.
inline double3x4 comp_subs( const double3x4& lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise subtracted by the corresponding component of the right-hand double3x4.
inline double3x4 comp_subm( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise multiplied by the given scalar value.
inline double3x4 comp_muls( const double3x4& lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise multiplied by the corresponding component of the right-hand double3x4.
inline double3x4 comp_mulm( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise divided by the given scalar value.
inline double3x4 comp_divs( const double3x4& lhs, const double scalar );

/// \relates double3x4
/// \brief Returns a copy of the double3x4 that has been component-wise divided by the corresponding component of the right-hand double3x4.
inline double3x4 comp_divm( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool3x4 cmpl( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool3x4 cmple( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool3x4 cmpg( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Returns a bool3x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool3x4 cmpge( const double3x4& lhs, const double3x4& rhs );

/// \relates double3x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( double3x4& mat );

/// \relates double3x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x3 transpose( const double3x4& mat );

/// \relates double3x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double3x3 mul( const double3x4& lhs, const double4x3& rhs );

/// \relates double3x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double3x4 translate( const double3x4& mat, const double3& vec );

/// \relates double3x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double3x4 scale( const double3x4& mat, const double2& vec );


// double4x2
/// \relates double4x2
/// \brief Returns true if the all the components of the left-hand-side double4x2 match the other one, otherwise returns false.
inline bool cmpe( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns true if not all of the components of the left-hand-side double4x2 match the other one, otherwise returns false.
inline bool cmpne( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise added by the given scalar value.
inline double4x2 comp_adds( const double4x2& lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise added by the corresponding component of the right-hand double4x2.
inline double4x2 comp_addm( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise subtracted by the given scalar value.
inline double4x2 comp_subs( const double4x2& lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise subtracted by the corresponding component of the right-hand double4x2.
inline double4x2 comp_subm( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise multiplied by the given scalar value.
inline double4x2 comp_muls( const double4x2& lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise multiplied by the corresponding component of the right-hand double4x2.
inline double4x2 comp_mulm( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise divided by the given scalar value.
inline double4x2 comp_divs( const double4x2& lhs, const double scalar );

/// \relates double4x2
/// \brief Returns a copy of the double4x2 that has been component-wise divided by the corresponding component of the right-hand double4x2.
inline double4x2 comp_divm( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x2 cmpl( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x2 cmple( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x2 cmpg( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Returns a bool4x2 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x2 cmpge( const double4x2& lhs, const double4x2& rhs );

/// \relates double4x2
/// \brief Sets the matrix to an identity matrix.
inline void identity( double4x2& mat );

/// \relates double4x2
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double2x4 transpose( const double4x2& mat );

/// \relates double4x2
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 mul( const double4x2& lhs, const double2x4& rhs );


// double4x3
/// \relates double4x3
/// \brief Returns true if the all the components of the left-hand-side double4x3 match the other one, otherwise returns false.
inline bool cmpe( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns true if not all of the components of the left-hand-side double4x3 match the other one, otherwise returns false.
inline bool cmpne( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise added by the given scalar value.
inline double4x3 comp_adds( const double4x3& lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise added by the corresponding component of the right-hand double4x3.
inline double4x3 comp_addm( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise subtracted by the given scalar value.
inline double4x3 comp_subs( const double4x3& lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise subtracted by the corresponding component of the right-hand double4x3.
inline double4x3 comp_subm( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise multiplied by the given scalar value.
inline double4x3 comp_muls( const double4x3& lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise multiplied by the corresponding component of the right-hand double4x3.
inline double4x3 comp_mulm( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise divided by the given scalar value.
inline double4x3 comp_divs( const double4x3& lhs, const double scalar );

/// \relates double4x3
/// \brief Returns a copy of the double4x3 that has been component-wise divided by the corresponding component of the right-hand double4x3.
inline double4x3 comp_divm( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x3 cmpl( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x3 cmple( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x3 cmpg( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Returns a bool4x3 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x3 cmpge( const double4x3& lhs, const double4x3& rhs );

/// \relates double4x3
/// \brief Sets the matrix to an identity matrix.
inline void identity( double4x3& mat );

/// \relates double4x3
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double3x4 transpose( const double4x3& mat );

/// \relates double4x3
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 mul( const double4x3& lhs, const double3x4& rhs );

/// \relates double4x3
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double4x3 scale( const double4x3& mat, const double2& vec );


// double4x4
/// \relates double4x4
/// \brief Returns true if the all the components of the left-hand-side double4x4 match the other one, otherwise returns false.
inline bool cmpe( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns true if not all of the components of the left-hand-side double4x4 match the other one, otherwise returns false.
inline bool cmpne( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise added by the given scalar value.
inline double4x4 comp_adds( const double4x4& lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise added by the corresponding component of the right-hand double4x4.
inline double4x4 comp_addm( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise subtracted by the given scalar value.
inline double4x4 comp_subs( const double4x4& lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise subtracted by the corresponding component of the right-hand double4x4.
inline double4x4 comp_subm( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise multiplied by the given scalar value.
inline double4x4 comp_muls( const double4x4& lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise multiplied by the corresponding component of the right-hand double4x4.
inline double4x4 comp_mulm( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise divided by the given scalar value.
inline double4x4 comp_divs( const double4x4& lhs, const double scalar );

/// \relates double4x4
/// \brief Returns a copy of the double4x4 that has been component-wise divided by the corresponding component of the right-hand double4x4.
inline double4x4 comp_divm( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than the corresponding right-hand type component.
inline bool4x4 cmpl( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is less than or equal to the corresponding right-hand type component.
inline bool4x4 cmple( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than the corresponding right-hand type component.
inline bool4x4 cmpg( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns a bool4x4 where each component is true if the component of the left-hand type is greater than or equal to the corresponding right-hand type component.
inline bool4x4 cmpge( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Sets the matrix to an identity matrix.
inline void identity( double4x4& mat );

/// \relates double4x4
/// \brief Returns a copy of the matrix that is transposed, where the value of each row is set to the value of each column and vice versa.
inline double4x4 transpose( const double4x4& mat );

/// \relates double4x4
/// \brief Returns the determinant of the matrix.
inline double determinant( const double4x4& mat );

/// \relates double4x4
/// \brief Returns a copy of the matrix that is inversed.
/// Currently this is only applicable for square matrices.  Pseudo-inverse support for non-square matrices is coming soon.
inline double4x4 inverse( const double4x4& mat );

/// \relates double4x4
/// \brief Returns a copy of the matrix where each row of the left-hand matrix has been dot-producted by the corresponding column of the right-hand matrix.
inline double4x4 mul( const double4x4& lhs, const double4x4& rhs );

/// \relates double4x4
/// \brief Returns the right-hand vector multiplied by the left-hand matrix.
inline double4 mul( const double4x4& lhs, const double4& rhs );

/// \relates double4x4
/// \brief Returns a copy of the matrix where each component of the 3rd column has been added by the given vector.
inline double4x4 translate( const double4x4& mat, const double3& vec );

/// \relates double4x4
/// \brief Returns a copy of the matrix that has had a rotation applied to it in radians on one or more of the following axes.
inline double4x4 rotate( const double4x4& mat, const double rad, const double3& axis );

/// \relates double4x4
/// \brief Returns a copy of the matrix that has had a non-uniform scale applied to it.
inline double4x4 scale( const double4x4& mat, const double3& vec );

/// \relates double4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range zero to one.
inline double4x4 ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns an left-handed orthographic projection matrix with the clip-space range minus-one to one.
inline double4x4 ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range zero to one.
inline double4x4 ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns an right-handed orthographic projection matrix with the clip-space range minus-one to one.
inline double4x4 ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline double4x4 perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a left-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline double4x4 perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of zero to one.
inline double4x4 perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a right-handed perspective projection matrix based on a vertical field-of-view in degrees and an aspect ratio in the clip-space range of minus-one to one.
inline double4x4 perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar );

/// \relates double4x4
/// \brief Returns a left-handed orthonormal matrix that is oriented at position eye to look at position target.
inline double4x4 lookat_lh( const double3& eye, const double3& target, const double3& up );

/// \relates double4x4
/// \brief Returns a right-handed orthonormal matrix that is oriented at position eye to look at position target.
inline double4x4 lookat_rh( const double3& eye, const double3& target, const double3& up );


#ifdef HLML_IMPLEMENTATION

#pragma once

// ignore missing brace initializers
#if defined( __GNUC__ ) || defined( __clang__ )
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmissing-braces"
#endif

bool cmpe( const bool2x2& lhs, const bool2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const bool2x2& lhs, const bool2x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat.rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
}

bool2x2 transpose( const bool2x2& mat )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

bool cmpe( const bool2x3& lhs, const bool2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const bool2x3& lhs, const bool2x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
}

bool3x2 transpose( const bool2x3& mat )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

bool cmpe( const bool2x4& lhs, const bool2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const bool2x4& lhs, const bool2x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
}

bool4x2 transpose( const bool2x4& mat )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

bool cmpe( const bool3x2& lhs, const bool3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const bool3x2& lhs, const bool3x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat.rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat.rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
}

bool2x3 transpose( const bool3x2& mat )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

bool cmpe( const bool3x3& lhs, const bool3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const bool3x3& lhs, const bool3x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat.rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
}

bool3x3 transpose( const bool3x3& mat )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

bool cmpe( const bool3x4& lhs, const bool3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const bool3x4& lhs, const bool3x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat.rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
}

bool4x3 transpose( const bool3x4& mat )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

bool cmpe( const bool4x2& lhs, const bool4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const bool4x2& lhs, const bool4x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool2 ) { true, false };
	mat.rows[1] = HLML_CONSTRUCT( bool2 ) { false, true };
	mat.rows[2] = HLML_CONSTRUCT( bool2 ) { false, false };
	mat.rows[3] = HLML_CONSTRUCT( bool2 ) { false, false };
}

bool2x4 transpose( const bool4x2& mat )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

bool cmpe( const bool4x3& lhs, const bool4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const bool4x3& lhs, const bool4x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool3 ) { true, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool3 ) { false, true, false };
	mat.rows[2] = HLML_CONSTRUCT( bool3 ) { false, false, true };
	mat.rows[3] = HLML_CONSTRUCT( bool3 ) { false, false, false };
}

bool3x4 transpose( const bool4x3& mat )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

bool cmpe( const bool4x4& lhs, const bool4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const bool4x4& lhs, const bool4x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

void identity( bool4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( bool4 ) { true, false, false, false };
	mat.rows[1] = HLML_CONSTRUCT( bool4 ) { false, true, false, false };
	mat.rows[2] = HLML_CONSTRUCT( bool4 ) { false, false, true, false };
	mat.rows[3] = HLML_CONSTRUCT( bool4 ) { false, false, false, true };
}

bool4x4 transpose( const bool4x4& mat )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

bool cmpe( const int2x2& lhs, const int2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const int2x2& lhs, const int2x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int2x2 comp_adds( const int2x2& lhs, const int32_t scalar )
{
	return int2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

int2x2 comp_addm( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_subs( const int2x2& lhs, const int32_t scalar )
{
	return int2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

int2x2 comp_subm( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_muls( const int2x2& lhs, const int32_t scalar )
{
	return int2x2(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

int2x2 comp_mulm( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_divs( const int2x2& lhs, const int32_t scalar )
{
	return int2x2(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

int2x2 comp_divm( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_and( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_or( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_xor( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_unary( const int2x2& lhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,

		~lhs.rows[1].x,
		~lhs.rows[1].y

	};
}

int2x2 comp_shift_left( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

int2x2 comp_shift_right( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( int2x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpl( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmple( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpg( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpge( const int2x2& lhs, const int2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( int2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
}

int2x2 transpose( const int2x2& mat )
{
	return HLML_CONSTRUCT( int2x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

int32_t determinant( const int2x2& mat )
{
	return mat.rows[0].x * mat.rows[1].y - mat.rows[1].x * mat.rows[0].y;
}

int2x2 mul( const int2x2& lhs, const int2x2& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

int2 mul( const int2x2& lhs, const int2& rhs )
{
	return HLML_CONSTRUCT( int2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

bool cmpe( const int2x3& lhs, const int2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const int2x3& lhs, const int2x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int2x3 comp_adds( const int2x3& lhs, const int32_t scalar )
{
	return int2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

int2x3 comp_addm( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_subs( const int2x3& lhs, const int32_t scalar )
{
	return int2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

int2x3 comp_subm( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_muls( const int2x3& lhs, const int32_t scalar )
{
	return int2x3(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

int2x3 comp_mulm( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_divs( const int2x3& lhs, const int32_t scalar )
{
	return int2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

int2x3 comp_divm( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_and( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_or( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_xor( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_unary( const int2x3& lhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z

	};
}

int2x3 comp_shift_left( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

int2x3 comp_shift_right( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( int2x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpl( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmple( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpg( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpge( const int2x3& lhs, const int2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( int2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
}

int3x2 transpose( const int2x3& mat )
{
	return HLML_CONSTRUCT( int3x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

int2x2 mul( const int2x3& lhs, const int3x2& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

int2x3 scale( const int2x3& mat, const int2& vec )
{
	return HLML_CONSTRUCT( int2x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z
	};
}

bool cmpe( const int2x4& lhs, const int2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const int2x4& lhs, const int2x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int2x4 comp_adds( const int2x4& lhs, const int32_t scalar )
{
	return int2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

int2x4 comp_addm( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_subs( const int2x4& lhs, const int32_t scalar )
{
	return int2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

int2x4 comp_subm( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_muls( const int2x4& lhs, const int32_t scalar )
{
	return int2x4(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

int2x4 comp_mulm( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_divs( const int2x4& lhs, const int32_t scalar )
{
	return int2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

int2x4 comp_divm( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_and( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_or( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_xor( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_unary( const int2x4& lhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,
		~lhs.rows[0].w,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,
		~lhs.rows[1].w

	};
}

int2x4 comp_shift_left( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

int2x4 comp_shift_right( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( int2x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpl( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmple( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpg( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpge( const int2x4& lhs, const int2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( int2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
}

int4x2 transpose( const int2x4& mat )
{
	return HLML_CONSTRUCT( int4x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

int2x2 mul( const int2x4& lhs, const int4x2& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( int2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

int2x4 scale( const int2x4& mat, const int2& vec )
{
	return HLML_CONSTRUCT( int2x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w
	};
}

bool cmpe( const int3x2& lhs, const int3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const int3x2& lhs, const int3x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int3x2 comp_adds( const int3x2& lhs, const int32_t scalar )
{
	return int3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

int3x2 comp_addm( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_subs( const int3x2& lhs, const int32_t scalar )
{
	return int3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

int3x2 comp_subm( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_muls( const int3x2& lhs, const int32_t scalar )
{
	return int3x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

int3x2 comp_mulm( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_divs( const int3x2& lhs, const int32_t scalar )
{
	return int3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

int3x2 comp_divm( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_and( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_or( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_xor( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_unary( const int3x2& lhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,

		~lhs.rows[1].x,
		~lhs.rows[1].y,

		~lhs.rows[2].x,
		~lhs.rows[2].y

	};
}

int3x2 comp_shift_left( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

int3x2 comp_shift_right( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( int3x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpl( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmple( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpg( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpge( const int3x2& lhs, const int3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( int3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat.rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

int2x3 transpose( const int3x2& mat )
{
	return HLML_CONSTRUCT( int2x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

int3x3 mul( const int3x2& lhs, const int2x3& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];
	int2 row2 = lhs.rows[2];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	int2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool cmpe( const int3x3& lhs, const int3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const int3x3& lhs, const int3x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int3x3 comp_adds( const int3x3& lhs, const int32_t scalar )
{
	return int3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

int3x3 comp_addm( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_subs( const int3x3& lhs, const int32_t scalar )
{
	return int3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

int3x3 comp_subm( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_muls( const int3x3& lhs, const int32_t scalar )
{
	return int3x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

int3x3 comp_mulm( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_divs( const int3x3& lhs, const int32_t scalar )
{
	return int3x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

int3x3 comp_divm( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_and( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_or( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_xor( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_unary( const int3x3& lhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z

	};
}

int3x3 comp_shift_left( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

int3x3 comp_shift_right( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( int3x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpl( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmple( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpg( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpge( const int3x3& lhs, const int3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( int3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
}

int3x3 transpose( const int3x3& mat )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

int32_t determinant( const int3x3& mat )
{
	return
		+ mat.rows[0].x * ( mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z ) 
		- mat.rows[0].y * ( mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z ) 
		+ mat.rows[0].z * ( mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y );
}

int3x3 mul( const int3x3& lhs, const int3x3& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];
	int3 row2 = lhs.rows[2];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	int3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

int3 mul( const int3x3& lhs, const int3& rhs )
{
	return HLML_CONSTRUCT( int3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

int3x3 translate( const int3x3& mat, const int2& vec )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z
	};
}

int3x3 scale( const int3x3& mat, const int2& vec )
{
	return HLML_CONSTRUCT( int3x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z
	};
}

bool cmpe( const int3x4& lhs, const int3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const int3x4& lhs, const int3x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int3x4 comp_adds( const int3x4& lhs, const int32_t scalar )
{
	return int3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

int3x4 comp_addm( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_subs( const int3x4& lhs, const int32_t scalar )
{
	return int3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

int3x4 comp_subm( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_muls( const int3x4& lhs, const int32_t scalar )
{
	return int3x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

int3x4 comp_mulm( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_divs( const int3x4& lhs, const int32_t scalar )
{
	return int3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

int3x4 comp_divm( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_and( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_or( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_xor( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_unary( const int3x4& lhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,
		~lhs.rows[0].w,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,
		~lhs.rows[1].w,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z,
		~lhs.rows[2].w

	};
}

int3x4 comp_shift_left( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

int3x4 comp_shift_right( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( int3x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpl( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmple( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpg( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpge( const int3x4& lhs, const int3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( int3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
}

int4x3 transpose( const int3x4& mat )
{
	return HLML_CONSTRUCT( int4x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

int3x3 mul( const int3x4& lhs, const int4x3& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];
	int4 row2 = lhs.rows[2];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	int4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( int3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

int3x4 translate( const int3x4& mat, const int3& vec )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z
	};
}

int3x4 scale( const int3x4& mat, const int2& vec )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,
		mat.rows[2].w
	};
}

bool cmpe( const int4x2& lhs, const int4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const int4x2& lhs, const int4x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int4x2 comp_adds( const int4x2& lhs, const int32_t scalar )
{
	return int4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

int4x2 comp_addm( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_subs( const int4x2& lhs, const int32_t scalar )
{
	return int4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

int4x2 comp_subm( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_muls( const int4x2& lhs, const int32_t scalar )
{
	return int4x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

int4x2 comp_mulm( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_divs( const int4x2& lhs, const int32_t scalar )
{
	return int4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

int4x2 comp_divm( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_and( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_or( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_xor( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_unary( const int4x2& lhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,

		~lhs.rows[1].x,
		~lhs.rows[1].y,

		~lhs.rows[2].x,
		~lhs.rows[2].y,

		~lhs.rows[3].x,
		~lhs.rows[3].y

	};
}

int4x2 comp_shift_left( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

int4x2 comp_shift_right( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( int4x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpl( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmple( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpg( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpge( const int4x2& lhs, const int4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( int4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int2 ) { 1, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int2 ) { 0, 1 };
	mat.rows[2] = HLML_CONSTRUCT( int2 ) { 0, 0 };
	mat.rows[3] = HLML_CONSTRUCT( int2 ) { 0, 0 };
}

int2x4 transpose( const int4x2& mat )
{
	return HLML_CONSTRUCT( int2x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

int4x4 mul( const int4x2& lhs, const int2x4& rhs )
{
	int2 row0 = lhs.rows[0];
	int2 row1 = lhs.rows[1];
	int2 row2 = lhs.rows[2];
	int2 row3 = lhs.rows[3];

	int2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	int2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	int2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	int2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool cmpe( const int4x3& lhs, const int4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const int4x3& lhs, const int4x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int4x3 comp_adds( const int4x3& lhs, const int32_t scalar )
{
	return int4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

int4x3 comp_addm( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_subs( const int4x3& lhs, const int32_t scalar )
{
	return int4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

int4x3 comp_subm( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_muls( const int4x3& lhs, const int32_t scalar )
{
	return int4x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

int4x3 comp_mulm( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_divs( const int4x3& lhs, const int32_t scalar )
{
	return int4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

int4x3 comp_divm( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_and( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_or( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_xor( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_unary( const int4x3& lhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z,

		~lhs.rows[3].x,
		~lhs.rows[3].y,
		~lhs.rows[3].z

	};
}

int4x3 comp_shift_left( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

int4x3 comp_shift_right( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( int4x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpl( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmple( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpg( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpge( const int4x3& lhs, const int4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( int4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int3 ) { 1, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int3 ) { 0, 1, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int3 ) { 0, 0, 1 };
	mat.rows[3] = HLML_CONSTRUCT( int3 ) { 0, 0, 0 };
}

int3x4 transpose( const int4x3& mat )
{
	return HLML_CONSTRUCT( int3x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

int4x4 mul( const int4x3& lhs, const int3x4& rhs )
{
	int3 row0 = lhs.rows[0];
	int3 row1 = lhs.rows[1];
	int3 row2 = lhs.rows[2];
	int3 row3 = lhs.rows[3];

	int3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	int3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	int3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	int3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

int4x3 scale( const int4x3& mat, const int2& vec )
{
	return HLML_CONSTRUCT( int4x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z
	};
}

bool cmpe( const int4x4& lhs, const int4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const int4x4& lhs, const int4x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

int4x4 comp_adds( const int4x4& lhs, const int32_t scalar )
{
	return int4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

int4x4 comp_addm( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_subs( const int4x4& lhs, const int32_t scalar )
{
	return int4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

int4x4 comp_subm( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_muls( const int4x4& lhs, const int32_t scalar )
{
	return int4x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

int4x4 comp_mulm( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_divs( const int4x4& lhs, const int32_t scalar )
{
	return int4x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

int4x4 comp_divm( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_and( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_or( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_xor( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_unary( const int4x4& lhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,
		~lhs.rows[0].w,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,
		~lhs.rows[1].w,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z,
		~lhs.rows[2].w,

		~lhs.rows[3].x,
		~lhs.rows[3].y,
		~lhs.rows[3].z,
		~lhs.rows[3].w

	};
}

int4x4 comp_shift_left( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

int4x4 comp_shift_right( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( int4x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpl( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmple( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpg( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpge( const int4x4& lhs, const int4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( int4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( int4 ) { 1, 0, 0, 0 };
	mat.rows[1] = HLML_CONSTRUCT( int4 ) { 0, 1, 0, 0 };
	mat.rows[2] = HLML_CONSTRUCT( int4 ) { 0, 0, 1, 0 };
	mat.rows[3] = HLML_CONSTRUCT( int4 ) { 0, 0, 0, 1 };
}

int4x4 transpose( const int4x4& mat )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

int32_t determinant( const int4x4& mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	int32_t sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	int32_t sub01 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	int32_t sub02 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	int32_t sub03 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	int32_t sub04 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	int32_t sub05 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;

	int4 cofactor = HLML_CONSTRUCT( int4 ) {
		 ( ( ( mat.rows[1].y * sub00 ) - ( mat.rows[1].z * sub01 ) ) + ( mat.rows[1].w * sub02 ) ),
		-( ( ( mat.rows[1].x * sub00 ) - ( mat.rows[1].z * sub03 ) ) + ( mat.rows[1].w * sub04 ) ),
		 ( ( ( mat.rows[1].x * sub01 ) - ( mat.rows[1].y * sub03 ) ) + ( mat.rows[1].w * sub05 ) ),
		-( ( ( mat.rows[1].x * sub02 ) - ( mat.rows[1].y * sub04 ) ) + ( mat.rows[1].z * sub05 ) ) 
	};

	return
		mat.rows[0].x * cofactor.x + mat.rows[0].y * cofactor.y +
		mat.rows[0].z * cofactor.z + mat.rows[0].w * cofactor.w; 
}

int4x4 mul( const int4x4& lhs, const int4x4& rhs )
{
	int4 row0 = lhs.rows[0];
	int4 row1 = lhs.rows[1];
	int4 row2 = lhs.rows[2];
	int4 row3 = lhs.rows[3];

	int4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	int4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	int4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	int4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( int4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

int4 mul( const int4x4& lhs, const int4& rhs )
{
	return HLML_CONSTRUCT( int4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

int4x4 translate( const int4x4& mat, const int3& vec )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

int4x4 scale( const int4x4& mat, const int3& vec )
{
	return HLML_CONSTRUCT( int4x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * vec.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

bool cmpe( const uint2x2& lhs, const uint2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const uint2x2& lhs, const uint2x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint2x2 comp_adds( const uint2x2& lhs, const uint32_t scalar )
{
	return uint2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

uint2x2 comp_addm( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_subs( const uint2x2& lhs, const uint32_t scalar )
{
	return uint2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

uint2x2 comp_subm( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_muls( const uint2x2& lhs, const uint32_t scalar )
{
	return uint2x2(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

uint2x2 comp_mulm( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_divs( const uint2x2& lhs, const uint32_t scalar )
{
	return uint2x2(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

uint2x2 comp_divm( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_and( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_or( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_xor( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_unary( const uint2x2& lhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,

		~lhs.rows[1].x,
		~lhs.rows[1].y

	};
}

uint2x2 comp_shift_left( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x2 comp_shift_right( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpl( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmple( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpg( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpge( const uint2x2& lhs, const uint2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( uint2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
}

uint2x2 transpose( const uint2x2& mat )
{
	return HLML_CONSTRUCT( uint2x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

uint2x2 mul( const uint2x2& lhs, const uint2x2& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

uint2 mul( const uint2x2& lhs, const uint2& rhs )
{
	return HLML_CONSTRUCT( uint2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

bool cmpe( const uint2x3& lhs, const uint2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const uint2x3& lhs, const uint2x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint2x3 comp_adds( const uint2x3& lhs, const uint32_t scalar )
{
	return uint2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

uint2x3 comp_addm( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_subs( const uint2x3& lhs, const uint32_t scalar )
{
	return uint2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

uint2x3 comp_subm( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_muls( const uint2x3& lhs, const uint32_t scalar )
{
	return uint2x3(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

uint2x3 comp_mulm( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_divs( const uint2x3& lhs, const uint32_t scalar )
{
	return uint2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

uint2x3 comp_divm( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_and( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_or( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_xor( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_unary( const uint2x3& lhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z

	};
}

uint2x3 comp_shift_left( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x3 comp_shift_right( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpl( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmple( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpg( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpge( const uint2x3& lhs, const uint2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( uint2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
}

uint3x2 transpose( const uint2x3& mat )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

uint2x2 mul( const uint2x3& lhs, const uint3x2& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

uint2x3 scale( const uint2x3& mat, const uint2& vec )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z
	};
}

bool cmpe( const uint2x4& lhs, const uint2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const uint2x4& lhs, const uint2x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint2x4 comp_adds( const uint2x4& lhs, const uint32_t scalar )
{
	return uint2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

uint2x4 comp_addm( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_subs( const uint2x4& lhs, const uint32_t scalar )
{
	return uint2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

uint2x4 comp_subm( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_muls( const uint2x4& lhs, const uint32_t scalar )
{
	return uint2x4(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

uint2x4 comp_mulm( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_divs( const uint2x4& lhs, const uint32_t scalar )
{
	return uint2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

uint2x4 comp_divm( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_and( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_or( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_xor( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_unary( const uint2x4& lhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,
		~lhs.rows[0].w,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,
		~lhs.rows[1].w

	};
}

uint2x4 comp_shift_left( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] )
	};
}

uint2x4 comp_shift_right( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpl( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmple( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpg( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpge( const uint2x4& lhs, const uint2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( uint2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
}

uint4x2 transpose( const uint2x4& mat )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

uint2x2 mul( const uint2x4& lhs, const uint4x2& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( uint2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

uint2x4 scale( const uint2x4& mat, const uint2& vec )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w
	};
}

bool cmpe( const uint3x2& lhs, const uint3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const uint3x2& lhs, const uint3x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint3x2 comp_adds( const uint3x2& lhs, const uint32_t scalar )
{
	return uint3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

uint3x2 comp_addm( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_subs( const uint3x2& lhs, const uint32_t scalar )
{
	return uint3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

uint3x2 comp_subm( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_muls( const uint3x2& lhs, const uint32_t scalar )
{
	return uint3x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

uint3x2 comp_mulm( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_divs( const uint3x2& lhs, const uint32_t scalar )
{
	return uint3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

uint3x2 comp_divm( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_and( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_or( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_xor( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_unary( const uint3x2& lhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,

		~lhs.rows[1].x,
		~lhs.rows[1].y,

		~lhs.rows[2].x,
		~lhs.rows[2].y

	};
}

uint3x2 comp_shift_left( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x2 comp_shift_right( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( uint3x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpl( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmple( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpg( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpge( const uint3x2& lhs, const uint3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( uint3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat.rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

uint2x3 transpose( const uint3x2& mat )
{
	return HLML_CONSTRUCT( uint2x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

uint3x3 mul( const uint3x2& lhs, const uint2x3& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];
	uint2 row2 = lhs.rows[2];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	uint2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool cmpe( const uint3x3& lhs, const uint3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const uint3x3& lhs, const uint3x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint3x3 comp_adds( const uint3x3& lhs, const uint32_t scalar )
{
	return uint3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

uint3x3 comp_addm( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_subs( const uint3x3& lhs, const uint32_t scalar )
{
	return uint3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

uint3x3 comp_subm( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_muls( const uint3x3& lhs, const uint32_t scalar )
{
	return uint3x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

uint3x3 comp_mulm( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_divs( const uint3x3& lhs, const uint32_t scalar )
{
	return uint3x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

uint3x3 comp_divm( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_and( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_or( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_xor( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_unary( const uint3x3& lhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z

	};
}

uint3x3 comp_shift_left( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x3 comp_shift_right( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpl( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmple( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpg( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpge( const uint3x3& lhs, const uint3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( uint3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
}

uint3x3 transpose( const uint3x3& mat )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

uint3x3 mul( const uint3x3& lhs, const uint3x3& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];
	uint3 row2 = lhs.rows[2];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	uint3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

uint3 mul( const uint3x3& lhs, const uint3& rhs )
{
	return HLML_CONSTRUCT( uint3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

uint3x3 translate( const uint3x3& mat, const uint2& vec )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z
	};
}

uint3x3 scale( const uint3x3& mat, const uint2& vec )
{
	return HLML_CONSTRUCT( uint3x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z
	};
}

bool cmpe( const uint3x4& lhs, const uint3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const uint3x4& lhs, const uint3x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint3x4 comp_adds( const uint3x4& lhs, const uint32_t scalar )
{
	return uint3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

uint3x4 comp_addm( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_subs( const uint3x4& lhs, const uint32_t scalar )
{
	return uint3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

uint3x4 comp_subm( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_muls( const uint3x4& lhs, const uint32_t scalar )
{
	return uint3x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

uint3x4 comp_mulm( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_divs( const uint3x4& lhs, const uint32_t scalar )
{
	return uint3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

uint3x4 comp_divm( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_and( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_or( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_xor( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_unary( const uint3x4& lhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,
		~lhs.rows[0].w,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,
		~lhs.rows[1].w,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z,
		~lhs.rows[2].w

	};
}

uint3x4 comp_shift_left( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] )
	};
}

uint3x4 comp_shift_right( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpl( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmple( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpg( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpge( const uint3x4& lhs, const uint3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( uint3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
}

uint4x3 transpose( const uint3x4& mat )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

uint3x3 mul( const uint3x4& lhs, const uint4x3& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];
	uint4 row2 = lhs.rows[2];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	uint4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( uint3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

uint3x4 translate( const uint3x4& mat, const uint3& vec )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z
	};
}

uint3x4 scale( const uint3x4& mat, const uint2& vec )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,
		mat.rows[2].w
	};
}

bool cmpe( const uint4x2& lhs, const uint4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const uint4x2& lhs, const uint4x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint4x2 comp_adds( const uint4x2& lhs, const uint32_t scalar )
{
	return uint4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

uint4x2 comp_addm( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_subs( const uint4x2& lhs, const uint32_t scalar )
{
	return uint4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

uint4x2 comp_subm( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_muls( const uint4x2& lhs, const uint32_t scalar )
{
	return uint4x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

uint4x2 comp_mulm( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_divs( const uint4x2& lhs, const uint32_t scalar )
{
	return uint4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

uint4x2 comp_divm( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_and( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_or( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_xor( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_unary( const uint4x2& lhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,

		~lhs.rows[1].x,
		~lhs.rows[1].y,

		~lhs.rows[2].x,
		~lhs.rows[2].y,

		~lhs.rows[3].x,
		~lhs.rows[3].y

	};
}

uint4x2 comp_shift_left( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x2 comp_shift_right( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( uint4x2 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpl( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmple( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpg( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpge( const uint4x2& lhs, const uint4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( uint4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint2 ) { 1U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint2 ) { 0U, 1U };
	mat.rows[2] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
	mat.rows[3] = HLML_CONSTRUCT( uint2 ) { 0U, 0U };
}

uint2x4 transpose( const uint4x2& mat )
{
	return HLML_CONSTRUCT( uint2x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

uint4x4 mul( const uint4x2& lhs, const uint2x4& rhs )
{
	uint2 row0 = lhs.rows[0];
	uint2 row1 = lhs.rows[1];
	uint2 row2 = lhs.rows[2];
	uint2 row3 = lhs.rows[3];

	uint2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	uint2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	uint2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	uint2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool cmpe( const uint4x3& lhs, const uint4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const uint4x3& lhs, const uint4x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint4x3 comp_adds( const uint4x3& lhs, const uint32_t scalar )
{
	return uint4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

uint4x3 comp_addm( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_subs( const uint4x3& lhs, const uint32_t scalar )
{
	return uint4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

uint4x3 comp_subm( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_muls( const uint4x3& lhs, const uint32_t scalar )
{
	return uint4x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

uint4x3 comp_mulm( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_divs( const uint4x3& lhs, const uint32_t scalar )
{
	return uint4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

uint4x3 comp_divm( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_and( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_or( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_xor( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_unary( const uint4x3& lhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z,

		~lhs.rows[3].x,
		~lhs.rows[3].y,
		~lhs.rows[3].z

	};
}

uint4x3 comp_shift_left( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x3 comp_shift_right( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpl( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmple( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpg( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpge( const uint4x3& lhs, const uint4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( uint4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint3 ) { 1U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint3 ) { 0U, 1U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 1U };
	mat.rows[3] = HLML_CONSTRUCT( uint3 ) { 0U, 0U, 0U };
}

uint3x4 transpose( const uint4x3& mat )
{
	return HLML_CONSTRUCT( uint3x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

uint4x4 mul( const uint4x3& lhs, const uint3x4& rhs )
{
	uint3 row0 = lhs.rows[0];
	uint3 row1 = lhs.rows[1];
	uint3 row2 = lhs.rows[2];
	uint3 row3 = lhs.rows[3];

	uint3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	uint3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	uint3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	uint3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

uint4x3 scale( const uint4x3& mat, const uint2& vec )
{
	return HLML_CONSTRUCT( uint4x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z
	};
}

bool cmpe( const uint4x4& lhs, const uint4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const uint4x4& lhs, const uint4x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

uint4x4 comp_adds( const uint4x4& lhs, const uint32_t scalar )
{
	return uint4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

uint4x4 comp_addm( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_subs( const uint4x4& lhs, const uint32_t scalar )
{
	return uint4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

uint4x4 comp_subm( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_muls( const uint4x4& lhs, const uint32_t scalar )
{
	return uint4x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

uint4x4 comp_mulm( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_divs( const uint4x4& lhs, const uint32_t scalar )
{
	return uint4x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

uint4x4 comp_divm( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_and( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_and( lhs.rows[0], rhs.rows[0] ),
		comp_and( lhs.rows[1], rhs.rows[1] ),
		comp_and( lhs.rows[2], rhs.rows[2] ),
		comp_and( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_or( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_or( lhs.rows[0], rhs.rows[0] ),
		comp_or( lhs.rows[1], rhs.rows[1] ),
		comp_or( lhs.rows[2], rhs.rows[2] ),
		comp_or( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_xor( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_xor( lhs.rows[0], rhs.rows[0] ),
		comp_xor( lhs.rows[1], rhs.rows[1] ),
		comp_xor( lhs.rows[2], rhs.rows[2] ),
		comp_xor( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_unary( const uint4x4& lhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		~lhs.rows[0].x,
		~lhs.rows[0].y,
		~lhs.rows[0].z,
		~lhs.rows[0].w,

		~lhs.rows[1].x,
		~lhs.rows[1].y,
		~lhs.rows[1].z,
		~lhs.rows[1].w,

		~lhs.rows[2].x,
		~lhs.rows[2].y,
		~lhs.rows[2].z,
		~lhs.rows[2].w,

		~lhs.rows[3].x,
		~lhs.rows[3].y,
		~lhs.rows[3].z,
		~lhs.rows[3].w

	};
}

uint4x4 comp_shift_left( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_shift_left( lhs.rows[0], rhs.rows[0] ),
		comp_shift_left( lhs.rows[1], rhs.rows[1] ),
		comp_shift_left( lhs.rows[2], rhs.rows[2] ),
		comp_shift_left( lhs.rows[3], rhs.rows[3] )
	};
}

uint4x4 comp_shift_right( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		comp_shift_right( lhs.rows[0], rhs.rows[0] ),
		comp_shift_right( lhs.rows[1], rhs.rows[1] ),
		comp_shift_right( lhs.rows[2], rhs.rows[2] ),
		comp_shift_right( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpl( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmple( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpg( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpge( const uint4x4& lhs, const uint4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( uint4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( uint4 ) { 1U, 0U, 0U, 0U };
	mat.rows[1] = HLML_CONSTRUCT( uint4 ) { 0U, 1U, 0U, 0U };
	mat.rows[2] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 1U, 0U };
	mat.rows[3] = HLML_CONSTRUCT( uint4 ) { 0U, 0U, 0U, 1U };
}

uint4x4 transpose( const uint4x4& mat )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

uint4x4 mul( const uint4x4& lhs, const uint4x4& rhs )
{
	uint4 row0 = lhs.rows[0];
	uint4 row1 = lhs.rows[1];
	uint4 row2 = lhs.rows[2];
	uint4 row3 = lhs.rows[3];

	uint4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	uint4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	uint4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	uint4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( uint4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

uint4 mul( const uint4x4& lhs, const uint4& rhs )
{
	return HLML_CONSTRUCT( uint4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

uint4x4 translate( const uint4x4& mat, const uint3& vec )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

uint4x4 scale( const uint4x4& mat, const uint3& vec )
{
	return HLML_CONSTRUCT( uint4x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * vec.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

bool cmpe( const float2x2& lhs, const float2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const float2x2& lhs, const float2x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float2x2 comp_adds( const float2x2& lhs, const float scalar )
{
	return float2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

float2x2 comp_addm( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x2 comp_subs( const float2x2& lhs, const float scalar )
{
	return float2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

float2x2 comp_subm( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x2 comp_muls( const float2x2& lhs, const float scalar )
{
	return float2x2(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

float2x2 comp_mulm( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x2 comp_divs( const float2x2& lhs, const float scalar )
{
	return float2x2(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

float2x2 comp_divm( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( float2x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpl( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmple( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpg( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpge( const float2x2& lhs, const float2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( float2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
}

float2x2 transpose( const float2x2& mat )
{
	return HLML_CONSTRUCT( float2x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

float determinant( const float2x2& mat )
{
	return mat.rows[0].x * mat.rows[1].y - mat.rows[1].x * mat.rows[0].y;
}

float2x2 inverse( const float2x2& mat )
{
	const float invdet = 1.0f / determinant( mat );
	return HLML_CONSTRUCT( float2x2 ) {
		 mat.rows[1].y * invdet, -mat.rows[0].y * invdet,
		-mat.rows[1].x * invdet,  mat.rows[0].x * invdet
	};
}

float2x2 mul( const float2x2& lhs, const float2x2& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

float2 mul( const float2x2& lhs, const float2& rhs )
{
	return HLML_CONSTRUCT( float2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

bool cmpe( const float2x3& lhs, const float2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const float2x3& lhs, const float2x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float2x3 comp_adds( const float2x3& lhs, const float scalar )
{
	return float2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

float2x3 comp_addm( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x3 comp_subs( const float2x3& lhs, const float scalar )
{
	return float2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

float2x3 comp_subm( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x3 comp_muls( const float2x3& lhs, const float scalar )
{
	return float2x3(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

float2x3 comp_mulm( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x3 comp_divs( const float2x3& lhs, const float scalar )
{
	return float2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

float2x3 comp_divm( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( float2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpl( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmple( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpg( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpge( const float2x3& lhs, const float2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( float2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
}

float3x2 transpose( const float2x3& mat )
{
	return HLML_CONSTRUCT( float3x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

float2x2 mul( const float2x3& lhs, const float3x2& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

float2x3 scale( const float2x3& mat, const float2& vec )
{
	return HLML_CONSTRUCT( float2x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z
	};
}

bool cmpe( const float2x4& lhs, const float2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const float2x4& lhs, const float2x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float2x4 comp_adds( const float2x4& lhs, const float scalar )
{
	return float2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

float2x4 comp_addm( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x4 comp_subs( const float2x4& lhs, const float scalar )
{
	return float2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

float2x4 comp_subm( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x4 comp_muls( const float2x4& lhs, const float scalar )
{
	return float2x4(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

float2x4 comp_mulm( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

float2x4 comp_divs( const float2x4& lhs, const float scalar )
{
	return float2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

float2x4 comp_divm( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( float2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpl( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmple( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpg( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpge( const float2x4& lhs, const float2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( float2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
}

float4x2 transpose( const float2x4& mat )
{
	return HLML_CONSTRUCT( float4x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

float2x2 mul( const float2x4& lhs, const float4x2& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( float2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

float2x4 scale( const float2x4& mat, const float2& vec )
{
	return HLML_CONSTRUCT( float2x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w
	};
}

bool cmpe( const float3x2& lhs, const float3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const float3x2& lhs, const float3x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float3x2 comp_adds( const float3x2& lhs, const float scalar )
{
	return float3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

float3x2 comp_addm( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x2 comp_subs( const float3x2& lhs, const float scalar )
{
	return float3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

float3x2 comp_subm( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x2 comp_muls( const float3x2& lhs, const float scalar )
{
	return float3x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

float3x2 comp_mulm( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x2 comp_divs( const float3x2& lhs, const float scalar )
{
	return float3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

float3x2 comp_divm( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( float3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpl( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmple( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpg( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpge( const float3x2& lhs, const float3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( float3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat.rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

float2x3 transpose( const float3x2& mat )
{
	return HLML_CONSTRUCT( float2x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

float3x3 mul( const float3x2& lhs, const float2x3& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];
	float2 row2 = lhs.rows[2];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	float2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool cmpe( const float3x3& lhs, const float3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const float3x3& lhs, const float3x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float3x3 comp_adds( const float3x3& lhs, const float scalar )
{
	return float3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

float3x3 comp_addm( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x3 comp_subs( const float3x3& lhs, const float scalar )
{
	return float3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

float3x3 comp_subm( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x3 comp_muls( const float3x3& lhs, const float scalar )
{
	return float3x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

float3x3 comp_mulm( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x3 comp_divs( const float3x3& lhs, const float scalar )
{
	return float3x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

float3x3 comp_divm( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( float3x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpl( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmple( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpg( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpge( const float3x3& lhs, const float3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( float3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
}

float3x3 transpose( const float3x3& mat )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

float determinant( const float3x3& mat )
{
	return
		+ mat.rows[0].x * ( mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z ) 
		- mat.rows[0].y * ( mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z ) 
		+ mat.rows[0].z * ( mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y );
}

float3x3 inverse( const float3x3& mat )
{
	const float invdet = 1.0f / determinant( mat );
	return HLML_CONSTRUCT( float3x3 ) {
		 ( mat.rows[1].y * mat.rows[2].z - mat.rows[1].z * mat.rows[2].y ) * invdet,
		-( mat.rows[0].y * mat.rows[2].z - mat.rows[0].z * mat.rows[2].y ) * invdet,
		 ( mat.rows[0].y * mat.rows[1].z - mat.rows[0].z * mat.rows[1].y ) * invdet,

		-( mat.rows[1].x * mat.rows[2].z - mat.rows[1].z * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[2].z - mat.rows[0].z * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[1].z - mat.rows[0].z * mat.rows[1].x ) * invdet,

		 ( mat.rows[1].x * mat.rows[2].y - mat.rows[1].y * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[2].y - mat.rows[0].y * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[1].y - mat.rows[0].y * mat.rows[1].x ) * invdet
	};
}

float3x3 mul( const float3x3& lhs, const float3x3& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];
	float3 row2 = lhs.rows[2];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	float3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

float3 mul( const float3x3& lhs, const float3& rhs )
{
	return HLML_CONSTRUCT( float3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

float3x3 translate( const float3x3& mat, const float2& vec )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z
	};
}

float3x3 rotate( const float3x3& mat, const float rad )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 row0_cos  = comp_muls( mat.rows[0], c );
	float3 row0_sin  = comp_muls( mat.rows[0], s );
	float3 row1_nsin = comp_muls( mat.rows[1], -s );
	float3 row1_cos  = comp_muls( mat.rows[1], c );

	return HLML_CONSTRUCT( float3x3 ) {
		comp_addv( row0_cos, row1_nsin ),
		comp_addv( row0_sin, row1_cos  ),
		mat.rows[2]
	};
}

float3x3 scale( const float3x3& mat, const float2& vec )
{
	return HLML_CONSTRUCT( float3x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z
	};
}

bool cmpe( const float3x4& lhs, const float3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const float3x4& lhs, const float3x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float3x4 comp_adds( const float3x4& lhs, const float scalar )
{
	return float3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

float3x4 comp_addm( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x4 comp_subs( const float3x4& lhs, const float scalar )
{
	return float3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

float3x4 comp_subm( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x4 comp_muls( const float3x4& lhs, const float scalar )
{
	return float3x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

float3x4 comp_mulm( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

float3x4 comp_divs( const float3x4& lhs, const float scalar )
{
	return float3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

float3x4 comp_divm( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( float3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpl( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmple( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpg( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpge( const float3x4& lhs, const float3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( float3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
}

float4x3 transpose( const float3x4& mat )
{
	return HLML_CONSTRUCT( float4x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

float3x3 mul( const float3x4& lhs, const float4x3& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];
	float4 row2 = lhs.rows[2];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	float4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( float3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

float3x4 translate( const float3x4& mat, const float3& vec )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z
	};
}

float3x4 scale( const float3x4& mat, const float2& vec )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,
		mat.rows[2].w
	};
}

bool cmpe( const float4x2& lhs, const float4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const float4x2& lhs, const float4x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float4x2 comp_adds( const float4x2& lhs, const float scalar )
{
	return float4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

float4x2 comp_addm( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x2 comp_subs( const float4x2& lhs, const float scalar )
{
	return float4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

float4x2 comp_subm( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x2 comp_muls( const float4x2& lhs, const float scalar )
{
	return float4x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

float4x2 comp_mulm( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x2 comp_divs( const float4x2& lhs, const float scalar )
{
	return float4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

float4x2 comp_divm( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( float4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpl( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmple( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpg( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpge( const float4x2& lhs, const float4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( float4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float2 ) { 1.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float2 ) { 0.0f, 1.0f };
	mat.rows[2] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
	mat.rows[3] = HLML_CONSTRUCT( float2 ) { 0.0f, 0.0f };
}

float2x4 transpose( const float4x2& mat )
{
	return HLML_CONSTRUCT( float2x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

float4x4 mul( const float4x2& lhs, const float2x4& rhs )
{
	float2 row0 = lhs.rows[0];
	float2 row1 = lhs.rows[1];
	float2 row2 = lhs.rows[2];
	float2 row3 = lhs.rows[3];

	float2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	float2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	float2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	float2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool cmpe( const float4x3& lhs, const float4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const float4x3& lhs, const float4x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float4x3 comp_adds( const float4x3& lhs, const float scalar )
{
	return float4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

float4x3 comp_addm( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x3 comp_subs( const float4x3& lhs, const float scalar )
{
	return float4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

float4x3 comp_subm( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x3 comp_muls( const float4x3& lhs, const float scalar )
{
	return float4x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

float4x3 comp_mulm( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x3 comp_divs( const float4x3& lhs, const float scalar )
{
	return float4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

float4x3 comp_divm( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( float4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpl( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmple( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpg( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpge( const float4x3& lhs, const float4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( float4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float3 ) { 1.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float3 ) { 0.0f, 1.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 1.0f };
	mat.rows[3] = HLML_CONSTRUCT( float3 ) { 0.0f, 0.0f, 0.0f };
}

float3x4 transpose( const float4x3& mat )
{
	return HLML_CONSTRUCT( float3x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

float4x4 mul( const float4x3& lhs, const float3x4& rhs )
{
	float3 row0 = lhs.rows[0];
	float3 row1 = lhs.rows[1];
	float3 row2 = lhs.rows[2];
	float3 row3 = lhs.rows[3];

	float3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	float3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	float3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	float3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

float4x3 scale( const float4x3& mat, const float2& vec )
{
	return HLML_CONSTRUCT( float4x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z
	};
}

bool cmpe( const float4x4& lhs, const float4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const float4x4& lhs, const float4x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

float4x4 comp_adds( const float4x4& lhs, const float scalar )
{
	return float4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

float4x4 comp_addm( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x4 comp_subs( const float4x4& lhs, const float scalar )
{
	return float4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

float4x4 comp_subm( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x4 comp_muls( const float4x4& lhs, const float scalar )
{
	return float4x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

float4x4 comp_mulm( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

float4x4 comp_divs( const float4x4& lhs, const float scalar )
{
	return float4x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

float4x4 comp_divm( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( float4x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpl( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmple( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpg( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpge( const float4x4& lhs, const float4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( float4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( float4 ) { 1.0f, 0.0f, 0.0f, 0.0f };
	mat.rows[1] = HLML_CONSTRUCT( float4 ) { 0.0f, 1.0f, 0.0f, 0.0f };
	mat.rows[2] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 1.0f, 0.0f };
	mat.rows[3] = HLML_CONSTRUCT( float4 ) { 0.0f, 0.0f, 0.0f, 1.0f };
}

float4x4 transpose( const float4x4& mat )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

float determinant( const float4x4& mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	float sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	float sub01 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	float sub02 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	float sub03 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	float sub04 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	float sub05 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;

	float4 cofactor = HLML_CONSTRUCT( float4 ) {
		 ( ( ( mat.rows[1].y * sub00 ) - ( mat.rows[1].z * sub01 ) ) + ( mat.rows[1].w * sub02 ) ),
		-( ( ( mat.rows[1].x * sub00 ) - ( mat.rows[1].z * sub03 ) ) + ( mat.rows[1].w * sub04 ) ),
		 ( ( ( mat.rows[1].x * sub01 ) - ( mat.rows[1].y * sub03 ) ) + ( mat.rows[1].w * sub05 ) ),
		-( ( ( mat.rows[1].x * sub02 ) - ( mat.rows[1].y * sub04 ) ) + ( mat.rows[1].z * sub05 ) ) 
	};

	return
		mat.rows[0].x * cofactor.x + mat.rows[0].y * cofactor.y +
		mat.rows[0].z * cofactor.z + mat.rows[0].w * cofactor.w; 
}

float4x4 inverse( const float4x4& mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	float sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	float sub01 = mat.rows[1].z * mat.rows[3].w - mat.rows[1].w * mat.rows[2].w;
	float sub02 = mat.rows[1].z * mat.rows[2].w - mat.rows[1].w * mat.rows[2].z;

	float sub03 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	float sub04 = mat.rows[1].y * mat.rows[3].w - mat.rows[1].w * mat.rows[3].y;
	float sub05 = mat.rows[1].y * mat.rows[2].w - mat.rows[1].w * mat.rows[2].y;

	float sub06 = mat.rows[2].y * mat.rows[3].z - mat.rows[2].z * mat.rows[3].y;
	float sub07 = mat.rows[1].y * mat.rows[3].z - mat.rows[1].z * mat.rows[3].y;
	float sub08 = mat.rows[1].y * mat.rows[2].z - mat.rows[1].z * mat.rows[2].y;

	float sub09 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	float sub10 = mat.rows[1].x * mat.rows[3].w - mat.rows[3].x * mat.rows[1].w;
	float sub11 = mat.rows[1].x * mat.rows[2].w - mat.rows[2].x * mat.rows[1].w;

	float sub12 = mat.rows[2].x * mat.rows[3].z - mat.rows[2].z * mat.rows[3].x;
	float sub13 = mat.rows[1].x * mat.rows[3].z - mat.rows[1].z * mat.rows[3].x;
	float sub14 = mat.rows[1].x * mat.rows[2].z - mat.rows[1].z * mat.rows[2].x;

	float sub15 = mat.rows[2].x * mat.rows[3].y - mat.rows[2].y * mat.rows[3].x;
	float sub16 = mat.rows[1].x * mat.rows[3].y - mat.rows[1].y * mat.rows[3].x;
	float sub17 = mat.rows[1].x * mat.rows[2].y - mat.rows[1].y * mat.rows[2].x;

	float4 fac0 = float4( sub00, sub00, sub01, sub02 );
	float4 fac1 = float4( sub03, sub03, sub04, sub05 );
	float4 fac2 = float4( sub06, sub06, sub07, sub08 );
	float4 fac3 = float4( sub09, sub09, sub10, sub11 );
	float4 fac4 = float4( sub12, sub12, sub13, sub14 );
	float4 fac5 = float4( sub15, sub15, sub16, sub17 );

	float4 vec0 = float4( mat.rows[1].x, mat.rows[0].x, mat.rows[0].x, mat.rows[0].x );
	float4 vec1 = float4( mat.rows[1].y, mat.rows[0].y, mat.rows[0].y, mat.rows[0].y );
	float4 vec2 = float4( mat.rows[1].z, mat.rows[0].z, mat.rows[0].z, mat.rows[0].z );
	float4 vec3 = float4( mat.rows[1].w, mat.rows[0].w, mat.rows[0].w, mat.rows[0].w );

	float4 inv0 = vec1 * fac0 - vec2 * fac1 + vec3 * fac2;
	float4 inv1 = vec0 * fac0 - vec2 * fac3 + vec3 * fac4;
	float4 inv2 = vec0 * fac1 - vec1 * fac3 + vec3 * fac5;
	float4 inv3 = vec0 * fac2 - vec1 * fac4 + vec2 * fac5;

	float4 sign0 = float4(  1, -1,  1, -1 );
	float4 sign1 = float4( -1,  1, -1,  1 );

	float4x4 result = float4x4(
		inv0 * sign0,
		inv1 * sign1,
		inv2 * sign0,
		inv3 * sign1
	);

	float4 col0 = float4( result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x );
	float4 dot0 = mat.rows[0] * col0;

	const float dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const float invdet = 1.0f / dot1;

	return comp_muls( result, invdet );
}

float4x4 mul( const float4x4& lhs, const float4x4& rhs )
{
	float4 row0 = lhs.rows[0];
	float4 row1 = lhs.rows[1];
	float4 row2 = lhs.rows[2];
	float4 row3 = lhs.rows[3];

	float4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	float4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	float4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	float4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( float4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

float4 mul( const float4x4& lhs, const float4& rhs )
{
	return HLML_CONSTRUCT( float4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

float4x4 translate( const float4x4& mat, const float3& vec )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

float4x4 rotate( const float4x4& mat, const float rad, const float3& axis )
{
	const float c = cosf( rad );
	const float s = sinf( rad );

	float3 u = normalized( axis );
	float ic = 1.0f - c;

	float4x4 rotation = mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return mul( mat, rotation );
}

float4x4 scale( const float4x4& mat, const float3& vec )
{
	return HLML_CONSTRUCT( float4x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * vec.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

float4x4 ortho_lh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip-space range: zero to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 ortho_lh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// left-handed, clip-space range: minus-one to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, 2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 ortho_rh_zo( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip-space range: zero to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -1.0f / far_minus_near, -znear / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 ortho_rh_no( const float left, const float right, const float top, const float bottom, const float znear, const float zfar )
{
	// right-handed, clip-space range: minus-one to one
	const float right_minus_left = right - left;
	const float right_plus_left = right + left;
	const float top_minus_bottom = top - bottom;
	const float top_plus_bottom = top + bottom;
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( float4x4 ) {
		2.0f / right_minus_left, 0.0f, 0.0f, -right_plus_left / right_minus_left,
		0.0f, 2.0f / top_minus_bottom, 0.0f, -top_plus_bottom / top_minus_bottom,
		0.0f, 0.0f, -2.0f / far_minus_near, -far_plus_near / far_minus_near,
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 perspective_lh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: zero to one
	const float far_minus_near = zfar - znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

float4x4 perspective_lh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// left-handed, clip space range: minus-one to one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, 1.0f, 0.0f
	};
}

float4x4 perspective_rh_zo( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: zero to one
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

float4x4 perspective_rh_no( const float fovdeg, const float aspect, const float znear, const float zfar )
{
	// right-handed, clip space range: minus-one to one
	const float far_minus_near = zfar - znear;
	const float far_plus_near = zfar + znear;
	const float tan_half_fov = tanf( fovdeg * 0.5f );

	return HLML_CONSTRUCT( float4x4 ) {
		1.0f / ( aspect * tan_half_fov ), 0.0f, 0.0f, 0.0f,
		0.0f, 1.0f / tan_half_fov, 0.0f, 0.0f,
		0.0f, 0.0f, -far_plus_near / far_minus_near, -( 2.0f * zfar * znear ) / far_minus_near,
		0.0f, 0.0f, -1.0f, 0.0f
	};
}

float4x4 lookat_lh( const float3& eye, const float3& target, const float3& up )
{
	// left handed
	const float3 forward = normalized( target - eye );
	const float3 right = normalized( cross( up, forward ) );
	const float3 up1 = cross( forward, right );

	return HLML_CONSTRUCT( float4x4 ) {
		right.x,   right.y,   right.z,   -dot( right, eye ),
		up1.x,     up1.y,     up1.z,     -dot( up1, eye ),
		forward.x, forward.y, forward.z, -dot( forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

float4x4 lookat_rh( const float3& eye, const float3& target, const float3& up )
{
	// right handed
	const float3 forward = normalized( target - eye );
	const float3 right = normalized( cross( forward, up ) );
	const float3 up1 = cross( right, forward );

	return HLML_CONSTRUCT( float4x4 ) {
		 right.x,    right.y,    right.z,   -dot( right, eye ),
		 up1.x,      up1.y,      up1.z,     -dot( up1, eye ),
		-forward.x, -forward.y, -forward.z,  dot( forward, eye ),
		0.0f, 0.0f, 0.0f, 1.0f
	};
}

bool cmpe( const double2x2& lhs, const double2x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const double2x2& lhs, const double2x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double2x2 comp_adds( const double2x2& lhs, const double scalar )
{
	return double2x2(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

double2x2 comp_addm( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x2 comp_subs( const double2x2& lhs, const double scalar )
{
	return double2x2(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

double2x2 comp_subm( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x2 comp_muls( const double2x2& lhs, const double scalar )
{
	return double2x2(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

double2x2 comp_mulm( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x2 comp_divs( const double2x2& lhs, const double scalar )
{
	return double2x2(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

double2x2 comp_divm( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( double2x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpl( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmple( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpg( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x2 cmpge( const double2x2& lhs, const double2x2& rhs )
{
	return HLML_CONSTRUCT( bool2x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( double2x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
}

double2x2 transpose( const double2x2& mat )
{
	return HLML_CONSTRUCT( double2x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y
	};
}

double determinant( const double2x2& mat )
{
	return mat.rows[0].x * mat.rows[1].y - mat.rows[1].x * mat.rows[0].y;
}

double2x2 inverse( const double2x2& mat )
{
	const double invdet = 1.0 / determinant( mat );
	return HLML_CONSTRUCT( double2x2 ) {
		 mat.rows[1].y * invdet, -mat.rows[0].y * invdet,
		-mat.rows[1].x * invdet,  mat.rows[0].x * invdet
	};
}

double2x2 mul( const double2x2& lhs, const double2x2& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y
	};
}

double2 mul( const double2x2& lhs, const double2& rhs )
{
	return HLML_CONSTRUCT( double2 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y
	};
}

bool cmpe( const double2x3& lhs, const double2x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const double2x3& lhs, const double2x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double2x3 comp_adds( const double2x3& lhs, const double scalar )
{
	return double2x3(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

double2x3 comp_addm( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x3 comp_subs( const double2x3& lhs, const double scalar )
{
	return double2x3(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

double2x3 comp_subm( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x3 comp_muls( const double2x3& lhs, const double scalar )
{
	return double2x3(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

double2x3 comp_mulm( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x3 comp_divs( const double2x3& lhs, const double scalar )
{
	return double2x3(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

double2x3 comp_divm( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( double2x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpl( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmple( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpg( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x3 cmpge( const double2x3& lhs, const double2x3& rhs )
{
	return HLML_CONSTRUCT( bool2x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( double2x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
}

double3x2 transpose( const double2x3& mat )
{
	return HLML_CONSTRUCT( double3x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z
	};
}

double2x2 mul( const double2x3& lhs, const double3x2& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z
	};
}

double2x3 scale( const double2x3& mat, const double2& vec )
{
	return HLML_CONSTRUCT( double2x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z
	};
}

bool cmpe( const double2x4& lhs, const double2x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] );
}

bool cmpne( const double2x4& lhs, const double2x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double2x4 comp_adds( const double2x4& lhs, const double scalar )
{
	return double2x4(
		lhs[0] + scalar,
		lhs[1] + scalar
	);
}

double2x4 comp_addm( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x4 comp_subs( const double2x4& lhs, const double scalar )
{
	return double2x4(
		lhs[0] - scalar,
		lhs[1] - scalar
	);
}

double2x4 comp_subm( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x4 comp_muls( const double2x4& lhs, const double scalar )
{
	return double2x4(
		lhs[0] * scalar,
		lhs[1] * scalar
	);
}

double2x4 comp_mulm( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] )
	};
}

double2x4 comp_divs( const double2x4& lhs, const double scalar )
{
	return double2x4(
		lhs[0] / scalar,
		lhs[1] / scalar
	);
}

double2x4 comp_divm( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( double2x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpl( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmple( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpg( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] )
	};
}

bool2x4 cmpge( const double2x4& lhs, const double2x4& rhs )
{
	return HLML_CONSTRUCT( bool2x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] )
	};
}

void identity( double2x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
}

double4x2 transpose( const double2x4& mat )
{
	return HLML_CONSTRUCT( double4x2 ) {
		mat.rows[0].x, mat.rows[1].x,
		mat.rows[0].y, mat.rows[1].y,
		mat.rows[0].z, mat.rows[1].z,
		mat.rows[0].w, mat.rows[1].w
	};
}

double2x2 mul( const double2x4& lhs, const double4x2& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };

	return HLML_CONSTRUCT( double2x2 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w
	};
}

double2x4 scale( const double2x4& mat, const double2& vec )
{
	return HLML_CONSTRUCT( double2x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w
	};
}

bool cmpe( const double3x2& lhs, const double3x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const double3x2& lhs, const double3x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double3x2 comp_adds( const double3x2& lhs, const double scalar )
{
	return double3x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

double3x2 comp_addm( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x2 comp_subs( const double3x2& lhs, const double scalar )
{
	return double3x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

double3x2 comp_subm( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x2 comp_muls( const double3x2& lhs, const double scalar )
{
	return double3x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

double3x2 comp_mulm( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x2 comp_divs( const double3x2& lhs, const double scalar )
{
	return double3x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

double3x2 comp_divm( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( double3x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpl( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmple( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpg( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x2 cmpge( const double3x2& lhs, const double3x2& rhs )
{
	return HLML_CONSTRUCT( bool3x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( double3x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat.rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

double2x3 transpose( const double3x2& mat )
{
	return HLML_CONSTRUCT( double2x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y
	};
}

double3x3 mul( const double3x2& lhs, const double2x3& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];
	double2 row2 = lhs.rows[2];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	double2 col2 = { rhs.rows[0].z, rhs.rows[1].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y
	};
}

bool cmpe( const double3x3& lhs, const double3x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const double3x3& lhs, const double3x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double3x3 comp_adds( const double3x3& lhs, const double scalar )
{
	return double3x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

double3x3 comp_addm( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x3 comp_subs( const double3x3& lhs, const double scalar )
{
	return double3x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

double3x3 comp_subm( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x3 comp_muls( const double3x3& lhs, const double scalar )
{
	return double3x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

double3x3 comp_mulm( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x3 comp_divs( const double3x3& lhs, const double scalar )
{
	return double3x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

double3x3 comp_divm( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( double3x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpl( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmple( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpg( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x3 cmpge( const double3x3& lhs, const double3x3& rhs )
{
	return HLML_CONSTRUCT( bool3x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( double3x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
}

double3x3 transpose( const double3x3& mat )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z
	};
}

double determinant( const double3x3& mat )
{
	return
		+ mat.rows[0].x * ( mat.rows[1].y * mat.rows[2].z - mat.rows[2].y * mat.rows[1].z ) 
		- mat.rows[0].y * ( mat.rows[1].x * mat.rows[2].z - mat.rows[2].x * mat.rows[1].z ) 
		+ mat.rows[0].z * ( mat.rows[1].x * mat.rows[2].y - mat.rows[2].x * mat.rows[1].y );
}

double3x3 inverse( const double3x3& mat )
{
	const double invdet = 1.0 / determinant( mat );
	return HLML_CONSTRUCT( double3x3 ) {
		 ( mat.rows[1].y * mat.rows[2].z - mat.rows[1].z * mat.rows[2].y ) * invdet,
		-( mat.rows[0].y * mat.rows[2].z - mat.rows[0].z * mat.rows[2].y ) * invdet,
		 ( mat.rows[0].y * mat.rows[1].z - mat.rows[0].z * mat.rows[1].y ) * invdet,

		-( mat.rows[1].x * mat.rows[2].z - mat.rows[1].z * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[2].z - mat.rows[0].z * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[1].z - mat.rows[0].z * mat.rows[1].x ) * invdet,

		 ( mat.rows[1].x * mat.rows[2].y - mat.rows[1].y * mat.rows[2].x ) * invdet,
		-( mat.rows[0].x * mat.rows[2].y - mat.rows[0].y * mat.rows[2].x ) * invdet,
		 ( mat.rows[0].x * mat.rows[1].y - mat.rows[0].y * mat.rows[1].x ) * invdet
	};
}

double3x3 mul( const double3x3& lhs, const double3x3& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];
	double3 row2 = lhs.rows[2];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	double3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z
	};
}

double3 mul( const double3x3& lhs, const double3& rhs )
{
	return HLML_CONSTRUCT( double3 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z
	};
}

double3x3 translate( const double3x3& mat, const double2& vec )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z
	};
}

double3x3 rotate( const double3x3& mat, const double rad )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 row0_cos  = comp_muls( mat.rows[0], c );
	double3 row0_sin  = comp_muls( mat.rows[0], s );
	double3 row1_nsin = comp_muls( mat.rows[1], -s );
	double3 row1_cos  = comp_muls( mat.rows[1], c );

	return HLML_CONSTRUCT( double3x3 ) {
		comp_addv( row0_cos, row1_nsin ),
		comp_addv( row0_sin, row1_cos  ),
		mat.rows[2]
	};
}

double3x3 scale( const double3x3& mat, const double2& vec )
{
	return HLML_CONSTRUCT( double3x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z
	};
}

bool cmpe( const double3x4& lhs, const double3x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] );
}

bool cmpne( const double3x4& lhs, const double3x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double3x4 comp_adds( const double3x4& lhs, const double scalar )
{
	return double3x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar
	);
}

double3x4 comp_addm( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x4 comp_subs( const double3x4& lhs, const double scalar )
{
	return double3x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar
	);
}

double3x4 comp_subm( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x4 comp_muls( const double3x4& lhs, const double scalar )
{
	return double3x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar
	);
}

double3x4 comp_mulm( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] )
	};
}

double3x4 comp_divs( const double3x4& lhs, const double scalar )
{
	return double3x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar
	);
}

double3x4 comp_divm( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( double3x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpl( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmple( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpg( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] )
	};
}

bool3x4 cmpge( const double3x4& lhs, const double3x4& rhs )
{
	return HLML_CONSTRUCT( bool3x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] )
	};
}

void identity( double3x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
}

double4x3 transpose( const double3x4& mat )
{
	return HLML_CONSTRUCT( double4x3 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w
	};
}

double3x3 mul( const double3x4& lhs, const double4x3& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];
	double4 row2 = lhs.rows[2];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	double4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };

	return HLML_CONSTRUCT( double3x3 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w
	};
}

double3x4 translate( const double3x4& mat, const double3& vec )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z
	};
}

double3x4 scale( const double3x4& mat, const double2& vec )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,
		mat.rows[2].w
	};
}

bool cmpe( const double4x2& lhs, const double4x2& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const double4x2& lhs, const double4x2& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double4x2 comp_adds( const double4x2& lhs, const double scalar )
{
	return double4x2(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

double4x2 comp_addm( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x2 comp_subs( const double4x2& lhs, const double scalar )
{
	return double4x2(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

double4x2 comp_subm( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x2 comp_muls( const double4x2& lhs, const double scalar )
{
	return double4x2(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

double4x2 comp_mulm( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x2 comp_divs( const double4x2& lhs, const double scalar )
{
	return double4x2(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

double4x2 comp_divm( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( double4x2 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpl( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmple( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpg( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x2 cmpge( const double4x2& lhs, const double4x2& rhs )
{
	return HLML_CONSTRUCT( bool4x2 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( double4x2& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double2 ) { 1.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double2 ) { 0.0, 1.0 };
	mat.rows[2] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
	mat.rows[3] = HLML_CONSTRUCT( double2 ) { 0.0, 0.0 };
}

double2x4 transpose( const double4x2& mat )
{
	return HLML_CONSTRUCT( double2x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y
	};
}

double4x4 mul( const double4x2& lhs, const double2x4& rhs )
{
	double2 row0 = lhs.rows[0];
	double2 row1 = lhs.rows[1];
	double2 row2 = lhs.rows[2];
	double2 row3 = lhs.rows[3];

	double2 col0 = { rhs.rows[0].x, rhs.rows[1].x };
	double2 col1 = { rhs.rows[0].y, rhs.rows[1].y };
	double2 col2 = { rhs.rows[0].z, rhs.rows[1].z };
	double2 col3 = { rhs.rows[0].w, rhs.rows[1].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y,
		row0.x * col1.x + row0.y * col1.y,
		row0.x * col2.x + row0.y * col2.y,
		row0.x * col3.x + row0.y * col3.y,

		row1.x * col0.x + row1.y * col0.y,
		row1.x * col1.x + row1.y * col1.y,
		row1.x * col2.x + row1.y * col2.y,
		row1.x * col3.x + row1.y * col3.y,

		row2.x * col0.x + row2.y * col0.y,
		row2.x * col1.x + row2.y * col1.y,
		row2.x * col2.x + row2.y * col2.y,
		row2.x * col3.x + row2.y * col3.y,

		row3.x * col0.x + row3.y * col0.y,
		row3.x * col1.x + row3.y * col1.y,
		row3.x * col2.x + row3.y * col2.y,
		row3.x * col3.x + row3.y * col3.y
	};
}

bool cmpe( const double4x3& lhs, const double4x3& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const double4x3& lhs, const double4x3& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double4x3 comp_adds( const double4x3& lhs, const double scalar )
{
	return double4x3(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

double4x3 comp_addm( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x3 comp_subs( const double4x3& lhs, const double scalar )
{
	return double4x3(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

double4x3 comp_subm( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x3 comp_muls( const double4x3& lhs, const double scalar )
{
	return double4x3(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

double4x3 comp_mulm( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x3 comp_divs( const double4x3& lhs, const double scalar )
{
	return double4x3(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

double4x3 comp_divm( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( double4x3 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpl( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmple( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpg( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x3 cmpge( const double4x3& lhs, const double4x3& rhs )
{
	return HLML_CONSTRUCT( bool4x3 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( double4x3& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double3 ) { 1.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double3 ) { 0.0, 1.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 1.0 };
	mat.rows[3] = HLML_CONSTRUCT( double3 ) { 0.0, 0.0, 0.0 };
}

double3x4 transpose( const double4x3& mat )
{
	return HLML_CONSTRUCT( double3x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z
	};
}

double4x4 mul( const double4x3& lhs, const double3x4& rhs )
{
	double3 row0 = lhs.rows[0];
	double3 row1 = lhs.rows[1];
	double3 row2 = lhs.rows[2];
	double3 row3 = lhs.rows[3];

	double3 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x };
	double3 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y };
	double3 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z };
	double3 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z
	};
}

double4x3 scale( const double4x3& mat, const double2& vec )
{
	return HLML_CONSTRUCT( double4x3 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z
	};
}

bool cmpe( const double4x4& lhs, const double4x4& rhs )
{
	return ( lhs[0] == rhs[0] )
		&& ( lhs[1] == rhs[1] )
		&& ( lhs[2] == rhs[2] )
		&& ( lhs[3] == rhs[3] );
}

bool cmpne( const double4x4& lhs, const double4x4& rhs )
{
	return !( cmpe( lhs, rhs ) );
}

double4x4 comp_adds( const double4x4& lhs, const double scalar )
{
	return double4x4(
		lhs[0] + scalar,
		lhs[1] + scalar,
		lhs[2] + scalar,
		lhs[3] + scalar
	);
}

double4x4 comp_addm( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		comp_addv( lhs.rows[0], rhs.rows[0] ),
		comp_addv( lhs.rows[1], rhs.rows[1] ),
		comp_addv( lhs.rows[2], rhs.rows[2] ),
		comp_addv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x4 comp_subs( const double4x4& lhs, const double scalar )
{
	return double4x4(
		lhs[0] - scalar,
		lhs[1] - scalar,
		lhs[2] - scalar,
		lhs[3] - scalar
	);
}

double4x4 comp_subm( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		comp_subv( lhs.rows[0], rhs.rows[0] ),
		comp_subv( lhs.rows[1], rhs.rows[1] ),
		comp_subv( lhs.rows[2], rhs.rows[2] ),
		comp_subv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x4 comp_muls( const double4x4& lhs, const double scalar )
{
	return double4x4(
		lhs[0] * scalar,
		lhs[1] * scalar,
		lhs[2] * scalar,
		lhs[3] * scalar
	);
}

double4x4 comp_mulm( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		comp_mulv( lhs.rows[0], rhs.rows[0] ),
		comp_mulv( lhs.rows[1], rhs.rows[1] ),
		comp_mulv( lhs.rows[2], rhs.rows[2] ),
		comp_mulv( lhs.rows[3], rhs.rows[3] )
	};
}

double4x4 comp_divs( const double4x4& lhs, const double scalar )
{
	return double4x4(
		lhs[0] / scalar,
		lhs[1] / scalar,
		lhs[2] / scalar,
		lhs[3] / scalar
	);
}

double4x4 comp_divm( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( double4x4 ) {
		comp_divv( lhs.rows[0], rhs.rows[0] ),
		comp_divv( lhs.rows[1], rhs.rows[1] ),
		comp_divv( lhs.rows[2], rhs.rows[2] ),
		comp_divv( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpl( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpl( lhs.rows[0], rhs.rows[0] ),
		cmpl( lhs.rows[1], rhs.rows[1] ),
		cmpl( lhs.rows[2], rhs.rows[2] ),
		cmpl( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmple( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmple( lhs.rows[0], rhs.rows[0] ),
		cmple( lhs.rows[1], rhs.rows[1] ),
		cmple( lhs.rows[2], rhs.rows[2] ),
		cmple( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpg( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpg( lhs.rows[0], rhs.rows[0] ),
		cmpg( lhs.rows[1], rhs.rows[1] ),
		cmpg( lhs.rows[2], rhs.rows[2] ),
		cmpg( lhs.rows[3], rhs.rows[3] )
	};
}

bool4x4 cmpge( const double4x4& lhs, const double4x4& rhs )
{
	return HLML_CONSTRUCT( bool4x4 ) {
		cmpge( lhs.rows[0], rhs.rows[0] ),
		cmpge( lhs.rows[1], rhs.rows[1] ),
		cmpge( lhs.rows[2], rhs.rows[2] ),
		cmpge( lhs.rows[3], rhs.rows[3] )
	};
}

void identity( double4x4& mat )
{
	mat.rows[0] = HLML_CONSTRUCT( double4 ) { 1.0, 0.0, 0.0, 0.0 };
	mat.rows[1] = HLML_CONSTRUCT( double4 ) { 0.0, 1.0, 0.0, 0.0 };
	mat.rows[2] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 1.0, 0.0 };
	mat.rows[3] = HLML_CONSTRUCT( double4 ) { 0.0, 0.0, 0.0, 1.0 };
}

double4x4 transpose( const double4x4& mat )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat.rows[0].x, mat.rows[1].x, mat.rows[2].x, mat.rows[3].x,
		mat.rows[0].y, mat.rows[1].y, mat.rows[2].y, mat.rows[3].y,
		mat.rows[0].z, mat.rows[1].z, mat.rows[2].z, mat.rows[3].z,
		mat.rows[0].w, mat.rows[1].w, mat.rows[2].w, mat.rows[3].w
	};
}

double determinant( const double4x4& mat )
{
	// using glm's method where you basically take determinants from each sub matrix and cache the repeat occurences
	double sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	double sub01 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	double sub02 = mat.rows[2].y * mat.rows[3].z - mat.rows[3].y * mat.rows[2].z;
	double sub03 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	double sub04 = mat.rows[2].x * mat.rows[3].z - mat.rows[3].x * mat.rows[2].z;
	double sub05 = mat.rows[2].x * mat.rows[3].y - mat.rows[3].x * mat.rows[2].y;

	double4 cofactor = HLML_CONSTRUCT( double4 ) {
		 ( ( ( mat.rows[1].y * sub00 ) - ( mat.rows[1].z * sub01 ) ) + ( mat.rows[1].w * sub02 ) ),
		-( ( ( mat.rows[1].x * sub00 ) - ( mat.rows[1].z * sub03 ) ) + ( mat.rows[1].w * sub04 ) ),
		 ( ( ( mat.rows[1].x * sub01 ) - ( mat.rows[1].y * sub03 ) ) + ( mat.rows[1].w * sub05 ) ),
		-( ( ( mat.rows[1].x * sub02 ) - ( mat.rows[1].y * sub04 ) ) + ( mat.rows[1].z * sub05 ) ) 
	};

	return
		mat.rows[0].x * cofactor.x + mat.rows[0].y * cofactor.y +
		mat.rows[0].z * cofactor.z + mat.rows[0].w * cofactor.w; 
}

double4x4 inverse( const double4x4& mat )
{
	// uses the glm version, which is basically just an optimised version of the adjugate formula
	double sub00 = mat.rows[2].z * mat.rows[3].w - mat.rows[3].z * mat.rows[2].w;
	double sub01 = mat.rows[1].z * mat.rows[3].w - mat.rows[1].w * mat.rows[2].w;
	double sub02 = mat.rows[1].z * mat.rows[2].w - mat.rows[1].w * mat.rows[2].z;

	double sub03 = mat.rows[2].y * mat.rows[3].w - mat.rows[2].w * mat.rows[3].y;
	double sub04 = mat.rows[1].y * mat.rows[3].w - mat.rows[1].w * mat.rows[3].y;
	double sub05 = mat.rows[1].y * mat.rows[2].w - mat.rows[1].w * mat.rows[2].y;

	double sub06 = mat.rows[2].y * mat.rows[3].z - mat.rows[2].z * mat.rows[3].y;
	double sub07 = mat.rows[1].y * mat.rows[3].z - mat.rows[1].z * mat.rows[3].y;
	double sub08 = mat.rows[1].y * mat.rows[2].z - mat.rows[1].z * mat.rows[2].y;

	double sub09 = mat.rows[2].x * mat.rows[3].w - mat.rows[3].x * mat.rows[2].w;
	double sub10 = mat.rows[1].x * mat.rows[3].w - mat.rows[3].x * mat.rows[1].w;
	double sub11 = mat.rows[1].x * mat.rows[2].w - mat.rows[2].x * mat.rows[1].w;

	double sub12 = mat.rows[2].x * mat.rows[3].z - mat.rows[2].z * mat.rows[3].x;
	double sub13 = mat.rows[1].x * mat.rows[3].z - mat.rows[1].z * mat.rows[3].x;
	double sub14 = mat.rows[1].x * mat.rows[2].z - mat.rows[1].z * mat.rows[2].x;

	double sub15 = mat.rows[2].x * mat.rows[3].y - mat.rows[2].y * mat.rows[3].x;
	double sub16 = mat.rows[1].x * mat.rows[3].y - mat.rows[1].y * mat.rows[3].x;
	double sub17 = mat.rows[1].x * mat.rows[2].y - mat.rows[1].y * mat.rows[2].x;

	double4 fac0 = double4( sub00, sub00, sub01, sub02 );
	double4 fac1 = double4( sub03, sub03, sub04, sub05 );
	double4 fac2 = double4( sub06, sub06, sub07, sub08 );
	double4 fac3 = double4( sub09, sub09, sub10, sub11 );
	double4 fac4 = double4( sub12, sub12, sub13, sub14 );
	double4 fac5 = double4( sub15, sub15, sub16, sub17 );

	double4 vec0 = double4( mat.rows[1].x, mat.rows[0].x, mat.rows[0].x, mat.rows[0].x );
	double4 vec1 = double4( mat.rows[1].y, mat.rows[0].y, mat.rows[0].y, mat.rows[0].y );
	double4 vec2 = double4( mat.rows[1].z, mat.rows[0].z, mat.rows[0].z, mat.rows[0].z );
	double4 vec3 = double4( mat.rows[1].w, mat.rows[0].w, mat.rows[0].w, mat.rows[0].w );

	double4 inv0 = vec1 * fac0 - vec2 * fac1 + vec3 * fac2;
	double4 inv1 = vec0 * fac0 - vec2 * fac3 + vec3 * fac4;
	double4 inv2 = vec0 * fac1 - vec1 * fac3 + vec3 * fac5;
	double4 inv3 = vec0 * fac2 - vec1 * fac4 + vec2 * fac5;

	double4 sign0 = double4(  1, -1,  1, -1 );
	double4 sign1 = double4( -1,  1, -1,  1 );

	double4x4 result = double4x4(
		inv0 * sign0,
		inv1 * sign1,
		inv2 * sign0,
		inv3 * sign1
	);

	double4 col0 = double4( result.rows[0].x, result.rows[1].x, result.rows[2].x, result.rows[3].x );
	double4 dot0 = mat.rows[0] * col0;

	const double dot1 = ( dot0.x + dot0.y ) + ( dot0.z + dot0.w );

	const double invdet = 1.0 / dot1;

	return comp_muls( result, invdet );
}

double4x4 mul( const double4x4& lhs, const double4x4& rhs )
{
	double4 row0 = lhs.rows[0];
	double4 row1 = lhs.rows[1];
	double4 row2 = lhs.rows[2];
	double4 row3 = lhs.rows[3];

	double4 col0 = { rhs.rows[0].x, rhs.rows[1].x, rhs.rows[2].x, rhs.rows[3].x };
	double4 col1 = { rhs.rows[0].y, rhs.rows[1].y, rhs.rows[2].y, rhs.rows[3].y };
	double4 col2 = { rhs.rows[0].z, rhs.rows[1].z, rhs.rows[2].z, rhs.rows[3].z };
	double4 col3 = { rhs.rows[0].w, rhs.rows[1].w, rhs.rows[2].w, rhs.rows[3].w };

	return HLML_CONSTRUCT( double4x4 ) {
		row0.x * col0.x + row0.y * col0.y + row0.z * col0.z + row0.w * col0.w,
		row0.x * col1.x + row0.y * col1.y + row0.z * col1.z + row0.w * col1.w,
		row0.x * col2.x + row0.y * col2.y + row0.z * col2.z + row0.w * col2.w,
		row0.x * col3.x + row0.y * col3.y + row0.z * col3.z + row0.w * col3.w,

		row1.x * col0.x + row1.y * col0.y + row1.z * col0.z + row1.w * col0.w,
		row1.x * col1.x + row1.y * col1.y + row1.z * col1.z + row1.w * col1.w,
		row1.x * col2.x + row1.y * col2.y + row1.z * col2.z + row1.w * col2.w,
		row1.x * col3.x + row1.y * col3.y + row1.z * col3.z + row1.w * col3.w,

		row2.x * col0.x + row2.y * col0.y + row2.z * col0.z + row2.w * col0.w,
		row2.x * col1.x + row2.y * col1.y + row2.z * col1.z + row2.w * col1.w,
		row2.x * col2.x + row2.y * col2.y + row2.z * col2.z + row2.w * col2.w,
		row2.x * col3.x + row2.y * col3.y + row2.z * col3.z + row2.w * col3.w,

		row3.x * col0.x + row3.y * col0.y + row3.z * col0.z + row3.w * col0.w,
		row3.x * col1.x + row3.y * col1.y + row3.z * col1.z + row3.w * col1.w,
		row3.x * col2.x + row3.y * col2.y + row3.z * col2.z + row3.w * col2.w,
		row3.x * col3.x + row3.y * col3.y + row3.z * col3.z + row3.w * col3.w
	};
}

double4 mul( const double4x4& lhs, const double4& rhs )
{
	return HLML_CONSTRUCT( double4 ) {
		lhs.rows[0].x * rhs.x + lhs.rows[0].y * rhs.y + lhs.rows[0].z * rhs.z + lhs.rows[0].w * rhs.w,
		lhs.rows[1].x * rhs.x + lhs.rows[1].y * rhs.y + lhs.rows[1].z * rhs.z + lhs.rows[1].w * rhs.w,
		lhs.rows[2].x * rhs.x + lhs.rows[2].y * rhs.y + lhs.rows[2].z * rhs.z + lhs.rows[2].w * rhs.w,
		lhs.rows[3].x * rhs.x + lhs.rows[3].y * rhs.y + lhs.rows[3].z * rhs.z + lhs.rows[3].w * rhs.w
	};
}

double4x4 translate( const double4x4& mat, const double3& vec )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat.rows[0].x, mat.rows[0].y, mat.rows[0].z, mat.rows[0].w + vec.x,
		mat.rows[1].x, mat.rows[1].y, mat.rows[1].z, mat.rows[1].w + vec.y,
		mat.rows[2].x, mat.rows[2].y, mat.rows[2].z, mat.rows[2].w + vec.z,
		mat.rows[3].x, mat.rows[3].y, mat.rows[3].z, mat.rows[3].w
	};
}

double4x4 rotate( const double4x4& mat, const double rad, const double3& axis )
{
	const double c = cos( rad );
	const double s = sin( rad );

	double3 u = normalized( axis );
	double ic = 1.0 - c;

	double4x4 rotation = mat;
	rotation.rows[0].x = c + u.x * ic;
	rotation.rows[0].y = u.x * u.y * ic - u.z * s;
	rotation.rows[0].z = u.x * u.z * ic + u.y * s;

	rotation.rows[1].x = u.y * u.x * ic + u.z * s;
	rotation.rows[1].y = c + u.y * ic;
	rotation.rows[1].z = u.y * u.z * ic - u.x * s;

	rotation.rows[2].x = u.z * u.x * ic - u.y * s;
	rotation.rows[2].y = u.z * u.y * ic + u.x * s;
	rotation.rows[2].z = c + u.z * ic;

	return mul( mat, rotation );
}

double4x4 scale( const double4x4& mat, const double3& vec )
{
	return HLML_CONSTRUCT( double4x4 ) {
		mat.rows[0].x * vec.x,
		mat.rows[0].y,
		mat.rows[0].z,
		mat.rows[0].w,

		mat.rows[1].x,
		mat.rows[1].y * vec.y,
		mat.rows[1].z,
		mat.rows[1].w,

		mat.rows[2].x,
		mat.rows[2].y,
		mat.rows[2].z * vec.z,
		mat.rows[2].w,

		mat.rows[3].x,
		mat.rows[3].y,
		mat.rows[3].z,
		mat.rows[3].w
	};
}

double4x4 ortho_lh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip-space range: zero to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 ortho_lh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// left-handed, clip-space range: minus-one to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, 2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 ortho_rh_zo( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip-space range: zero to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -1.0 / far_minus_near, -znear / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 ortho_rh_no( const double left, const double right, const double top, const double bottom, const double znear, const double zfar )
{
	// right-handed, clip-space range: minus-one to one
	const double right_minus_left = right - left;
	const double right_plus_left = right + left;
	const double top_minus_bottom = top - bottom;
	const double top_plus_bottom = top + bottom;
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;

	return HLML_CONSTRUCT( double4x4 ) {
		2.0 / right_minus_left, 0.0, 0.0, -right_plus_left / right_minus_left,
		0.0, 2.0 / top_minus_bottom, 0.0, -top_plus_bottom / top_minus_bottom,
		0.0, 0.0, -2.0 / far_minus_near, -far_plus_near / far_minus_near,
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 perspective_lh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: zero to one
	const double far_minus_near = zfar - znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / far_minus_near, -( zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

double4x4 perspective_lh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// left-handed, clip space range: minus-one to one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, 1.0, 0.0
	};
}

double4x4 perspective_rh_zo( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: zero to one
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, zfar / ( znear - zfar ), -( zfar * znear ) / ( zfar - znear ),
		0.0, 0.0, -1.0, 0.0
	};
}

double4x4 perspective_rh_no( const double fovdeg, const double aspect, const double znear, const double zfar )
{
	// right-handed, clip space range: minus-one to one
	const double far_minus_near = zfar - znear;
	const double far_plus_near = zfar + znear;
	const double tan_half_fov = tan( fovdeg * 0.5 );

	return HLML_CONSTRUCT( double4x4 ) {
		1.0 / ( aspect * tan_half_fov ), 0.0, 0.0, 0.0,
		0.0, 1.0 / tan_half_fov, 0.0, 0.0,
		0.0, 0.0, -far_plus_near / far_minus_near, -( 2.0 * zfar * znear ) / far_minus_near,
		0.0, 0.0, -1.0, 0.0
	};
}

double4x4 lookat_lh( const double3& eye, const double3& target, const double3& up )
{
	// left handed
	const double3 forward = normalized( target - eye );
	const double3 right = normalized( cross( up, forward ) );
	const double3 up1 = cross( forward, right );

	return HLML_CONSTRUCT( double4x4 ) {
		right.x,   right.y,   right.z,   -dot( right, eye ),
		up1.x,     up1.y,     up1.z,     -dot( up1, eye ),
		forward.x, forward.y, forward.z, -dot( forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

double4x4 lookat_rh( const double3& eye, const double3& target, const double3& up )
{
	// right handed
	const double3 forward = normalized( target - eye );
	const double3 right = normalized( cross( forward, up ) );
	const double3 up1 = cross( right, forward );

	return HLML_CONSTRUCT( double4x4 ) {
		 right.x,    right.y,    right.z,   -dot( right, eye ),
		 up1.x,      up1.y,      up1.z,     -dot( up1, eye ),
		-forward.x, -forward.y, -forward.z,  dot( forward, eye ),
		0.0, 0.0, 0.0, 1.0
	};
}

#if defined( __GNUC__ ) || defined( __clang__ )
#pragma GCC diagnostic pop
#endif
#endif // HLML_IMPLEMENTATION
